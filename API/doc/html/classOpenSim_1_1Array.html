<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>OpenSim: Array Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceOpenSim.html">OpenSim</a>::<a class="el" href="classOpenSim_1_1Array.html">Array</a>
  </div>
</div>
<div class="contents">
<h1>Array Class Template Reference</h1><!-- doxytag: class="OpenSim::Array" --><code>#include &lt;<a class="el" href="Array_8h-source.html">Array.h</a>&gt;</code>
<p>

<p>
<a href="classOpenSim_1_1Array-members.html">List of all members.</a><h3>template&lt;class T&gt;<br>
 class OpenSim::Array&lt; T &gt;</h3>

<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#4397a572b12256eb1217355167e5f392">~Array</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#4397a572b12256eb1217355167e5f392"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#e9b4c6d5c7e525c5e042df294e5f43e8">Array</a> (const T &amp;aDefaultValue=T(), int aSize=0, int aCapacity=Array_CAPMIN)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#e9b4c6d5c7e525c5e042df294e5f43e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#af55b0598d695a0b6fdc9aca41415cd8">Array</a> (const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;aArray)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coppy constructor.  <a href="#af55b0598d695a0b6fdc9aca41415cd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#7c70748e89ebf9f5ae24f27b2db55fe5">arrayEquals</a> (const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;aArray) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#2cb41ffab493a991783a723b5135ae01">operator[]</a> (int aIndex) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the array element at a specified index.  <a href="#2cb41ffab493a991783a723b5135ae01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#4b5a6917bb3e4b6907b24f4a7599c969">operator=</a> (const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;aArray)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign this array to a specified array.  <a href="#4b5a6917bb3e4b6907b24f4a7599c969"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#7a1669fe2d256f9fd56bde155bf5a6d2">operator==</a> (const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;aArray) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if two arrays are equal.  <a href="#7a1669fe2d256f9fd56bde155bf5a6d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#a71696943692d36cc2887f3520bbe7a8">computeNewCapacity</a> (int aMinCapacity, int &amp;rNewCapacity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a new capacity that is at least as large as a specified minimum capacity; this method does not change the capacity, it simply computes a new recommended capacity.  <a href="#a71696943692d36cc2887f3520bbe7a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#747422d44fe0ba2bcbd08cbc8cef5894">ensureCapacity</a> (int aCapacity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure that the capacity of this array is at least the specified amount.  <a href="#747422d44fe0ba2bcbd08cbc8cef5894"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#268ae12a22c9f97b84833e4c39fb2278">trim</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Trim the capacity of this array so that it is one larger than the size of this array.  <a href="#268ae12a22c9f97b84833e4c39fb2278"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#fa0ceece31dc5085e27abcef7cfb6fd8">getCapacity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the capacity of this storage instance.  <a href="#fa0ceece31dc5085e27abcef7cfb6fd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#e12a54c741b67e221676bc54d7501529">setCapacityIncrement</a> (int aIncrement)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the amount by which the capacity is increased when the capacity of of the array in exceeded.  <a href="#e12a54c741b67e221676bc54d7501529"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#91a6bbeaf350334e001995c1402af16a">getCapacityIncrement</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the amount by which the capacity is increased.  <a href="#91a6bbeaf350334e001995c1402af16a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#35e9fd950f4fb68fc488f1bc75e78316">setSize</a> (int aSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the size of the array.  <a href="#35e9fd950f4fb68fc488f1bc75e78316"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#4f8dbb76319fe40792867d6ca51ef447">getSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of the array.  <a href="#4f8dbb76319fe40792867d6ca51ef447"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#d7e2d01fc8f88f8f430ba534b8e1c92d">append</a> (const T &amp;aValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a value onto the array.  <a href="#d7e2d01fc8f88f8f430ba534b8e1c92d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#deab5c727d059faa0a1e5581ca67cadb">append</a> (const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;aArray)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an array of values.  <a href="#deab5c727d059faa0a1e5581ca67cadb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#fe1b46efab87dcc37cf1c7a45c0cca94">append</a> (int aSize, const T *aArray)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an array of values.  <a href="#fe1b46efab87dcc37cf1c7a45c0cca94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#93feb1ba647be9015c5ae6cbbb4b5ef1">insert</a> (int aIndex, const T &amp;aValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a value into the array at a specified index.  <a href="#93feb1ba647be9015c5ae6cbbb4b5ef1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#4851b93f73459383aebae9c2f5a42e7e">remove</a> (int aIndex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a value from the array at a specified index.  <a href="#4851b93f73459383aebae9c2f5a42e7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#cbce04822db23e13419bd858ca7c30ff">set</a> (int aIndex, const T &amp;aValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the value at a specified index.  <a href="#cbce04822db23e13419bd858ca7c30ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#c051b2568208e363ae2dffb23c0ad9ba">get</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the low-level array.  <a href="#c051b2568208e363ae2dffb23c0ad9ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#919f0a4ccce2a24c3941433289bb7e70">get</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a pointer to the low-level array.  <a href="#919f0a4ccce2a24c3941433289bb7e70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#f372ae00da0d551b53ad83275ba3ca28">get</a> (int aIndex) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value at a specified array index.  <a href="#f372ae00da0d551b53ad83275ba3ca28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#c06235aebed59203bfbd8003bb926964">getLast</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the last value in the array.  <a href="#c06235aebed59203bfbd8003bb926964"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#be088dd2cd7c3f44820141354901a8a9">findIndex</a> (const T &amp;aValue) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linear search for an element matching a given value.  <a href="#be088dd2cd7c3f44820141354901a8a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#50c65ea881271b36e0f2f4f6c9aed1c1">rfindIndex</a> (const T &amp;aValue) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linear search in reverse for an element matching a given value.  <a href="#50c65ea881271b36e0f2f4f6c9aed1c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#785cb8e3d9adf5f36487dad6361ac33b">searchBinary</a> (const T &amp;aValue, bool aFindFirst=false, int aLo=-1, int aHi=-1) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for the largest value in the array that is less than or equal to a specified value.  <a href="#785cb8e3d9adf5f36487dad6361ac33b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#aa6c8c862a2c0bc18c802314cc58961d">_size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of the array.  <a href="#aa6c8c862a2c0bc18c802314cc58961d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#dc9ca8d1d3cf06b3975b6e768a942c61">_capacity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current capacity of the array.  <a href="#dc9ca8d1d3cf06b3975b6e768a942c61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#ba9b915a20e0bf5cde72a3103e04a9e4">_capacityIncrement</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment by which the current capacity is increased when the capacity of this storage instance is reached.  <a href="#ba9b915a20e0bf5cde72a3103e04a9e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#a97adea9ae306791f01d92fee0df5e60">_defaultValue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default value of elements.  <a href="#a97adea9ae306791f01d92fee0df5e60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#2371cfbba1b0a27d949f87c9ae047a8c">_array</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Array.html">Array</a> of values.  <a href="#2371cfbba1b0a27d949f87c9ae047a8c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Array.html#9de7cd20d4d15367196d207c9628b57b">operator&lt;&lt;</a> (std::ostream &amp;aOut, const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;aArray)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the output operator.  <a href="#9de7cd20d4d15367196d207c9628b57b"></a><br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4397a572b12256eb1217355167e5f392"></a><!-- doxytag: member="OpenSim::Array::~Array" ref="4397a572b12256eb1217355167e5f392" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classOpenSim_1_1Array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
When the array is deleted, references to elements of this array become invalid. 
</div>
</div><p>
<a class="anchor" name="e9b4c6d5c7e525c5e042df294e5f43e8"></a><!-- doxytag: member="OpenSim::Array::Array" ref="e9b4c6d5c7e525c5e042df294e5f43e8" args="(const T &amp;aDefaultValue=T(), int aSize=0, int aCapacity=Array_CAPMIN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>aDefaultValue</em> = <code>T()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aCapacity</em> = <code>Array_CAPMIN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDefaultValue</em>&nbsp;</td><td>Default value of an array element. This value is used to initialize array elements as the size of the array is changed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aSize</em>&nbsp;</td><td>Initial size of the array. The array elements are initialized to aDefaultValue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCapacity</em>&nbsp;</td><td>Initial capacity of the array. The initial capacity is guarranteed to be at least as large as aSize + 1. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="af55b0598d695a0b6fdc9aca41415cd8"></a><!-- doxytag: member="OpenSim::Array::Array" ref="af55b0598d695a0b6fdc9aca41415cd8" args="(const Array&lt; T &gt; &amp;aArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aArray</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Coppy constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aArray</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> to be copied. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7c70748e89ebf9f5ae24f27b2db55fe5"></a><!-- doxytag: member="OpenSim::Array::arrayEquals" ref="7c70748e89ebf9f5ae24f27b2db55fe5" args="(const Array&lt; T &gt; &amp;aArray) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrayEquals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aArray</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2cb41ffab493a991783a723b5135ae01"></a><!-- doxytag: member="OpenSim::Array::operator[]" ref="2cb41ffab493a991783a723b5135ae01" args="(int aIndex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator[]           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the array element at a specified index. 
<p>
This overloaded operator can be used both to set and get element values:<br>
 &lt;T&gt; array(2);<br>
  value = array[i];<br>
 [i] = value;<br>
<br>
<p>
This operator is intended for accessing array elements with as little overhead as possible, so no error checking is performed. The caller must make sure the specified index is within the bounds of the array. If error checking is desired, use <a class="el" href="classOpenSim_1_1Array.html#c051b2568208e363ae2dffb23c0ad9ba" title="Get a pointer to the low-level array.">Array::get()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aIndex</em>&nbsp;</td><td>Index of the desired element (0 &lt;= aIndex &lt; _size). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Reference to the array element. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1Array.html#c051b2568208e363ae2dffb23c0ad9ba" title="Get a pointer to the low-level array.">get()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b5a6917bb3e4b6907b24f4a7599c969"></a><!-- doxytag: member="OpenSim::Array::operator=" ref="4b5a6917bb3e4b6907b24f4a7599c969" args="(const Array&lt; T &gt; &amp;aArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt;T&gt;&amp; operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aArray</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign this array to a specified array. 
<p>
This operator makes a complete copy of the specified array; all member variables are copied. So, the result is two identical, independent arrays.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aArray</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> to be copied. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Reference to this array. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a1669fe2d256f9fd56bde155bf5a6d2"></a><!-- doxytag: member="OpenSim::Array::operator==" ref="7a1669fe2d256f9fd56bde155bf5a6d2" args="(const Array&lt; T &gt; &amp;aArray) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aArray</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if two arrays are equal. 
<p>
Two arrays are equal if their contents are equal. That is, each array must be the same length and their corresponding array elements must be equal.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aArray</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> to be tested as equal. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if equal, false if not equal. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a71696943692d36cc2887f3520bbe7a8"></a><!-- doxytag: member="OpenSim::Array::computeNewCapacity" ref="a71696943692d36cc2887f3520bbe7a8" args="(int aMinCapacity, int &amp;rNewCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool computeNewCapacity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aMinCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>rNewCapacity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute a new capacity that is at least as large as a specified minimum capacity; this method does not change the capacity, it simply computes a new recommended capacity. 
<p>
If the capacity increment is negative, the current capacity is doubled until the computed capacity is greater than or equal to the specified minimum capacity. If the capacity increment is positive, the current capacity increment by this amount until the computed capacity is greater than or equal to the specified minimum capacity. If the capacity increment is zero, the computed capacity is set to the current capacity and false is returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rNewCapacity</em>&nbsp;</td><td>New computed capacity. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aMinCapacity</em>&nbsp;</td><td>Minimum new computed capacity. The computed capacity is incremented until it is at least as large as aMinCapacity, assuming the capacity increment is not zero. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the new capacity was increased, false otherwise (i.e., if the capacity increment is set to 0). </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1Array.html#e12a54c741b67e221676bc54d7501529" title="Set the amount by which the capacity is increased when the capacity of of the array...">setCapacityIncrement()</a> </dd></dl>

<p>Referenced by <a class="el" href="Array_8h-source.html#l00486">Array&lt; OpenSim::AbstractActuator * &gt;::append()</a>, <a class="el" href="Array_8h-source.html#l00105">Array&lt; OpenSim::AbstractActuator * &gt;::Array()</a>, <a class="el" href="Array_8h-source.html#l00564">Array&lt; OpenSim::AbstractActuator * &gt;::insert()</a>, <a class="el" href="Array_8h-source.html#l00654">Array&lt; OpenSim::AbstractActuator * &gt;::set()</a>, and <a class="el" href="Array_8h-source.html#l00443">Array&lt; OpenSim::AbstractActuator * &gt;::setSize()</a>.</p>

</div>
</div><p>
<a class="anchor" name="747422d44fe0ba2bcbd08cbc8cef5894"></a><!-- doxytag: member="OpenSim::Array::ensureCapacity" ref="747422d44fe0ba2bcbd08cbc8cef5894" args="(int aCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ensureCapacity           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aCapacity</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ensure that the capacity of this array is at least the specified amount. 
<p>
Note that the newly allocated array elements are not initialized.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aCapacity</em>&nbsp;</td><td>Desired capacity. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the capacity was successfully obtained, false otherwise. </dd></dl>

<p>Referenced by <a class="el" href="Array_8h-source.html#l00486">Array&lt; OpenSim::AbstractActuator * &gt;::append()</a>, <a class="el" href="Array_8h-source.html#l00105">Array&lt; OpenSim::AbstractActuator * &gt;::Array()</a>, <a class="el" href="Array_8h-source.html#l00564">Array&lt; OpenSim::AbstractActuator * &gt;::insert()</a>, <a class="el" href="Array_8h-source.html#l00654">Array&lt; OpenSim::AbstractActuator * &gt;::set()</a>, and <a class="el" href="Array_8h-source.html#l00443">Array&lt; OpenSim::AbstractActuator * &gt;::setSize()</a>.</p>

</div>
</div><p>
<a class="anchor" name="268ae12a22c9f97b84833e4c39fb2278"></a><!-- doxytag: member="OpenSim::Array::trim" ref="268ae12a22c9f97b84833e4c39fb2278" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trim           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Trim the capacity of this array so that it is one larger than the size of this array. 
<p>
This is useful for reducing the amount of memory used by this array. This capacity is kept at one larger than the size so that, for example, an array of characters can be treated as a NULL terminated string. 
</div>
</div><p>
<a class="anchor" name="fa0ceece31dc5085e27abcef7cfb6fd8"></a><!-- doxytag: member="OpenSim::Array::getCapacity" ref="fa0ceece31dc5085e27abcef7cfb6fd8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getCapacity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the capacity of this storage instance. 
<p>

</div>
</div><p>
<a class="anchor" name="e12a54c741b67e221676bc54d7501529"></a><!-- doxytag: member="OpenSim::Array::setCapacityIncrement" ref="e12a54c741b67e221676bc54d7501529" args="(int aIncrement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setCapacityIncrement           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aIncrement</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the amount by which the capacity is increased when the capacity of of the array in exceeded. 
<p>
If the specified increment is negative, the capacity is set to double whenever the capacity is exceeded.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aIncrement</em>&nbsp;</td><td>Desired capacity increment. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="91a6bbeaf350334e001995c1402af16a"></a><!-- doxytag: member="OpenSim::Array::getCapacityIncrement" ref="91a6bbeaf350334e001995c1402af16a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getCapacityIncrement           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the amount by which the capacity is increased. 
<p>

</div>
</div><p>
<a class="anchor" name="35e9fd950f4fb68fc488f1bc75e78316"></a><!-- doxytag: member="OpenSim::Array::setSize" ref="35e9fd950f4fb68fc488f1bc75e78316" args="(int aSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setSize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aSize</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the size of the array. 
<p>
This method can be used to either increase or decrease the size of the array. If this size of the array is increased, the new elements are initialized to the default value that was specified at the time of construction.<p>
Note that the size of an array is different than its capacity. The size indicates how many valid elements are stored in an array. The capacity indicates how much the size of the array can be increased without allocated more memory. At all times size &lt;= capacity.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aSize</em>&nbsp;</td><td>Desired size of the array. The size must be greater than or equal to zero. </td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="Set_8h-source.html#l00794">Set&lt; OpenSim::BodyScale &gt;::getGroupNames()</a>, <a class="el" href="Set_8h-source.html#l00468">Set&lt; OpenSim::BodyScale &gt;::getGroupNamesContaining()</a>, and <a class="el" href="Array_8h-source.html#l00564">Array&lt; OpenSim::AbstractActuator * &gt;::insert()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4f8dbb76319fe40792867d6ca51ef447"></a><!-- doxytag: member="OpenSim::Array::getSize" ref="4f8dbb76319fe40792867d6ca51ef447" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the size of the array. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of the array. </dd></dl>

<p>Referenced by <a class="el" href="Array_8h-source.html#l00512">Array&lt; OpenSim::AbstractActuator * &gt;::append()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d7e2d01fc8f88f8f430ba534b8e1c92d"></a><!-- doxytag: member="OpenSim::Array::append" ref="d7e2d01fc8f88f8f430ba534b8e1c92d" args="(const T &amp;aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int append           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>aValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append a value onto the array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value to be appended. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>New size of the array, or, equvalently, the index to the new first empty element of the array. </dd></dl>

<p>Referenced by <a class="el" href="Array_8h-source.html#l00512">Array&lt; OpenSim::AbstractActuator * &gt;::append()</a>, <a class="el" href="Set_8h-source.html#l00794">Set&lt; OpenSim::BodyScale &gt;::getGroupNames()</a>, <a class="el" href="Set_8h-source.html#l00468">Set&lt; OpenSim::BodyScale &gt;::getGroupNamesContaining()</a>, and <a class="el" href="Set_8h-source.html#l00671">Set&lt; OpenSim::BodyScale &gt;::getNames()</a>.</p>

</div>
</div><p>
<a class="anchor" name="deab5c727d059faa0a1e5581ca67cadb"></a><!-- doxytag: member="OpenSim::Array::append" ref="deab5c727d059faa0a1e5581ca67cadb" args="(const Array&lt; T &gt; &amp;aArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int append           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aArray</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append an array of values. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aArray</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> of values to append. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>New size of the array, or, equvalently, the index to the new first empty element of the array. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe1b46efab87dcc37cf1c7a45c0cca94"></a><!-- doxytag: member="OpenSim::Array::append" ref="fe1b46efab87dcc37cf1c7a45c0cca94" args="(int aSize, const T *aArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int append           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>aArray</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append an array of values. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aSize</em>&nbsp;</td><td>Size of the array to append. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aArray</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> of values to append. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>New size of the array, or, equvalently, the index to the new first empty element of the array. </dd></dl>

</div>
</div><p>
<a class="anchor" name="93feb1ba647be9015c5ae6cbbb4b5ef1"></a><!-- doxytag: member="OpenSim::Array::insert" ref="93feb1ba647be9015c5ae6cbbb4b5ef1" args="(int aIndex, const T &amp;aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int insert           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a value into the array at a specified index. 
<p>
This method is relatively computationally costly since many of the array elements may need to be shifted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value to be inserted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aIndex</em>&nbsp;</td><td>Index at which to insert the new value. All current elements from aIndex to the end of the array are shifted one place in the direction of the end of the array. If the specified index is greater than the current size of the array, the size of the array is increased to aIndex+1 and the itervening new elements are initialized to the default value that was specified at the time of construction. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of the array after the insertion. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4851b93f73459383aebae9c2f5a42e7e"></a><!-- doxytag: member="OpenSim::Array::remove" ref="4851b93f73459383aebae9c2f5a42e7e" args="(int aIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int remove           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a value from the array at a specified index. 
<p>
This method is relatively computationally costly since many of the array elements may need to be shifted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aIndex</em>&nbsp;</td><td>Index of the value to remove. All elements from aIndex to the end of the array are shifted one place toward the beginning of the array. If aIndex is less than 0 or greater than or equal to the current size of the array, no element is removed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of the array after the removal. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cbce04822db23e13419bd858ca7c30ff"></a><!-- doxytag: member="OpenSim::Array::set" ref="cbce04822db23e13419bd858ca7c30ff" args="(int aIndex, const T &amp;aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the value at a specified index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aIndex</em>&nbsp;</td><td>Index of the array element to be set. It is permissible for aIndex to be past the current end of the array- the capacity will be increased if necessary. Values between the current end of the array and aIndex are not initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c051b2568208e363ae2dffb23c0ad9ba"></a><!-- doxytag: member="OpenSim::Array::get" ref="c051b2568208e363ae2dffb23c0ad9ba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* get           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the low-level array. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the low-level array. </dd></dl>

</div>
</div><p>
<a class="anchor" name="919f0a4ccce2a24c3941433289bb7e70"></a><!-- doxytag: member="OpenSim::Array::get" ref="919f0a4ccce2a24c3941433289bb7e70" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const T* get           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a pointer to the low-level array. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the low-level array. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f372ae00da0d551b53ad83275ba3ca28"></a><!-- doxytag: member="OpenSim::Array::get" ref="f372ae00da0d551b53ad83275ba3ca28" args="(int aIndex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; get           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the value at a specified array index. 
<p>
If the index is negative or passed the end of the array, an exception is thrown.<p>
For faster execution, the array elements can be accessed through the overloaded operator[], which does no bounds checking.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aIndex</em>&nbsp;</td><td>Index of the desired array element. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Reference to the array element. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classOpenSim_1_1Exception.html">Exception</a></em>&nbsp;</td><td>if (aIndex&lt;0)||(aIndex&gt;=_size). </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>operator[]. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c06235aebed59203bfbd8003bb926964"></a><!-- doxytag: member="OpenSim::Array::getLast" ref="c06235aebed59203bfbd8003bb926964" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; getLast           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the last value in the array. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Last value in the array. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classOpenSim_1_1Exception.html">Exception</a></em>&nbsp;</td><td>if the array is empty. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="be088dd2cd7c3f44820141354901a8a9"></a><!-- doxytag: member="OpenSim::Array::findIndex" ref="be088dd2cd7c3f44820141354901a8a9" args="(const T &amp;aValue) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int findIndex           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>aValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Linear search for an element matching a given value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value to which the array elements are compared. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Index of the array element matching aValue. If there is more than one such elements with the same value the index of the first of these elements is returned. If no match is found, -1 is returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="50c65ea881271b36e0f2f4f6c9aed1c1"></a><!-- doxytag: member="OpenSim::Array::rfindIndex" ref="50c65ea881271b36e0f2f4f6c9aed1c1" args="(const T &amp;aValue) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rfindIndex           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>aValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Linear search in reverse for an element matching a given value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value to which the array elements are compared. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Index of the array element matching aValue. If there is more than one such elements with the same value the index of the last of these elements is returned. If no match is found, -1 is returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="785cb8e3d9adf5f36487dad6361ac33b"></a><!-- doxytag: member="OpenSim::Array::searchBinary" ref="785cb8e3d9adf5f36487dad6361ac33b" args="(const T &amp;aValue, bool aFindFirst=false, int aLo=-1, int aHi=-1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int searchBinary           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>aValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aFindFirst</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aLo</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aHi</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search for the largest value in the array that is less than or equal to a specified value. 
<p>
If there is more than one element with this largest value, the index of the first of these elements can optionally be found, but this can be up to twice as costly.<p>
This method assumes that the array element values monotonically increase as the array index increases. Note that monotonically increase means never decrease, so it is permissible for elements to<p>
A binary search is performed (i.e., the array is repeatedly subdivided into two bins one of which must contain the specified until the approprite element is identified), so the performance of this method is approximately ln(n), where n is the size of the array.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value to which the array elements are compared. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aFindFirst</em>&nbsp;</td><td>If true, find the first element that satisfies the search. If false, the index of any element that satisfies the search can be returned- which index will be returned depends on the length of the array and is therefore somewhat arbitrary. By default, this flag is false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aLo</em>&nbsp;</td><td>Lowest array index to consider in the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aHi</em>&nbsp;</td><td>Highest array index to consider in the search. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Index of the array element that has the largest value that is less than or equal to aValue. If there is more than one such elements with the same value and aFindFirst is set to true, the index of the first of these elements is returned. If an error is encountered (e.g., the array is empty), or the array contains no element that is less than or equal to aValue, -1 is returned. </dd></dl>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="9de7cd20d4d15367196d207c9628b57b"></a><!-- doxytag: member="OpenSim::Array::operator&lt;&lt;" ref="9de7cd20d4d15367196d207c9628b57b" args="(std::ostream &amp;aOut, const Array&lt; T &gt; &amp;aArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>aOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aArray</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementation of the output operator. 
<p>
The output for an array looks like the following:<br>
<br>
<p>
<a class="el" href="classOpenSim_1_1Array.html">Array</a>[size] = T[0] T[1] T[2] ... T[size-1].<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aOut</em>&nbsp;</td><td>Output stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aArray</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> to be output. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Reference to the output stream. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="aa6c8c862a2c0bc18c802314cc58961d"></a><!-- doxytag: member="OpenSim::Array::_size" ref="aa6c8c862a2c0bc18c802314cc58961d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Array.html#aa6c8c862a2c0bc18c802314cc58961d">_size</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size of the array. 
<p>
Also the index of the first empty array element. 
<p>Referenced by <a class="el" href="Array_8h-source.html#l00486">Array&lt; OpenSim::AbstractActuator * &gt;::append()</a>, <a class="el" href="Array_8h-source.html#l00105">Array&lt; OpenSim::AbstractActuator * &gt;::Array()</a>, <a class="el" href="Array_8h-source.html#l00323">Array&lt; OpenSim::AbstractActuator * &gt;::ensureCapacity()</a>, <a class="el" href="Array_8h-source.html#l00756">Array&lt; OpenSim::AbstractActuator * &gt;::findIndex()</a>, <a class="el" href="Array_8h-source.html#l00711">Array&lt; OpenSim::AbstractActuator * &gt;::get()</a>, <a class="el" href="Array_8h-source.html#l00735">Array&lt; OpenSim::AbstractActuator * &gt;::getLast()</a>, <a class="el" href="Array_8h-source.html#l00470">Array&lt; OpenSim::AbstractActuator * &gt;::getSize()</a>, <a class="el" href="Array_8h-source.html#l00564">Array&lt; OpenSim::AbstractActuator * &gt;::insert()</a>, <a class="el" href="Array_8h-source.html#l00198">Array&lt; OpenSim::AbstractActuator * &gt;::operator=()</a>, <a class="el" href="Array_8h-source.html#l00227">Array&lt; OpenSim::AbstractActuator * &gt;::operator==()</a>, <a class="el" href="Array_8h-source.html#l00618">Array&lt; OpenSim::AbstractActuator * &gt;::remove()</a>, <a class="el" href="Array_8h-source.html#l00770">Array&lt; OpenSim::AbstractActuator * &gt;::rfindIndex()</a>, <a class="el" href="Array_8h-source.html#l00806">Array&lt; OpenSim::AbstractActuator * &gt;::searchBinary()</a>, <a class="el" href="Array_8h-source.html#l00654">Array&lt; OpenSim::AbstractActuator * &gt;::set()</a>, <a class="el" href="Array_8h-source.html#l00443">Array&lt; OpenSim::AbstractActuator * &gt;::setSize()</a>, and <a class="el" href="Array_8h-source.html#l00360">Array&lt; OpenSim::AbstractActuator * &gt;::trim()</a>.</p>

</div>
</div><p>
<a class="anchor" name="dc9ca8d1d3cf06b3975b6e768a942c61"></a><!-- doxytag: member="OpenSim::Array::_capacity" ref="dc9ca8d1d3cf06b3975b6e768a942c61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Array.html#dc9ca8d1d3cf06b3975b6e768a942c61">_capacity</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Current capacity of the array. 
<p>

<p>Referenced by <a class="el" href="Array_8h-source.html#l00486">Array&lt; OpenSim::AbstractActuator * &gt;::append()</a>, <a class="el" href="Array_8h-source.html#l00292">Array&lt; OpenSim::AbstractActuator * &gt;::computeNewCapacity()</a>, <a class="el" href="Array_8h-source.html#l00323">Array&lt; OpenSim::AbstractActuator * &gt;::ensureCapacity()</a>, <a class="el" href="Array_8h-source.html#l00391">Array&lt; OpenSim::AbstractActuator * &gt;::getCapacity()</a>, <a class="el" href="Array_8h-source.html#l00564">Array&lt; OpenSim::AbstractActuator * &gt;::insert()</a>, <a class="el" href="Array_8h-source.html#l00198">Array&lt; OpenSim::AbstractActuator * &gt;::operator=()</a>, <a class="el" href="Array_8h-source.html#l00654">Array&lt; OpenSim::AbstractActuator * &gt;::set()</a>, <a class="el" href="Array_8h-source.html#l00443">Array&lt; OpenSim::AbstractActuator * &gt;::setSize()</a>, and <a class="el" href="Array_8h-source.html#l00360">Array&lt; OpenSim::AbstractActuator * &gt;::trim()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ba9b915a20e0bf5cde72a3103e04a9e4"></a><!-- doxytag: member="OpenSim::Array::_capacityIncrement" ref="ba9b915a20e0bf5cde72a3103e04a9e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Array.html#ba9b915a20e0bf5cde72a3103e04a9e4">_capacityIncrement</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Increment by which the current capacity is increased when the capacity of this storage instance is reached. 
<p>
If negative, capacity doubles. 
<p>Referenced by <a class="el" href="Array_8h-source.html#l00292">Array&lt; OpenSim::AbstractActuator * &gt;::computeNewCapacity()</a>, <a class="el" href="Array_8h-source.html#l00417">Array&lt; OpenSim::AbstractActuator * &gt;::getCapacityIncrement()</a>, <a class="el" href="Array_8h-source.html#l00198">Array&lt; OpenSim::AbstractActuator * &gt;::operator=()</a>, and <a class="el" href="Array_8h-source.html#l00409">Array&lt; OpenSim::AbstractActuator * &gt;::setCapacityIncrement()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a97adea9ae306791f01d92fee0df5e60"></a><!-- doxytag: member="OpenSim::Array::_defaultValue" ref="a97adea9ae306791f01d92fee0df5e60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classOpenSim_1_1Array.html#a97adea9ae306791f01d92fee0df5e60">_defaultValue</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default value of elements. 
<p>

<p>Referenced by <a class="el" href="Array_8h-source.html#l00105">Array&lt; OpenSim::AbstractActuator * &gt;::Array()</a>, <a class="el" href="Array_8h-source.html#l00323">Array&lt; OpenSim::AbstractActuator * &gt;::ensureCapacity()</a>, <a class="el" href="Array_8h-source.html#l00198">Array&lt; OpenSim::AbstractActuator * &gt;::operator=()</a>, <a class="el" href="Array_8h-source.html#l00618">Array&lt; OpenSim::AbstractActuator * &gt;::remove()</a>, and <a class="el" href="Array_8h-source.html#l00443">Array&lt; OpenSim::AbstractActuator * &gt;::setSize()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2371cfbba1b0a27d949f87c9ae047a8c"></a><!-- doxytag: member="OpenSim::Array::_array" ref="2371cfbba1b0a27d949f87c9ae047a8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classOpenSim_1_1Array.html#2371cfbba1b0a27d949f87c9ae047a8c">_array</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classOpenSim_1_1Array.html">Array</a> of values. 
<p>

<p>Referenced by <a class="el" href="Array_8h-source.html#l00486">Array&lt; OpenSim::AbstractActuator * &gt;::append()</a>, <a class="el" href="Array_8h-source.html#l00323">Array&lt; OpenSim::AbstractActuator * &gt;::ensureCapacity()</a>, <a class="el" href="Array_8h-source.html#l00756">Array&lt; OpenSim::AbstractActuator * &gt;::findIndex()</a>, <a class="el" href="Array_8h-source.html#l00680">Array&lt; OpenSim::AbstractActuator * &gt;::get()</a>, <a class="el" href="Array_8h-source.html#l00735">Array&lt; OpenSim::AbstractActuator * &gt;::getLast()</a>, <a class="el" href="Array_8h-source.html#l00564">Array&lt; OpenSim::AbstractActuator * &gt;::insert()</a>, <a class="el" href="Array_8h-source.html#l00198">Array&lt; OpenSim::AbstractActuator * &gt;::operator=()</a>, <a class="el" href="Array_8h-source.html#l00227">Array&lt; OpenSim::AbstractActuator * &gt;::operator==()</a>, <a class="el" href="Array_8h-source.html#l00181">Array&lt; OpenSim::AbstractActuator * &gt;::operator[]()</a>, <a class="el" href="Array_8h-source.html#l00618">Array&lt; OpenSim::AbstractActuator * &gt;::remove()</a>, <a class="el" href="Array_8h-source.html#l00770">Array&lt; OpenSim::AbstractActuator * &gt;::rfindIndex()</a>, <a class="el" href="Array_8h-source.html#l00806">Array&lt; OpenSim::AbstractActuator * &gt;::searchBinary()</a>, <a class="el" href="Array_8h-source.html#l00654">Array&lt; OpenSim::AbstractActuator * &gt;::set()</a>, <a class="el" href="Array_8h-source.html#l00443">Array&lt; OpenSim::AbstractActuator * &gt;::setSize()</a>, <a class="el" href="Array_8h-source.html#l00360">Array&lt; OpenSim::AbstractActuator * &gt;::trim()</a>, and <a class="el" href="Array_8h-source.html#l00089">Array&lt; OpenSim::AbstractActuator * &gt;::~Array()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Array_8h-source.html">Array.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Aug 25 11:00:35 2008 for OpenSim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
