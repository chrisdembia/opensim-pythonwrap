<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenSim: OpenSim::Storage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>OpenSim</b>::<a class="el" href="classOpenSim_1_1Storage.html">Storage</a>
  </div>
</div>
<div class="contents">
<h1>OpenSim::Storage Class Reference</h1><!-- doxytag: class="OpenSim::Storage" --><!-- doxytag: inherits="OpenSim::StorageInterface" -->
<p><code>#include &lt;Storage.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OpenSim::Storage:</div>
<div class="dynsection">
 <div class="center">
  <img src="classOpenSim_1_1Storage.gif" usemap="#OpenSim::Storage_map" alt=""/>
  <map id="OpenSim::Storage_map" name="OpenSim::Storage_map">
<area href="classOpenSim_1_1StorageInterface.html" alt="OpenSim::StorageInterface" shape="rect" coords="0,56,163,80"/>
<area href="classOpenSim_1_1Object.html" alt="OpenSim::Object" shape="rect" coords="0,0,163,24"/>
</map>
 </div>
</div>

<p><a href="classOpenSim_1_1Storage-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a72509bf8ca5e662389fd257973cf7ce3">Storage</a> (int aCapacity=Storage_DEFAULT_CAPACITY, const std::string &amp;aName=&quot;UNKNOWN&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ae8f00eb780556a3774f46d2668656423">Storage</a> (const std::string &amp;aFileName) SWIG_DECLARE_EXCEPTION</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a1d5c832bdf903b5e8fb247ee53c5c709">Storage</a> (const <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> &amp;aStorage, bool aCopyData=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a1d5c832bdf903b5e8fb247ee53c5c709"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a9c0a910a37b00772ed76c867ea640b63">Storage</a> (const <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> &amp;aStorage, int aStateIndex, int aN, const char *aDelimiter=&quot;\t&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a copy of a specified storage taking only a subset of the states.  <a href="#a9c0a910a37b00772ed76c867ea640b63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOpenSim_1_1Object.html">Object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aa2b677ca5e2fda582fce8d70c36777c9">copy</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy this object.  <a href="#aa2b677ca5e2fda582fce8d70c36777c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a73cf30f0a34250396f9eabee7dc5c93d">~Storage</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a73cf30f0a34250396f9eabee7dc5c93d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a79779c85dc6bfa2528f9eab945e522f8">getName</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of this object.  <a href="#a79779c85dc6bfa2528f9eab945e522f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ab3ad6289a019b30526c830994d9f3acb">getDescription</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the description of this object.  <a href="#ab3ad6289a019b30526c830994d9f3acb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a4cd5760e04c721afe581f25cface572e">setName</a> (const std::string &amp;aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ae7cb45aa2c24af1754e9afba280a190a">setDescription</a> (const std::string &amp;aDescription)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aeeadf5347ea3d0355518cb4d9c506e24">getSize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a1d6190784783c6c615776e10125ecf78">getSmallestNumberOfStates</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the smallest number of states.  <a href="#a1d6190784783c6c615776e10125ecf78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#abb09ca2050be7a8cb926910f532a2611">getStateVector</a> (int aTimeIndex) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="classOpenSim_1_1StateVector.html" title="A class which stores a vector of states or data at a specified time.">StateVector</a> at a spcified time index.  <a href="#abb09ca2050be7a8cb926910f532a2611"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a1d90debbb39fc006ca9cb483e28bac0b">getLastStateVector</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the last states stored.  <a href="#a1d90debbb39fc006ca9cb483e28bac0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a2d982e0afcd82e77d7e39442bc581b3f">getFirstTime</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time of the first stored states.  <a href="#a2d982e0afcd82e77d7e39442bc581b3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a64cb85afa3a41c5b80404deb2f9d56dc">getLastTime</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time of the last states.  <a href="#a64cb85afa3a41c5b80404deb2f9d56dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aad15c7586320e6c3b98e6b3119f91490">getMinTimeStep</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the smallest time step.  <a href="#aad15c7586320e6c3b98e6b3119f91490"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a0a586d3e04d9803450ff848f7fe7a052">getTime</a> (int aTimeIndex, double &amp;rTime, int aStateIndex=-1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time at a specified time index for a specified state.  <a href="#a0a586d3e04d9803450ff848f7fe7a052"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a671b617e6323316980e7064d3b9c090c">getTimeColumn</a> (double *&amp;rTimes, int aStateIndex=-1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the times for a specified state.  <a href="#a671b617e6323316980e7064d3b9c090c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ac23ded50b157c9310989b3a0b317ae8d">getTimeColumn</a> (<a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;rTimes, int aStateIndex=-1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ae3251a8522b1fe633849def4b691ba14">getTimeColumnWithStartTime</a> (<a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;rTimes, double startTime=0.0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time column starting at aTime.  <a href="#ae3251a8522b1fe633849def4b691ba14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a78b4672a61156732695cf5a3a57e2380">addKeyValuePair</a> (const std::string &amp;aKey, const std::string &amp;aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processing of special reserved words used by SIMM and corresponding values The keys and their corresponding values are maintained in _keyValueMap.  <a href="#a78b4672a61156732695cf5a3a57e2380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aa44f52d25994c9582f70ebf1ecbdd969">getValueForKey</a> (const std::string &amp;aKey, std::string &amp;rValue) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a33936941624958b7902f4f7a6c02c3c0">hasKey</a> (const std::string &amp;aKey) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#acd608c8e7a93a04c450ce31505abd41a">getData</a> (int aTimeIndex, int aStateIndex, double &amp;rValue) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a data value of a specified state at a specified time index.  <a href="#acd608c8e7a93a04c450ce31505abd41a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a1b51f10628decda186d0cd14d17bf6d8">getData</a> (int aTimeIndex, int aStateIndex, int aN, double **rData) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for getData.  <a href="#a1b51f10628decda186d0cd14d17bf6d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a39483fc281f6666d092d3992185c4e18">getData</a> (int aTimeIndex, int aStateIndex, int aN, double *rData) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">At a specified time index, get a number of state values starting at a specified state.  <a href="#a39483fc281f6666d092d3992185c4e18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a2b0dabd9267723fd0109d9fa1c407734">getData</a> (int aTimeIndex, int aN, double **rData) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">At a specified time index, get a number of state values starting at a specified state.  <a href="#a2b0dabd9267723fd0109d9fa1c407734"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#afd30d0fa06df466f92fcb36d40b696ac">getData</a> (int aTimeIndex, int aN, double *rData) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first aN states at a specified time index.  <a href="#afd30d0fa06df466f92fcb36d40b696ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a9b14eb852052fc444b350369c3f85ef3">getDataAtTime</a> (double aTime, int aN, double **rData) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first aN states at a specified time.  <a href="#a9b14eb852052fc444b350369c3f85ef3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a28eb187b2723f5d207718277cd17596a">getDataAtTime</a> (double aTime, int aN, double *rData) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first aN states at a specified time.  <a href="#a28eb187b2723f5d207718277cd17596a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ae8c990f3cf8e787899a0eb87f37ed8ce">getDataAtTime</a> (double aTime, int aN, <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;rData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a93069a2816af0b7ee633cf37c0f9f786">getDataColumn</a> (int aStateIndex, double *&amp;rData) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the data corresponding to a specified state.  <a href="#a93069a2816af0b7ee633cf37c0f9f786"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ad69c445edf687d360134e8b442468b88">getDataColumn</a> (int aStateIndex, <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;rData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a921cf7ac20c64307478b6c2c7cafd1fe">setDataColumn</a> (int aStateIndex, const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;aData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the data corresponding to a specified state.  <a href="#a921cf7ac20c64307478b6c2c7cafd1fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a13763c771337662e825f7cbfa5271030">getDataColumn</a> (const std::string &amp;columnName, double *&amp;rData) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the data corresponding to a state specified by name.  <a href="#a13763c771337662e825f7cbfa5271030"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a46ba35856fe4e58fb738a6820cb3332f">getDataColumn</a> (const std::string &amp;columnName, <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;data, double startTime=0.0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the data column starting at aTime.  <a href="#a46ba35856fe4e58fb738a6820cb3332f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a1c4d690f29d0412a622d9b9415cea4ba">setStepInterval</a> (int aStepInterval)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the step interval.  <a href="#a1c4d690f29d0412a622d9b9415cea4ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ace7f9afaa03fd2615d29caab325a616b">getStepInterval</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the step interval.  <a href="#ace7f9afaa03fd2615d29caab325a616b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aa936add9494bde3c6953acb9154d9b7b">setCapacityIncrement</a> (int aIncrement)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the capacity increment of this storage object.  <a href="#aa936add9494bde3c6953acb9154d9b7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aa99ac3cfe670ab642579e92202c01e4a">getCapacityIncrement</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the capacity increment of this storage object.  <a href="#aa99ac3cfe670ab642579e92202c01e4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a8f9340332d4e9bc6111bc4aefee3a68b">setWriteSIMMHeader</a> (bool aTrueFalse)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the whether or not to write a header appropriate for a SIMM motion file.  <a href="#a8f9340332d4e9bc6111bc4aefee3a68b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#adfd055d50f777860d0bb9ac351bea347">getWriteSIMMHeader</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the whether or not to write a header appropriate for a SIMM motion file.  <a href="#adfd055d50f777860d0bb9ac351bea347"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a43196bfd28dbbc22e71afb44aae21c8e">setHeaderToken</a> (const std::string &amp;aToken)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the header token.  <a href="#a43196bfd28dbbc22e71afb44aae21c8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#acf714b8f3ea5aa97c74445a6e8420aa1">getHeaderToken</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the header token of this storage.  <a href="#acf714b8f3ea5aa97c74445a6e8420aa1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a2c0ea41be1f45fa359e7ab5b2f3701a1">getStateIndex</a> (const std::string &amp;aColumnName, int startIndex=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the column index corresponding to specified column name.  <a href="#a2c0ea41be1f45fa359e7ab5b2f3701a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#afbf5736671c1c8527a65545920fba907">setColumnLabels</a> (const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; std::string &gt; &amp;aColumnLabels)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> column labels array.  <a href="#afbf5736671c1c8527a65545920fba907"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; std::string &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a0317dbdd8992f308ec8bd1b038fe6f85">getColumnLabels</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get column labels array.  <a href="#a0317dbdd8992f308ec8bd1b038fe6f85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a0c68c9ac19e7b844bff5638ea6412ad4">reset</a> (int aIndex=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the storage to start storing at a specified index.  <a href="#a0c68c9ac19e7b844bff5638ea6412ad4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a3e8b4b9b3870d774cb0f05bec18a4527">reset</a> (double aTime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the storage to start storing after a specified time.  <a href="#a3e8b4b9b3870d774cb0f05bec18a4527"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#afa7717a4c221f4b038ead6d3b7e55b94">purge</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a0eca1c69322718fdec57516a11881d45">crop</a> (const double newStartTime, const double newFinalTime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Crop the storage object to the specified start and final time.  <a href="#a0eca1c69322718fdec57516a11881d45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ab60f82ee14878028c65f4904e5ee2537">append</a> (const <a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> &amp;aVec, bool aCheckForDuplicateTime=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an <a class="el" href="classOpenSim_1_1StateVector.html" title="A class which stores a vector of states or data at a specified time.">StateVector</a>.  <a href="#ab60f82ee14878028c65f4904e5ee2537"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a42dc67004b5160cf9f3ef21b3c2d7510">append</a> (const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; <a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> &gt; &amp;aArray)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append copies of all state vectors in an <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> object.  <a href="#a42dc67004b5160cf9f3ef21b3c2d7510"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a827bdc891ac03b5153f0cc5097e2821a">append</a> (double aT, int aN, const double *aY, bool aCheckForDuplicateTime=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an array of data that occured at a specified time.  <a href="#a827bdc891ac03b5153f0cc5097e2821a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#abd9998faa53ee76c1dae716b9d737b21">append</a> (double aT, const SimTK::Vector &amp;aY, bool aCheckForDuplicateTime=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an array of data that occured at a specified time.  <a href="#abd9998faa53ee76c1dae716b9d737b21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#abdcb681ccdd3b49c25232cf85ab8ae5c">append</a> (double aT, const SimTK::Vec3 &amp;aY, bool aCheckForDuplicateTime=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ad7c2ae9160a2833c8faa4417de6768d8">store</a> (int aStep, double aT, int aN, const double *aY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store a simulation vector.  <a href="#ad7c2ae9160a2833c8faa4417de6768d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aa8261da0c0a09c0a9716cee047426350">shiftTime</a> (double aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift the times of all state vectors.  <a href="#aa8261da0c0a09c0a9716cee047426350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ac34f8b0052abeca502367b73d946e536">scaleTime</a> (double aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Scale.html">Scale</a> the times of all state vectors.  <a href="#ac34f8b0052abeca502367b73d946e536"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a0c344b3d53418a9c7956963e63e60cd4">add</a> (double aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a value to all state vectors in this storage instance.  <a href="#a0c344b3d53418a9c7956963e63e60cd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a37b83eb8b85882ad22ec2d497efa579d">add</a> (int aN, double aY[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an array to all state vectors in this storage instance.  <a href="#a37b83eb8b85882ad22ec2d497efa579d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#afe3240bda725f4371efdf8109d642de6">add</a> (int aN, double aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a value to all entries in one column of the storage.  <a href="#afe3240bda725f4371efdf8109d642de6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a960bdd25929c7cc4bcb6f9482b2d7578">add</a> (<a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> *aStateVector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a state vector to the all state vectors in this storage instance.  <a href="#a960bdd25929c7cc4bcb6f9482b2d7578"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aeac09251ea81d378e7df329adcef7dce">add</a> (<a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *aStorage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a storage instance to this storage instance.  <a href="#aeac09251ea81d378e7df329adcef7dce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a67fc901e35d2b5351a62ae9b66f0ecdf">subtract</a> (double aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract a value from all state vectors in this storage instance.  <a href="#a67fc901e35d2b5351a62ae9b66f0ecdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#af5c9f86cb883a820a5de76b4d161f50d">subtract</a> (int aN, double aY[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract an array from all state vectors in this storage instance.  <a href="#af5c9f86cb883a820a5de76b4d161f50d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a4f9994828fbc969a0a1c57ff199e1b52">subtract</a> (<a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> *aStateVector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract a state vector from all state vectors in this storage instance.  <a href="#a4f9994828fbc969a0a1c57ff199e1b52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#acc896c2b82d650d9f851d70ca2eb4d30">subtract</a> (<a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *aStorage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract a storage instance to this storage instance.  <a href="#acc896c2b82d650d9f851d70ca2eb4d30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ac8e6b464a431fe227827519b3425b154">multiply</a> (double aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply all state vectors in this storage instance by a value.  <a href="#ac8e6b464a431fe227827519b3425b154"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#acd5ffc32050a7299ff219ddd0c7c6fb8">multiplyColumn</a> (int aIndex, double aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply entries at column aIndex by a value.  <a href="#acd5ffc32050a7299ff219ddd0c7c6fb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ab9961091d67f841d46d597f92f08552e">multiply</a> (int aN, double aY[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply all state vectors in this storage instance by an array.  <a href="#ab9961091d67f841d46d597f92f08552e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ac3e23fef09b9a2cb8e19c2e5866946b8">multiply</a> (<a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> *aStateVector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply all state vectors in this storage instance by a state vector.  <a href="#ac3e23fef09b9a2cb8e19c2e5866946b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aec83f13fbcc57befcb3cecd2feeb47d7">multiply</a> (<a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *aStorage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multipy this storage instance by a storage instance.  <a href="#aec83f13fbcc57befcb3cecd2feeb47d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a864462adbe0c4a269ee7979f5547675f">divide</a> (double aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide all state vectors in this storage instance by a value.  <a href="#a864462adbe0c4a269ee7979f5547675f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#abf76bf675b83d1ad8a9e8571c15d2487">divide</a> (int aN, double aY[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide all state vectors in this storage instance by an array.  <a href="#abf76bf675b83d1ad8a9e8571c15d2487"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aaf1d6a3cc5da06a69c7a58aa7d7a348c">divide</a> (<a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> *aStateVector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide all state vectors in this storage instance by a state vector.  <a href="#aaf1d6a3cc5da06a69c7a58aa7d7a348c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a0bb572cc27d909fe5c8779269dd2850a">divide</a> (<a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *aStorage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide this storage instance by a storage instance.  <a href="#a0bb572cc27d909fe5c8779269dd2850a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#afa75290cc36e8f0ea7a61e23892cfe75">integrate</a> (int aI1=-2, int aI2=-1) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integrate the state vectors between aI1 and aI2.  <a href="#afa75290cc36e8f0ea7a61e23892cfe75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a8b03feabf5cd1a0aa76fe78bb4cb32d0">integrate</a> (double aT1, double aT2) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integrate the state vectors between times aTI and aTF.  <a href="#a8b03feabf5cd1a0aa76fe78bb4cb32d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a5d8dece91579f091e04e9bd7cacc5798">computeArea</a> (int aN, double *aArea) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the area of the first aN states stored for all state vectors stored in this storage instance.  <a href="#a5d8dece91579f091e04e9bd7cacc5798"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a2197f37207a8f423f33a358dfcbcf935">computeArea</a> (double aTI, double aTF, int aN, double *aArea) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the area of the first aN states stored between the times aTI and aTF.  <a href="#a2197f37207a8f423f33a358dfcbcf935"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#acfa2bfc3ddff1f822d7425499dea5c27">computeAverage</a> (int aN, double *aAve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the average value of the first aN states stored for all state vectors stored in this storage instance.  <a href="#acfa2bfc3ddff1f822d7425499dea5c27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#adc3ec9a78c398cb5860e80aac07554be">computeAverage</a> (double aTI, double aTF, int aN, double *aAve) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the average value of the first aN states stored between the times aTI and aTF.  <a href="#adc3ec9a78c398cb5860e80aac07554be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aaf3ba558195c62b9675e0ec1bac1cd23">pad</a> (int aPadSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pad each of the columns in a statevector by a specified amount.  <a href="#aaf3ba558195c62b9675e0ec1bac1cd23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a8aec0bb90cf0b0633e4dbac0f4cbc925">smoothSpline</a> (int aOrder, double aCutoffFrequency)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Smooth spline each of the columns in the storage.  <a href="#a8aec0bb90cf0b0633e4dbac0f4cbc925"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a046d176a098a767be0c24053114d3577">lowpassIIR</a> (double aCutoffFequency)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lowpass filter each of the columns in the storage.  <a href="#a046d176a098a767be0c24053114d3577"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ae3049bf6dcd620208572654c1ad3ad9b">lowpassFIR</a> (int aOrder, double aCutoffFequency)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lowpass filter each of the columns in the storage.  <a href="#ae3049bf6dcd620208572654c1ad3ad9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a7222665f1d58da6a7756d081ad7f97b8">addToRdStorage</a> (<a class="el" href="classOpenSim_1_1Storage.html">Storage</a> &amp;rStorage, double aStartTime, double aEndTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a2b2611013561cbc0a96922ad6da05d15">findIndex</a> (double aT) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index of the storage element that occured immediately before or at a specified time ( getTime(index) &lt;= aT ).  <a href="#a2b2611013561cbc0a96922ad6da05d15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aaaa55ca6f6f65717badecda31791804c">findIndex</a> (int aI, double aT) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index of the storage element that occured immediately before or at time aT ( aT &lt;= getTime(index) ).  <a href="#aaaa55ca6f6f65717badecda31791804c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a5a6ac5e5597cd330d558aa4a234e8ece">findFrameRange</a> (double aStartTime, double aEndTime, int &amp;oStartFrame, int &amp;oEndFrame) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the range of frames that is between start time and end time (inclusive).  <a href="#a5a6ac5e5597cd330d558aa4a234e8ece"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#adb7be2ee9e5be4d8ec4db79029aa9c9c">resample</a> (double aDT, int aDegree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resample <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> columns to specified rate.  <a href="#adb7be2ee9e5be4d8ec4db79029aa9c9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a3e7347ae928c68129b416e2fb8ca9227">resampleLinear</a> (double aDT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resample using linear interpolation.  <a href="#a3e7347ae928c68129b416e2fb8ca9227"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a1449c7ff95a05fa5ed87271b09f53286">compareColumn</a> (<a class="el" href="classOpenSim_1_1Storage.html">Storage</a> &amp;aOtherStorage, std::string &amp;aColumnName, double startTime, double endTime=-1.0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare column named "aColumnName" in two storage objects If endTime is not specified the comparison goes to the end of the file.  <a href="#a1449c7ff95a05fa5ed87271b09f53286"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a2d9a9e61784736668e2784475d01998a">makeStorageLabelsUnique</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Force.html" title="This abstract class represents a force applied to bodies or generalized coordinates...">Force</a> column labels for a <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> object to become unique.  <a href="#a2d9a9e61784736668e2784475d01998a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#abd01fa11849b97cf7e888c25acd1dffd">print</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the contents of this storage instance to standard output.  <a href="#abd01fa11849b97cf7e888c25acd1dffd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a22abd314e0e07069d0eaaa54b9645d61">print</a> (const std::string &amp;aFileName, const std::string &amp;aMode=&quot;w&quot;, const std::string &amp;aComment=&quot;&quot;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a6593f8074ece310fe51a09f0c79548db">print</a> (const std::string &amp;aFileName, double aDT, const std::string &amp;aMode=&quot;w&quot;) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ac675bbd9d8e8db518ed84204757c9256">setOutputFileName</a> (const std::string &amp;aFileName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> name of output file to be written into.  <a href="#ac675bbd9d8e8db518ed84204757c9256"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aaf9d072bc4c4046e039050e8768c4408">interpolateAt</a> (const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;targetTimes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">interpolateAt passed in list of time values.  <a href="#aaf9d072bc4c4046e039050e8768c4408"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a9d0cbcb6c4e6ecf207a0ad8c6fe11a47">printResult</a> (const <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *aStorage, const std::string &amp;aName, const std::string &amp;aDir, double aDT, const std::string &amp;aExtension)</td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ae58dd0c88d6e40845142ea5c1f27abc8">DEFAULT_HEADER_TOKEN</a> = &quot;endheader&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default token used to mark the end of the storage description in a file.  <a href="#ae58dd0c88d6e40845142ea5c1f27abc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ab66065724f81afd76dc9360694a9f82d">DEFAULT_HEADER_SEPARATOR</a> = &quot; \t\r\n&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a165f803c99ae3e1cefa9c71b6e12d68f">MAX_RESAMPLE_SIZE</a> = 100000</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; <a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a6a3ca0a579d96363c2e79e691f34b5a3">_storage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Array.html">Array</a> of StateVectors.  <a href="#a6a3ca0a579d96363c2e79e691f34b5a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a766fbc5ee487820620ba477d29cae595">_headerToken</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Token used to mark the end of the description in a file.  <a href="#a766fbc5ee487820620ba477d29cae595"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ac7910a5e3c35dae4a8827f66e5590653">_columnLabels</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Column labels.  <a href="#ac7910a5e3c35dae4a8827f66e5590653"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ade3e3b6dea78c4a25ec81e29285c57f4">_stepInterval</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Step interval at which states in a simulation are stored.  <a href="#ade3e3b6dea78c4a25ec81e29285c57f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a903a7fef57c6d4d91237c57f58e9f23c">_lastI</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Last index at which a search was started.  <a href="#a903a7fef57c6d4d91237c57f58e9f23c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a466c205541be980bfc0218db76d77ce8">_writeSIMMHeader</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag for whether or not to insert a SIMM style header.  <a href="#a466c205541be980bfc0218db76d77ce8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Units.html">Units</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a465e44061bc8b343bb505089d6716048">_units</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Units.html" title="A class implementing various units for measuring quantities.">Units</a> in which the data is represented.  <a href="#a465e44061bc8b343bb505089d6716048"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">MapKeysToValues&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aac082a43ac237c03ccbab990aefbf3a9">_keyValueMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map between keys in file header and values.  <a href="#aac082a43ac237c03ccbab990aefbf3a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#aea1c769d45399c5be0c455ab149d359f">_fileName</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cache for fileName and file pointer when the file is opened so we can flush and write intermediate files if needed.  <a href="#aea1c769d45399c5be0c455ab149d359f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a55e8a172ee5db206cbed4733c0a21f60">_fp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#ab3769ffec960c64a6623a374acb2dae9">_name</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Name and Description.  <a href="#ab3769ffec960c64a6623a374acb2dae9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a59d6d892194a8f55b03a1ffd39989971">_description</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A description of the object.  <a href="#a59d6d892194a8f55b03a1ffd39989971"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Storage.html#a6348da7e089075920caf7d40e38b5ca4">simmReservedKeys</a> []</td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a72509bf8ca5e662389fd257973cf7ce3"></a><!-- doxytag: member="OpenSim::Storage::Storage" ref="a72509bf8ca5e662389fd257973cf7ce3" args="(int aCapacity=Storage_DEFAULT_CAPACITY, const std::string &amp;aName=&quot;UNKNOWN&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenSim::Storage::Storage </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aCapacity</em> = <code>Storage_DEFAULT_CAPACITY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aName</em> = <code>&quot;UNKNOWN&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8f00eb780556a3774f46d2668656423"></a><!-- doxytag: member="OpenSim::Storage::Storage" ref="ae8f00eb780556a3774f46d2668656423" args="(const std::string &amp;aFileName) SWIG_DECLARE_EXCEPTION" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenSim::Storage::Storage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d5c832bdf903b5e8fb247ee53c5c709"></a><!-- doxytag: member="OpenSim::Storage::Storage" ref="a1d5c832bdf903b5e8fb247ee53c5c709" args="(const Storage &amp;aStorage, bool aCopyData=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Storage::Storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aStorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aCopyData</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="a9c0a910a37b00772ed76c867ea640b63"></a><!-- doxytag: member="OpenSim::Storage::Storage" ref="a9c0a910a37b00772ed76c867ea640b63" args="(const Storage &amp;aStorage, int aStateIndex, int aN, const char *aDelimiter=&quot;\t&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Storage::Storage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aStorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStateIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aDelimiter</em> = <code>&quot;\t&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a copy of a specified storage taking only a subset of the states. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStorage</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> to be copied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aStateIndex</em>&nbsp;</td><td>Index of the state (column) at which to start the copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Number of states to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aDelimiter</em>&nbsp;</td><td>Delimiter used to separate state labels (i.e., column labels). The delimiter is assumed to be a tab by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73cf30f0a34250396f9eabee7dc5c93d"></a><!-- doxytag: member="OpenSim::Storage::~Storage" ref="a73cf30f0a34250396f9eabee7dc5c93d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Storage::~Storage </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>The stored StateVectors are deleted during destruction. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aeac09251ea81d378e7df329adcef7dce"></a><!-- doxytag: member="OpenSim::Storage::add" ref="aeac09251ea81d378e7df329adcef7dce" args="(Storage *aStorage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *&nbsp;</td>
          <td class="paramname"> <em>aStorage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a storage instance to this storage instance. </p>
<p>Linear interpolation or extrapolation is used to get the values of the states that correspond in time to the states held in this storage instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStorage</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> to add to this storage. s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a960bdd25929c7cc4bcb6f9482b2d7578"></a><!-- doxytag: member="OpenSim::Storage::add" ref="a960bdd25929c7cc4bcb6f9482b2d7578" args="(StateVector *aStateVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> *&nbsp;</td>
          <td class="paramname"> <em>aStateVector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a state vector to the all state vectors in this storage instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStateVector</em>&nbsp;</td><td>State vector to add to the state vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1StateVector.html#ac759468d36cf0bebc3cc7064936a84d1" title="Add a value to each state.">StateVector::add</a>(int,double[]) </dd></dl>

</div>
</div>
<a class="anchor" id="afe3240bda725f4371efdf8109d642de6"></a><!-- doxytag: member="OpenSim::Storage::add" ref="afe3240bda725f4371efdf8109d642de6" args="(int aN, double aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::add </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a value to all entries in one column of the storage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Index of the column that the value is to be added to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value to add to the column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1StateVector.html#a1bbe055aefa3a2342deed1e84dbd87f6" title="Add a value to a state.">StateVector::add(int,double)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a37b83eb8b85882ad22ec2d497efa579d"></a><!-- doxytag: member="OpenSim::Storage::add" ref="a37b83eb8b85882ad22ec2d497efa579d" args="(int aN, double aY[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::add </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aY</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an array to all state vectors in this storage instance. </p>
<p>Only the first aN states of each state vector are altered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Length of aY </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aY</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> of values to add to the state vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1StateVector.html#ac759468d36cf0bebc3cc7064936a84d1" title="Add a value to each state.">StateVector::add</a>(int,double[]) </dd></dl>

</div>
</div>
<a class="anchor" id="a0c344b3d53418a9c7956963e63e60cd4"></a><!-- doxytag: member="OpenSim::Storage::add" ref="a0c344b3d53418a9c7956963e63e60cd4" args="(double aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::add </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a value to all state vectors in this storage instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value to add to the state vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1StateVector.html#ac759468d36cf0bebc3cc7064936a84d1" title="Add a value to each state.">StateVector::add(double)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a78b4672a61156732695cf5a3a57e2380"></a><!-- doxytag: member="OpenSim::Storage::addKeyValuePair" ref="a78b4672a61156732695cf5a3a57e2380" args="(const std::string &amp;aKey, const std::string &amp;aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::addKeyValuePair </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Processing of special reserved words used by SIMM and corresponding values The keys and their corresponding values are maintained in _keyValueMap. </p>

</div>
</div>
<a class="anchor" id="a7222665f1d58da6a7756d081ad7f97b8"></a><!-- doxytag: member="OpenSim::Storage::addToRdStorage" ref="a7222665f1d58da6a7756d081ad7f97b8" args="(Storage &amp;rStorage, double aStartTime, double aEndTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::addToRdStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rStorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aStartTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aEndTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abdcb681ccdd3b49c25232cf85ab8ae5c"></a><!-- doxytag: member="OpenSim::Storage::append" ref="abdcb681ccdd3b49c25232cf85ab8ae5c" args="(double aT, const SimTK::Vec3 &amp;aY, bool aCheckForDuplicateTime=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OpenSim::Storage::append </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>aY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aCheckForDuplicateTime</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOpenSim_1_1StorageInterface.html#ad8f1ec797aabdd6d0d3d315cff4ec2fb">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="abd9998faa53ee76c1dae716b9d737b21"></a><!-- doxytag: member="OpenSim::Storage::append" ref="abd9998faa53ee76c1dae716b9d737b21" args="(double aT, const SimTK::Vector &amp;aY, bool aCheckForDuplicateTime=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::append </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vector &amp;&nbsp;</td>
          <td class="paramname"> <em>aY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aCheckForDuplicateTime</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an array of data that occured at a specified time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aT</em>&nbsp;</td><td>Time stamp of the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aY</em>&nbsp;</td><td>Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index of the first empty storage element. </dd></dl>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a6df90f9605aed3a8b10cf7e3602d892d">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a827bdc891ac03b5153f0cc5097e2821a"></a><!-- doxytag: member="OpenSim::Storage::append" ref="a827bdc891ac03b5153f0cc5097e2821a" args="(double aT, int aN, const double *aY, bool aCheckForDuplicateTime=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::append </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aCheckForDuplicateTime</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an array of data that occured at a specified time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aT</em>&nbsp;</td><td>Time stamp of the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Length of the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aY</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index of the first empty storage element. </dd></dl>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#ae638d1ff032b9e39862edbb04669bde6">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a42dc67004b5160cf9f3ef21b3c2d7510"></a><!-- doxytag: member="OpenSim::Storage::append" ref="a42dc67004b5160cf9f3ef21b3c2d7510" args="(const Array&lt; StateVector &gt; &amp;aArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; <a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aStorage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append copies of all state vectors in an <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> object. </p>
<p>This method overrides Array::append(Array). Currently, there is no difference. The override is done for completeness.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStorage</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of the first empty storage element. </dd></dl>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a6c6a474f6fd75b7901cc25c73a2ae07d">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ab60f82ee14878028c65f4904e5ee2537"></a><!-- doxytag: member="OpenSim::Storage::append" ref="ab60f82ee14878028c65f4904e5ee2537" args="(const StateVector &amp;aVec, bool aCheckForDuplicateTime=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aStateVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aCheckForDuplicateTime</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an <a class="el" href="classOpenSim_1_1StateVector.html" title="A class which stores a vector of states or data at a specified time.">StateVector</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStateVector</em>&nbsp;</td><td>Statevector to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size of the storage after the append. </dd></dl>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a16c92aaae96d9f954c47d5fef1b1772c">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a1449c7ff95a05fa5ed87271b09f53286"></a><!-- doxytag: member="OpenSim::Storage::compareColumn" ref="a1449c7ff95a05fa5ed87271b09f53286" args="(Storage &amp;aOtherStorage, std::string &amp;aColumnName, double startTime, double endTime=&#45;1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Storage::compareColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aOtherStorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aColumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>endTime</em> = <code>-1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare column named "aColumnName" in two storage objects If endTime is not specified the comparison goes to the end of the file. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the difference or SimTK::Infinity if times do not match up.</dd></dl>
<p>NOTE: This assumes same time sampling between both Storages. </p>

</div>
</div>
<a class="anchor" id="a2197f37207a8f423f33a358dfcbcf935"></a><!-- doxytag: member="OpenSim::Storage::computeArea" ref="a2197f37207a8f423f33a358dfcbcf935" args="(double aTI, double aTF, int aN, double *aArea) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::computeArea </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aTI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aTF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aArea</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the area of the first aN states stored between the times aTI and aTF. </p>
<p>It is assumed that there is enough memory at aArea to hold aN states. If aN exceeds the number of states held in storage, aN is disregarded.</p>
<p>The number of valid states in aArea is returned.</p>
<p>Note that if aTI and aTF do not fall exactly on the time stamp of a stored state, the states are linearly interpolated to provide an estimate of the state at aTI or at aTF. </p>

</div>
</div>
<a class="anchor" id="a5d8dece91579f091e04e9bd7cacc5798"></a><!-- doxytag: member="OpenSim::Storage::computeArea" ref="a5d8dece91579f091e04e9bd7cacc5798" args="(int aN, double *aArea) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::computeArea </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aArea</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the area of the first aN states stored for all state vectors stored in this storage instance. </p>
<p>It is assumed that there is enough memory at aArea to hold aN states. If aN exceeds the number of states held in storage, aN is disregarded.</p>
<p>The number of valid states in aArea is returned. </p>

</div>
</div>
<a class="anchor" id="adc3ec9a78c398cb5860e80aac07554be"></a><!-- doxytag: member="OpenSim::Storage::computeAverage" ref="adc3ec9a78c398cb5860e80aac07554be" args="(double aTI, double aTF, int aN, double *aAve) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::computeAverage </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aTI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aTF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aAve</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the average value of the first aN states stored between the times aTI and aTF. </p>
<p>This method uses <a class="el" href="classOpenSim_1_1Storage.html#a5d8dece91579f091e04e9bd7cacc5798" title="Compute the area of the first aN states stored for all state vectors stored in this...">computeArea()</a> to compute the area (integral) of each state on the interval [aTI,aTF] and then simply divides by the (aTF-aTI).</p>
<p>It is assumed that there is enough memory at aAve to hold aN states. If aN exceeds the number of states held in storage, aN is disregarded.</p>
<p>The number of valid states in aAve is returned.</p>
<p>Note that if aTI and aTF do not fall exactly on the time stamp of a stored state, the states are linearly interpolated to provide an estimate of the state at aTI or at aTF. </p>

</div>
</div>
<a class="anchor" id="acfa2bfc3ddff1f822d7425499dea5c27"></a><!-- doxytag: member="OpenSim::Storage::computeAverage" ref="acfa2bfc3ddff1f822d7425499dea5c27" args="(int aN, double *aAve) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::computeAverage </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aAve</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the average value of the first aN states stored for all state vectors stored in this storage instance. </p>
<p>This method uses <a class="el" href="classOpenSim_1_1Storage.html#a5d8dece91579f091e04e9bd7cacc5798" title="Compute the area of the first aN states stored for all state vectors stored in this...">computeArea()</a> to compute the area (integral) and then simply divides by the the time interval (tf-ti).</p>
<p>It is assumed that there is enough memory at aAve to hold aN states. If aN exceeds the number of states held in storage, aN is disregarded.</p>
<p>The number of valid states in aAve is returned. </p>

</div>
</div>
<a class="anchor" id="aa2b677ca5e2fda582fce8d70c36777c9"></a><!-- doxytag: member="OpenSim::Storage::copy" ref="aa2b677ca5e2fda582fce8d70c36777c9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Object.html">Object</a> * Storage::copy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy this object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to a copy of this object. </dd></dl>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#ac46b2338b7276d013da2c93932287529">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a0eca1c69322718fdec57516a11881d45"></a><!-- doxytag: member="OpenSim::Storage::crop" ref="a0eca1c69322718fdec57516a11881d45" args="(const double newStartTime, const double newFinalTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::crop </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>newStartTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>newFinalTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Crop the storage object to the specified start and final time. </p>

</div>
</div>
<a class="anchor" id="a0bb572cc27d909fe5c8779269dd2850a"></a><!-- doxytag: member="OpenSim::Storage::divide" ref="a0bb572cc27d909fe5c8779269dd2850a" args="(Storage *aStorage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *&nbsp;</td>
          <td class="paramname"> <em>aStorage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide this storage instance by a storage instance. </p>
<p>Linear interpolation or extrapolation is used to get the values of the states that correspond in time to the states held in this storage instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStorage</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> instance by which to divide. s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf1d6a3cc5da06a69c7a58aa7d7a348c"></a><!-- doxytag: member="OpenSim::Storage::divide" ref="aaf1d6a3cc5da06a69c7a58aa7d7a348c" args="(StateVector *aStateVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> *&nbsp;</td>
          <td class="paramname"> <em>aStateVector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide all state vectors in this storage instance by a state vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStateVector</em>&nbsp;</td><td>State vector by which to divide the state vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf76bf675b83d1ad8a9e8571c15d2487"></a><!-- doxytag: member="OpenSim::Storage::divide" ref="abf76bf675b83d1ad8a9e8571c15d2487" args="(int aN, double aY[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::divide </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aY</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide all state vectors in this storage instance by an array. </p>
<p>Only the first aN states of each state vector are altered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Length of aY </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aY</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> of values the states are to be divided by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a864462adbe0c4a269ee7979f5547675f"></a><!-- doxytag: member="OpenSim::Storage::divide" ref="a864462adbe0c4a269ee7979f5547675f" args="(double aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::divide </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide all state vectors in this storage instance by a value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value by which to divide the state vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a6ac5e5597cd330d558aa4a234e8ece"></a><!-- doxytag: member="OpenSim::Storage::findFrameRange" ref="a5a6ac5e5597cd330d558aa4a234e8ece" args="(double aStartTime, double aEndTime, int &amp;oStartFrame, int &amp;oEndFrame) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::findFrameRange </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aStartTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aEndTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>oStartFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>oEndFrame</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the range of frames that is between start time and end time (inclusive). </p>
<p>Return the indices of the bounding frames. </p>

</div>
</div>
<a class="anchor" id="aaaa55ca6f6f65717badecda31791804c"></a><!-- doxytag: member="OpenSim::Storage::findIndex" ref="aaaa55ca6f6f65717badecda31791804c" args="(int aI, double aT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::findIndex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the index of the storage element that occured immediately before or at time aT ( aT &lt;= getTime(index) ). </p>
<p>This method can be much more efficient than findIndex(aT) if a good guess is made for aI. If aI corresponds to a state which occured later than aT, an exhaustive search is performed by calling findIndex(aT).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aI</em>&nbsp;</td><td>Index at which to start searching. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aT</em>&nbsp;</td><td>Time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index preceding or at time aT. If aT is less than the earliest time, 0 is returned. </dd></dl>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a41d5c2394c66796d64d370f5ed5fb4b4">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a2b2611013561cbc0a96922ad6da05d15"></a><!-- doxytag: member="OpenSim::Storage::findIndex" ref="a2b2611013561cbc0a96922ad6da05d15" args="(double aT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::findIndex </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the index of the storage element that occured immediately before or at a specified time ( getTime(index) &lt;= aT ). </p>
<p>This method is not very efficient because it always starts its search with the first stored state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aT</em>&nbsp;</td><td>Time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index preceding or at time aT. If aT is less than the earliest time, 0 is returned. </dd></dl>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a87840a54c34a8134ec23840f740c7ebe">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="aa99ac3cfe670ab642579e92202c01e4a"></a><!-- doxytag: member="OpenSim::Storage::getCapacityIncrement" ref="aa99ac3cfe670ab642579e92202c01e4a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getCapacityIncrement </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the capacity increment of this storage object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Capacity increment of this storage. For details on what the capacity increment does see <a class="el" href="classOpenSim_1_1Array.html#a14a93e0f3ffac301534392de881e1e72" title="Set the amount by which the capacity is increased when the capacity of of the array...">Array::setCapacityIncrement()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0317dbdd8992f308ec8bd1b038fe6f85"></a><!-- doxytag: member="OpenSim::Storage::getColumnLabels" ref="a0317dbdd8992f308ec8bd1b038fe6f85" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; string &gt; &amp; Storage::getColumnLabels </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get column labels array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Character string of column labels. </dd></dl>

</div>
</div>
<a class="anchor" id="afd30d0fa06df466f92fcb36d40b696ac"></a><!-- doxytag: member="OpenSim::Storage::getData" ref="afd30d0fa06df466f92fcb36d40b696ac" args="(int aTimeIndex, int aN, double *rData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getData </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aTimeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>rData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the first aN states at a specified time index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTimeIndex</em>&nbsp;</td><td>Time index at which to get the states. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Number of states to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rData</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> where the returned data will be set. The size of rData is assumed to be at least aN. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of states that were set. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b0dabd9267723fd0109d9fa1c407734"></a><!-- doxytag: member="OpenSim::Storage::getData" ref="a2b0dabd9267723fd0109d9fa1c407734" args="(int aTimeIndex, int aN, double **rData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getData </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aTimeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>rData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>At a specified time index, get a number of state values starting at a specified state. </p>
<p>The method simply gets part of a row of data from adjacent columns in the storage object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTimeIndex</em>&nbsp;</td><td>Time index at which to get the states. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aStateIndex</em>&nbsp;</td><td>Index of the state (column) at which to start getting the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Number of states to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rData</em>&nbsp;</td><td>Pointer to an array where the returned data will be set. The size of *rData is assumed to be at least aN. If rData comes in as NULL, memory is allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of states. </dd></dl>

</div>
</div>
<a class="anchor" id="a39483fc281f6666d092d3992185c4e18"></a><!-- doxytag: member="OpenSim::Storage::getData" ref="a39483fc281f6666d092d3992185c4e18" args="(int aTimeIndex, int aStateIndex, int aN, double *rData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getData </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aTimeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStateIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>rData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>At a specified time index, get a number of state values starting at a specified state. </p>
<p>The method simply gets part of a row of data from adjacent columns in the storage object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTimeIndex</em>&nbsp;</td><td>Index that identifies the time (row) at which to get the data value: 0 &lt;= aTimeIndex &lt; _storage.getSize(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aStateIndex</em>&nbsp;</td><td>Index of the state (column) at which to start getting the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Number of states (columns) to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rData</em>&nbsp;</td><td>Data values. rData should be able to hold at least N values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of states that were gotten. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b51f10628decda186d0cd14d17bf6d8"></a><!-- doxytag: member="OpenSim::Storage::getData" ref="a1b51f10628decda186d0cd14d17bf6d8" args="(int aTimeIndex, int aStateIndex, int aN, double **rData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getData </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aTimeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStateIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>rData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function for getData. </p>

</div>
</div>
<a class="anchor" id="acd608c8e7a93a04c450ce31505abd41a"></a><!-- doxytag: member="OpenSim::Storage::getData" ref="acd608c8e7a93a04c450ce31505abd41a" args="(int aTimeIndex, int aStateIndex, double &amp;rValue) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getData </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aTimeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStateIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>rValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a data value of a specified state at a specified time index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTimeIndex</em>&nbsp;</td><td>Index that identifies the time (row) at which to get the data value: 0 &lt;= aTimeIndex &lt; _storage.getSize(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aStateIndex</em>&nbsp;</td><td>Index of the state (column) for which to get the value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rValue</em>&nbsp;</td><td>Value of the state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8c990f3cf8e787899a0eb87f37ed8ce"></a><!-- doxytag: member="OpenSim::Storage::getDataAtTime" ref="ae8c990f3cf8e787899a0eb87f37ed8ce" args="(double aTime, int aN, Array&lt; double &gt; &amp;rData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getDataAtTime </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a7adac2006928c42529d6d266f5a9334f">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a28eb187b2723f5d207718277cd17596a"></a><!-- doxytag: member="OpenSim::Storage::getDataAtTime" ref="a28eb187b2723f5d207718277cd17596a" args="(double aTime, int aN, double *rData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getDataAtTime </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>rData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the first aN states at a specified time. </p>
<p>The values of the states are determined by linear interpolation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aT</em>&nbsp;</td><td>Time at which to get the states. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Number of states to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rData</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> where the returned data will be set. The size of rData is assumed to be at least aN. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of states that were set. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b14eb852052fc444b350369c3f85ef3"></a><!-- doxytag: member="OpenSim::Storage::getDataAtTime" ref="a9b14eb852052fc444b350369c3f85ef3" args="(double aTime, int aN, double **rData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getDataAtTime </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>rData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the first aN states at a specified time. </p>
<p>The values of the states are determined by linear interpolation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aT</em>&nbsp;</td><td>Time at which to get the states. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Number of states to get. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rData</em>&nbsp;</td><td>Pointer to an array where the returned data will be set. The size of *rData is assumed to be at least aN. If rData comes in as NULL, memory is allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of states that were set. </dd></dl>

</div>
</div>
<a class="anchor" id="a46ba35856fe4e58fb738a6820cb3332f"></a><!-- doxytag: member="OpenSim::Storage::getDataColumn" ref="a46ba35856fe4e58fb738a6820cb3332f" args="(const std::string &amp;columnName, Array&lt; double &gt; &amp;data, double startTime=0.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::getDataColumn </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>columnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aStartTime</em> = <code>0.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the data column starting at aTime. </p>
<p>Return it in rData rData is preallocated by the caller. </p>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a2d1e575dab4900138620c812e5fafe88">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a13763c771337662e825f7cbfa5271030"></a><!-- doxytag: member="OpenSim::Storage::getDataColumn" ref="a13763c771337662e825f7cbfa5271030" args="(const std::string &amp;columnName, double *&amp;rData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getDataColumn </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aColumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&nbsp;</td>
          <td class="paramname"> <em>rData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the data corresponding to a state specified by name. </p>
<p>This call is equivalent to getting a column of data from the storage file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aColumnName</em>&nbsp;</td><td>name in header of column for which to get the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rData</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> containing the desired data. If rData is sent in as NULL, memory is allocated. However, if rData is sent in as a non-NULL, it is assumed that rData points to a memory block that is large enough to hold <a class="el" href="classOpenSim_1_1Storage.html#aeeadf5347ea3d0355518cb4d9c506e24">getSize()</a> doubles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of values set in rData. The number of values set may be less than <a class="el" href="classOpenSim_1_1Storage.html#aeeadf5347ea3d0355518cb4d9c506e24">getSize()</a> because not all stored state vectors are required to have the same number of states. </dd></dl>

</div>
</div>
<a class="anchor" id="ad69c445edf687d360134e8b442468b88"></a><!-- doxytag: member="OpenSim::Storage::getDataColumn" ref="ad69c445edf687d360134e8b442468b88" args="(int aStateIndex, Array&lt; double &gt; &amp;rData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getDataColumn </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStateIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a93069a2816af0b7ee633cf37c0f9f786"></a><!-- doxytag: member="OpenSim::Storage::getDataColumn" ref="a93069a2816af0b7ee633cf37c0f9f786" args="(int aStateIndex, double *&amp;rData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getDataColumn </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStateIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&nbsp;</td>
          <td class="paramname"> <em>rData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the data corresponding to a specified state. </p>
<p>This call is equivalent to getting a column of data from the storage file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStateIndex</em>&nbsp;</td><td>Index of the state (column) for which to get the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rData</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> containing the desired data. If rData is sent in as NULL, memory is allocated. However, if rData is sent in as a non-NULL, it is assumed that rData points to a memory block that is large enough to hold <a class="el" href="classOpenSim_1_1Storage.html#aeeadf5347ea3d0355518cb4d9c506e24">getSize()</a> doubles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of values set in rData. The number of values set may be less than <a class="el" href="classOpenSim_1_1Storage.html#aeeadf5347ea3d0355518cb4d9c506e24">getSize()</a> because not all stored state vectors are required to have the same number of states. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3ad6289a019b30526c830994d9f3acb"></a><!-- doxytag: member="OpenSim::Storage::getDescription" ref="ab3ad6289a019b30526c830994d9f3acb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; OpenSim::Storage::getDescription </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the description of this object. </p>

<p>Reimplemented from <a class="el" href="classOpenSim_1_1Object.html#ab9362b31ab977b334072eab7794123ec">OpenSim::Object</a>.</p>

</div>
</div>
<a class="anchor" id="a2d982e0afcd82e77d7e39442bc581b3f"></a><!-- doxytag: member="OpenSim::Storage::getFirstTime" ref="a2d982e0afcd82e77d7e39442bc581b3f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Storage::getFirstTime </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the time of the first stored states. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Time of the first stored states. If there is no stored state, the constant SimTK::NaN (not a number) is returned. </dd></dl>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a92e20435cf7f9edaaf52e750981bfa15">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="acf714b8f3ea5aa97c74445a6e8420aa1"></a><!-- doxytag: member="OpenSim::Storage::getHeaderToken" ref="acf714b8f3ea5aa97c74445a6e8420aa1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; Storage::getHeaderToken </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the header token of this storage. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Header token. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1Storage.html#a43196bfd28dbbc22e71afb44aae21c8e" title="Set the header token.">setHeaderToken()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1d90debbb39fc006ca9cb483e28bac0b"></a><!-- doxytag: member="OpenSim::Storage::getLastStateVector" ref="a1d90debbb39fc006ca9cb483e28bac0b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> * Storage::getLastStateVector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the last states stored. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Statevector. If no state vector is stored, NULL is returned. </dd></dl>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a7e5b9f8526547ac461eac4fd8cfd91b0">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a64cb85afa3a41c5b80404deb2f9d56dc"></a><!-- doxytag: member="OpenSim::Storage::getLastTime" ref="a64cb85afa3a41c5b80404deb2f9d56dc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Storage::getLastTime </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the time of the last states. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Time of the first stored states. If there is no stored state, the constant SimTK::NaN (not a number) is returned. </dd></dl>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#ad134b28527ca3f3c84865817aa53f5d3">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="aad15c7586320e6c3b98e6b3119f91490"></a><!-- doxytag: member="OpenSim::Storage::getMinTimeStep" ref="aad15c7586320e6c3b98e6b3119f91490" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Storage::getMinTimeStep </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the smallest time step. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Smallest time step. If there are less than 2 state vectors, SimTK::Infinity is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a79779c85dc6bfa2528f9eab945e522f8"></a><!-- doxytag: member="OpenSim::Storage::getName" ref="a79779c85dc6bfa2528f9eab945e522f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; OpenSim::Storage::getName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of this object. </p>

<p>Reimplemented from <a class="el" href="classOpenSim_1_1Object.html#a40651ab63aba5bfb7ddc6f495d5d4b60">OpenSim::Object</a>.</p>

</div>
</div>
<a class="anchor" id="aeeadf5347ea3d0355518cb4d9c506e24"></a><!-- doxytag: member="OpenSim::Storage::getSize" ref="aeeadf5347ea3d0355518cb4d9c506e24" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OpenSim::Storage::getSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#ab8ecb61b7610df992fc5daf6180bc61c">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a1d6190784783c6c615776e10125ecf78"></a><!-- doxytag: member="OpenSim::Storage::getSmallestNumberOfStates" ref="a1d6190784783c6c615776e10125ecf78" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getSmallestNumberOfStates </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the smallest number of states. </p>
<p>Ordinarily, the number of states is the same in each state vector; however, this is not required. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Smallest number of states. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c0ea41be1f45fa359e7ab5b2f3701a1"></a><!-- doxytag: member="OpenSim::Storage::getStateIndex" ref="a2c0ea41be1f45fa359e7ab5b2f3701a1" args="(const std::string &amp;aColumnName, int startIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Storage::getStateIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aColumnName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the column index corresponding to specified column name. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>State index of column or -1. Note that the returned index is equivalent to the state index. For example, for the first column in a storage (usually time) -1 would be returned. For the second colunn in a storage (the first state) 0 would be returned. </dd></dl>
<p>added a default Parameter for startIndex. -Ayman </p>

</div>
</div>
<a class="anchor" id="abb09ca2050be7a8cb926910f532a2611"></a><!-- doxytag: member="OpenSim::Storage::getStateVector" ref="abb09ca2050be7a8cb926910f532a2611" args="(int aTimeIndex) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> * Storage::getStateVector </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aTimeIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the <a class="el" href="classOpenSim_1_1StateVector.html" title="A class which stores a vector of states or data at a specified time.">StateVector</a> at a spcified time index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTimeIndex</em>&nbsp;</td><td>Time index at which to get the state vector: 0 &lt;= aTimeIndex &lt; _storage.getSize(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Statevector. If no valid statevector exists at aTimeIndex, NULL is returned. </dd></dl>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a828a3999b8fc8c4c2170af32720b5991">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="ace7f9afaa03fd2615d29caab325a616b"></a><!-- doxytag: member="OpenSim::Storage::getStepInterval" ref="ace7f9afaa03fd2615d29caab325a616b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getStepInterval </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the step interval. </p>

</div>
</div>
<a class="anchor" id="a0a586d3e04d9803450ff848f7fe7a052"></a><!-- doxytag: member="OpenSim::Storage::getTime" ref="a0a586d3e04d9803450ff848f7fe7a052" args="(int aTimeIndex, double &amp;rTime, int aStateIndex=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Storage::getTime </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aTimeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>rTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStateIndex</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the time at a specified time index for a specified state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTimeIndex</em>&nbsp;</td><td>Time index (row) for which to get the time. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rTime</em>&nbsp;</td><td>Time value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aStateIndex</em>&nbsp;</td><td>Index of the state for which to get the time. By default, aStateIndex has a value of -1, which means disregard whether or not there is a valid state- just get the time at aTimeIndex. If aStateIndex is non-negative, the time is returned only if there is a valid state at aStateIndex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true when the time was set, false when there was no valid state. </dd></dl>

</div>
</div>
<a class="anchor" id="ac23ded50b157c9310989b3a0b317ae8d"></a><!-- doxytag: member="OpenSim::Storage::getTimeColumn" ref="ac23ded50b157c9310989b3a0b317ae8d" args="(Array&lt; double &gt; &amp;rTimes, int aStateIndex=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getTimeColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rTimes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStateIndex</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a953d669cfb42e657271fd2d17ffe3b2a">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a671b617e6323316980e7064d3b9c090c"></a><!-- doxytag: member="OpenSim::Storage::getTimeColumn" ref="a671b617e6323316980e7064d3b9c090c" args="(double *&amp;rTimes, int aStateIndex=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::getTimeColumn </td>
          <td>(</td>
          <td class="paramtype">double *&amp;&nbsp;</td>
          <td class="paramname"> <em>rTimes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStateIndex</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the times for a specified state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rTime</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> where times are set. If rTime is sent in as NULL, memory is allocated. If rTime is setn in as non-NULL, it is assumed that enough memory has been allocated at rTime to hold _storage.getSize() doubles. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aStateIndex</em>&nbsp;</td><td>Index of the state for which to get the times. By default, aStateIndex has a value of -1, which means disregard whether or not there is a valid state- just get the times. If aStateIndex is non-negative, the time is set only if there is a valid state at aStateIndex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of times set. This can be less than _storage.getSize() if a state does not exist for all or a subset of the stored statevectors. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3251a8522b1fe633849def4b691ba14"></a><!-- doxytag: member="OpenSim::Storage::getTimeColumnWithStartTime" ref="ae3251a8522b1fe633849def4b691ba14" args="(Array&lt; double &gt; &amp;rTimes, double startTime=0.0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::getTimeColumnWithStartTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rTimes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aStartTime</em> = <code>0.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the time column starting at aTime. </p>
<p>Return it in rTimes rTimes is preallocated by the caller. </p>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#ac760e9c05171d548861a7ebc77c6b6d0">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="aa44f52d25994c9582f70ebf1ecbdd969"></a><!-- doxytag: member="OpenSim::Storage::getValueForKey" ref="aa44f52d25994c9582f70ebf1ecbdd969" args="(const std::string &amp;aKey, std::string &amp;rValue) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::getValueForKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>rValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adfd055d50f777860d0bb9ac351bea347"></a><!-- doxytag: member="OpenSim::Storage::getWriteSIMMHeader" ref="adfd055d50f777860d0bb9ac351bea347" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Storage::getWriteSIMMHeader </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the whether or not to write a header appropriate for a SIMM motion file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTrueFalse</em>&nbsp;</td><td>Whether (true) or not (false) to write a SIMM header. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33936941624958b7902f4f7a6c02c3c0"></a><!-- doxytag: member="OpenSim::Storage::hasKey" ref="a33936941624958b7902f4f7a6c02c3c0" args="(const std::string &amp;aKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Storage::hasKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aKey</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b03feabf5cd1a0aa76fe78bb4cb32d0"></a><!-- doxytag: member="OpenSim::Storage::integrate" ref="a8b03feabf5cd1a0aa76fe78bb4cb32d0" args="(double aT1, double aT2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> * Storage::integrate </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aTI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aTF</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integrate the state vectors between times aTI and aTF. </p>
<p>The integration results are returned in an <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> instance that is a copy of this instance except the name has been appended with "_integrated" and, of course, the state vectors have been integrated. The caller is responsible for deleting the returned storage instance.</p>
<p>Note that if aTI and aTF do not fall exactly on the time stamp of a stored state, the states are linearly interpolated or extrapolated to provide an estimate of the state at aTI or at aTF.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTI</em>&nbsp;</td><td>Time at which to start the integration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTF</em>&nbsp;</td><td>Time at which to stop the integration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> instance of integrated results. NULL is returned if an error is encountered. </dd></dl>

</div>
</div>
<a class="anchor" id="afa75290cc36e8f0ea7a61e23892cfe75"></a><!-- doxytag: member="OpenSim::Storage::integrate" ref="afa75290cc36e8f0ea7a61e23892cfe75" args="(int aI1=&#45;2, int aI2=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> * Storage::integrate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aI1</em> = <code>-2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aI2</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integrate the state vectors between aI1 and aI2. </p>
<p>The integration results are returned in an <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> instance that is a copy of this instance except the name has been appended with "_integrated" and, of course, the state vectors have been integrated. The caller is responsible for deleting the returned storage instance.</p>
<p>If aI1 is negative, integrations starts at the first <a class="el" href="classOpenSim_1_1StateVector.html" title="A class which stores a vector of states or data at a specified time.">StateVector</a> held by this <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> instance. If aI2 is negative, integration starts at the last <a class="el" href="classOpenSim_1_1StateVector.html" title="A class which stores a vector of states or data at a specified time.">StateVector</a> held by this <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> instance.</p>
<p>Note that aI1 and aI2 have negative default values, so that this method may be called without arguments to integrate all StateVectors held by this <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aI1</em>&nbsp;</td><td>Index of state vector at which to start integration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aI2</em>&nbsp;</td><td>Index of state vector at which to stop integration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> instance of integrated results. NULL is returned if an error is encountered. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf9d072bc4c4046e039050e8768c4408"></a><!-- doxytag: member="OpenSim::Storage::interpolateAt" ref="aaf9d072bc4c4046e039050e8768c4408" args="(const Array&lt; double &gt; &amp;targetTimes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::interpolateAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>targetTimes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>interpolateAt passed in list of time values. </p>
<p>Tries to check if there is a data row at the specified times to avoid introducing duplicates. </p>

</div>
</div>
<a class="anchor" id="ae3049bf6dcd620208572654c1ad3ad9b"></a><!-- doxytag: member="OpenSim::Storage::lowpassFIR" ref="ae3049bf6dcd620208572654c1ad3ad9b" args="(int aOrder, double aCutoffFequency)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::lowpassFIR </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aCutoffFrequency</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lowpass filter each of the columns in the storage. </p>
<p>Note that as a part of this operation, the storage is resampled so that the statevectors are at equal spacing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aOrder</em>&nbsp;</td><td>Order of the FIR filter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCutoffFrequency</em>&nbsp;</td><td>Cutoff frequency. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a046d176a098a767be0c24053114d3577"></a><!-- doxytag: member="OpenSim::Storage::lowpassIIR" ref="a046d176a098a767be0c24053114d3577" args="(double aCutoffFequency)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::lowpassIIR </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aCutoffFrequency</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lowpass filter each of the columns in the storage. </p>
<p>Note that as a part of this operation, the storage is resampled so that the statevectors are at equal spacing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aOrder</em>&nbsp;</td><td>Order of the FIR filter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCutoffFrequency</em>&nbsp;</td><td>Cutoff frequency. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d9a9e61784736668e2784475d01998a"></a><!-- doxytag: member="OpenSim::Storage::makeStorageLabelsUnique" ref="a2d9a9e61784736668e2784475d01998a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Storage::makeStorageLabelsUnique </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Force.html" title="This abstract class represents a force applied to bodies or generalized coordinates...">Force</a> column labels for a <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> object to become unique. </p>
<p>This is done by appenging the string (n) as needed where n=1, 2, ...</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if labels were changed false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aec83f13fbcc57befcb3cecd2feeb47d7"></a><!-- doxytag: member="OpenSim::Storage::multiply" ref="aec83f13fbcc57befcb3cecd2feeb47d7" args="(Storage *aStorage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *&nbsp;</td>
          <td class="paramname"> <em>aStorage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multipy this storage instance by a storage instance. </p>
<p>Linear interpolation or extrapolation is used to get the values of the states that correspond in time to the states held in this storage instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStorage</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> instance by which to multiply. s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3e23fef09b9a2cb8e19c2e5866946b8"></a><!-- doxytag: member="OpenSim::Storage::multiply" ref="ac3e23fef09b9a2cb8e19c2e5866946b8" args="(StateVector *aStateVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> *&nbsp;</td>
          <td class="paramname"> <em>aStateVector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply all state vectors in this storage instance by a state vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStateVector</em>&nbsp;</td><td>State vector by which to multiply the state vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>StateVector::multiply(StateVector) </dd></dl>

</div>
</div>
<a class="anchor" id="ab9961091d67f841d46d597f92f08552e"></a><!-- doxytag: member="OpenSim::Storage::multiply" ref="ab9961091d67f841d46d597f92f08552e" args="(int aN, double aY[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::multiply </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aY</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply all state vectors in this storage instance by an array. </p>
<p>Only the first aN states of each state vector are altered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Length of aY </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aY</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> of values the states are to be multiplied by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1StateVector.html#addd5cf253188235a94d1ab7eb04197e2" title="Multiply the states by a value.">StateVector::multiply</a>(int,double[]) </dd></dl>

</div>
</div>
<a class="anchor" id="ac8e6b464a431fe227827519b3425b154"></a><!-- doxytag: member="OpenSim::Storage::multiply" ref="ac8e6b464a431fe227827519b3425b154" args="(double aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::multiply </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply all state vectors in this storage instance by a value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value by which to mutiply the state vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1StateVector.html#addd5cf253188235a94d1ab7eb04197e2" title="Multiply the states by a value.">StateVector::multiply(double)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acd5ffc32050a7299ff219ddd0c7c6fb8"></a><!-- doxytag: member="OpenSim::Storage::multiplyColumn" ref="acd5ffc32050a7299ff219ddd0c7c6fb8" args="(int aIndex, double aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::multiplyColumn </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply entries at column aIndex by a value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aIndex</em>&nbsp;</td><td>is the index of the column to multiply </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value by which to mutiply the column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf3ba558195c62b9675e0ec1bac1cd23"></a><!-- doxytag: member="OpenSim::Storage::pad" ref="aaf3ba558195c62b9675e0ec1bac1cd23" args="(int aPadSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::pad </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aPadSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pad each of the columns in a statevector by a specified amount. </p>
<p>Data is both prepended and appended by reflecting and negating.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aPadSize</em>&nbsp;</td><td>Number of data points to prepend and append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6593f8074ece310fe51a09f0c79548db"></a><!-- doxytag: member="OpenSim::Storage::print" ref="a6593f8074ece310fe51a09f0c79548db" args="(const std::string &amp;aFileName, double aDT, const std::string &amp;aMode=&quot;w&quot;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenSim::Storage::print </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aDT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aMode</em> = <code>&quot;w&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a22abd314e0e07069d0eaaa54b9645d61"></a><!-- doxytag: member="OpenSim::Storage::print" ref="a22abd314e0e07069d0eaaa54b9645d61" args="(const std::string &amp;aFileName, const std::string &amp;aMode=&quot;w&quot;, const std::string &amp;aComment=&quot;&quot;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenSim::Storage::print </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aMode</em> = <code>&quot;w&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aComment</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abd01fa11849b97cf7e888c25acd1dffd"></a><!-- doxytag: member="OpenSim::Storage::print" ref="abd01fa11849b97cf7e888c25acd1dffd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::print </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the contents of this storage instance to standard output. </p>

</div>
</div>
<a class="anchor" id="a9d0cbcb6c4e6ecf207a0ad8c6fe11a47"></a><!-- doxytag: member="OpenSim::Storage::printResult" ref="a9d0cbcb6c4e6ecf207a0ad8c6fe11a47" args="(const Storage *aStorage, const std::string &amp;aName, const std::string &amp;aDir, double aDT, const std::string &amp;aExtension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::printResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *&nbsp;</td>
          <td class="paramname"> <em>aStorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aDT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aExtension</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afa7717a4c221f4b038ead6d3b7e55b94"></a><!-- doxytag: member="OpenSim::Storage::purge" ref="afa7717a4c221f4b038ead6d3b7e55b94" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Storage::purge </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adb7be2ee9e5be4d8ec4db79029aa9c9c"></a><!-- doxytag: member="OpenSim::Storage::resample" ref="adb7be2ee9e5be4d8ec4db79029aa9c9c" args="(double aDT, int aDegree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Storage::resample </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aDT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aDegree</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resample <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> columns to specified rate. </p>
<p>This's done by fitting splines to <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> columns and resampling</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDT</em>&nbsp;</td><td>Time interval between adjacent statevectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Actual sampling time step (may be clamped) </dd></dl>

</div>
</div>
<a class="anchor" id="a3e7347ae928c68129b416e2fb8ca9227"></a><!-- doxytag: member="OpenSim::Storage::resampleLinear" ref="a3e7347ae928c68129b416e2fb8ca9227" args="(double aDT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Storage::resampleLinear </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aDT</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resample using linear interpolation. </p>

</div>
</div>
<a class="anchor" id="a3e8b4b9b3870d774cb0f05bec18a4527"></a><!-- doxytag: member="OpenSim::Storage::reset" ref="a3e8b4b9b3870d774cb0f05bec18a4527" args="(double aTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::reset </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the storage to start storing after a specified time. </p>
<p>If no valid statevector exists at that specified time, the storage is set to occur after the first valid statevector that immediately precedes the specified time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aT</em>&nbsp;</td><td>Time after which to start storing states. If aT doesn't exist exactly in the storage, the time is rounded down to the first valid time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index at which the next appended statevector will be stored. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c68c9ac19e7b844bff5638ea6412ad4"></a><!-- doxytag: member="OpenSim::Storage::reset" ref="a0c68c9ac19e7b844bff5638ea6412ad4" args="(int aIndex=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::reset </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aIndex</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the storage to start storing at a specified index. </p>
<p>All statevectors at and following the specified index are discarded.</p>
<p>If aIndex is less than or equal to zero, the storage object is emptied (i.e., its size is set to 0).</p>
<p>If aIndex is larger than the current size of the storage object, no action is taken.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aIndex</em>&nbsp;</td><td>Index at which to start storing new statevectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Index at which the next appended statevector will be stored. </dd></dl>

</div>
</div>
<a class="anchor" id="ac34f8b0052abeca502367b73d946e536"></a><!-- doxytag: member="OpenSim::Storage::scaleTime" ref="ac34f8b0052abeca502367b73d946e536" args="(double aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::scaleTime </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Scale.html">Scale</a> the times of all state vectors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value by which to scale the times. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa936add9494bde3c6953acb9154d9b7b"></a><!-- doxytag: member="OpenSim::Storage::setCapacityIncrement" ref="aa936add9494bde3c6953acb9154d9b7b" args="(int aIncrement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::setCapacityIncrement </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aIncrement</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the capacity increment of this storage object. </p>
<p>For details on what the capacity increment does see <a class="el" href="classOpenSim_1_1Array.html#a14a93e0f3ffac301534392de881e1e72" title="Set the amount by which the capacity is increased when the capacity of of the array...">Array::setCapacityIncrement()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aIncrement</em>&nbsp;</td><td>Capacity increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1Array.html">Array</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbf5736671c1c8527a65545920fba907"></a><!-- doxytag: member="OpenSim::Storage::setColumnLabels" ref="afbf5736671c1c8527a65545920fba907" args="(const Array&lt; std::string &gt; &amp;aColumnLabels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::setColumnLabels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aColumnLabels</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> column labels array. </p>

</div>
</div>
<a class="anchor" id="a921cf7ac20c64307478b6c2c7cafd1fe"></a><!-- doxytag: member="OpenSim::Storage::setDataColumn" ref="a921cf7ac20c64307478b6c2c7cafd1fe" args="(int aStateIndex, const Array&lt; double &gt; &amp;aData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::setDataColumn </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStateIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the data corresponding to a specified state. </p>
<p>This call is equivalent to setting a column of data from the storage file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStateIndex</em>&nbsp;</td><td>Index of the state (column) for which to get the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aData</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> containing the new data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of values set in rData. The number of values set may be less than <a class="el" href="classOpenSim_1_1Storage.html#aeeadf5347ea3d0355518cb4d9c506e24">getSize()</a> because not all stored state vectors are required to have the same number of states. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7cb45aa2c24af1754e9afba280a190a"></a><!-- doxytag: member="OpenSim::Storage::setDescription" ref="ae7cb45aa2c24af1754e9afba280a190a" args="(const std::string &amp;aDescription)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Storage::setDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aDescription</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOpenSim_1_1Object.html#a8121d7c3d138ca194e75554888eb5d43">OpenSim::Object</a>.</p>

</div>
</div>
<a class="anchor" id="a43196bfd28dbbc22e71afb44aae21c8e"></a><!-- doxytag: member="OpenSim::Storage::setHeaderToken" ref="a43196bfd28dbbc22e71afb44aae21c8e" args="(const std::string &amp;aToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::setHeaderToken </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aToken</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the header token. </p>
<p>The header token is used to mark the end of the header portion of an <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> when an <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> is saved in a file.</p>
<p>If the header token is NULL, a default header token is used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aToken</em>&nbsp;</td><td>Header token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cd5760e04c721afe581f25cface572e"></a><!-- doxytag: member="OpenSim::Storage::setName" ref="a4cd5760e04c721afe581f25cface572e" args="(const std::string &amp;aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Storage::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classOpenSim_1_1Object.html#a8308f41560dae2d55f358129ae00bf52">OpenSim::Object</a>.</p>

</div>
</div>
<a class="anchor" id="ac675bbd9d8e8db518ed84204757c9256"></a><!-- doxytag: member="OpenSim::Storage::setOutputFileName" ref="ac675bbd9d8e8db518ed84204757c9256" args="(const std::string &amp;aFileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::setOutputFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> name of output file to be written into. </p>
<p>This has the side effect of openning the file for writing. The header will not have the correct number of rows but this may not be an issue for ersion 2 of the <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> class </p>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a0cedfaa0faddaa7a5967a6de5ed11710">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="a1c4d690f29d0412a622d9b9415cea4ba"></a><!-- doxytag: member="OpenSim::Storage::setStepInterval" ref="a1c4d690f29d0412a622d9b9415cea4ba" args="(int aStepInterval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::setStepInterval </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStepInterval</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the step interval. </p>

</div>
</div>
<a class="anchor" id="a8f9340332d4e9bc6111bc4aefee3a68b"></a><!-- doxytag: member="OpenSim::Storage::setWriteSIMMHeader" ref="a8f9340332d4e9bc6111bc4aefee3a68b" args="(bool aTrueFalse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::setWriteSIMMHeader </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aTrueFalse</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the whether or not to write a header appropriate for a SIMM motion file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTrueFalse</em>&nbsp;</td><td>Whether (true) or not (false) to write a SIMM header. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8261da0c0a09c0a9716cee047426350"></a><!-- doxytag: member="OpenSim::Storage::shiftTime" ref="aa8261da0c0a09c0a9716cee047426350" args="(double aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::shiftTime </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shift the times of all state vectors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value by which to shift the times. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8aec0bb90cf0b0633e4dbac0f4cbc925"></a><!-- doxytag: member="OpenSim::Storage::smoothSpline" ref="a8aec0bb90cf0b0633e4dbac0f4cbc925" args="(int aOrder, double aCutoffFrequency)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::smoothSpline </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aCutoffFrequency</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Smooth spline each of the columns in the storage. </p>
<p>Note that as a part of this operation, the storage is resampled so that the statevectors are at equal spacing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aOrder</em>&nbsp;</td><td>Order of the spline. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCutoffFrequency</em>&nbsp;</td><td>Cutoff frequency. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7c2ae9160a2833c8faa4417de6768d8"></a><!-- doxytag: member="OpenSim::Storage::store" ref="ad7c2ae9160a2833c8faa4417de6768d8" args="(int aStep, double aT, int aN, const double *aY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Storage::store </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aY</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store a simulation vector. </p>
<p>This method differs from append in that, if the integration step of a simulation is not a multiple of the step interval of this <a class="el" href="classOpenSim_1_1Storage.html">Storage</a> class, the state is not appended. Note that if the step storage interval is 0, storage is turned off.</p>
<p>The first empty storage location is returned. </p>

<p>Implements <a class="el" href="classOpenSim_1_1StorageInterface.html#a4731af60846ca404c7cf20f8c0bacd00">OpenSim::StorageInterface</a>.</p>

</div>
</div>
<a class="anchor" id="acc896c2b82d650d9f851d70ca2eb4d30"></a><!-- doxytag: member="OpenSim::Storage::subtract" ref="acc896c2b82d650d9f851d70ca2eb4d30" args="(Storage *aStorage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> *&nbsp;</td>
          <td class="paramname"> <em>aStorage</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract a storage instance to this storage instance. </p>
<p>Linear interpolation or extrapolation is used to get the values of the states that correspond in time to the states held in this storage instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStorage</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Storage.html">Storage</a> to subtract from this storage. s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f9994828fbc969a0a1c57ff199e1b52"></a><!-- doxytag: member="OpenSim::Storage::subtract" ref="a4f9994828fbc969a0a1c57ff199e1b52" args="(StateVector *aStateVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a> *&nbsp;</td>
          <td class="paramname"> <em>aStateVector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract a state vector from all state vectors in this storage instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aStateVector</em>&nbsp;</td><td>State vector to subtract from the state vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1StateVector.html#a9b0861ca67b1499d3a415c6c38f0d6d1" title="Subtract a value from each state.">StateVector::subtract</a>(int,double[]) </dd></dl>

</div>
</div>
<a class="anchor" id="af5c9f86cb883a820a5de76b4d161f50d"></a><!-- doxytag: member="OpenSim::Storage::subtract" ref="af5c9f86cb883a820a5de76b4d161f50d" args="(int aN, double aY[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::subtract </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aY</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract an array from all state vectors in this storage instance. </p>
<p>Only the first aN states of each state vector are altered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Length of aY </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aY</em>&nbsp;</td><td><a class="el" href="classOpenSim_1_1Array.html">Array</a> of values to subtract from the state vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1StateVector.html#a9b0861ca67b1499d3a415c6c38f0d6d1" title="Subtract a value from each state.">StateVector::subtract</a>(int,double[]) </dd></dl>

</div>
</div>
<a class="anchor" id="a67fc901e35d2b5351a62ae9b66f0ecdf"></a><!-- doxytag: member="OpenSim::Storage::subtract" ref="a67fc901e35d2b5351a62ae9b66f0ecdf" args="(double aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::subtract </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract a value from all state vectors in this storage instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>Value to subtract from the state vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classOpenSim_1_1StateVector.html#a9b0861ca67b1499d3a415c6c38f0d6d1" title="Subtract a value from each state.">StateVector::subtract(double)</a> </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ac7910a5e3c35dae4a8827f66e5590653"></a><!-- doxytag: member="OpenSim::Storage::_columnLabels" ref="ac7910a5e3c35dae4a8827f66e5590653" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt;std::string&gt; <a class="el" href="classOpenSim_1_1Storage.html#ac7910a5e3c35dae4a8827f66e5590653">OpenSim::Storage::_columnLabels</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Column labels. </p>

</div>
</div>
<a class="anchor" id="a59d6d892194a8f55b03a1ffd39989971"></a><!-- doxytag: member="OpenSim::Storage::_description" ref="a59d6d892194a8f55b03a1ffd39989971" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classOpenSim_1_1Storage.html#a59d6d892194a8f55b03a1ffd39989971">OpenSim::Storage::_description</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A description of the object. </p>
<p>-&gt; rdSerializable interface </p>

<p>Reimplemented from <a class="el" href="classOpenSim_1_1Object.html#acad4529fe7b19f09e6c1ca381a2fa2f8">OpenSim::Object</a>.</p>

</div>
</div>
<a class="anchor" id="aea1c769d45399c5be0c455ab149d359f"></a><!-- doxytag: member="OpenSim::Storage::_fileName" ref="aea1c769d45399c5be0c455ab149d359f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classOpenSim_1_1Storage.html#aea1c769d45399c5be0c455ab149d359f">OpenSim::Storage::_fileName</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cache for fileName and file pointer when the file is opened so we can flush and write intermediate files if needed. </p>

</div>
</div>
<a class="anchor" id="a55e8a172ee5db206cbed4733c0a21f60"></a><!-- doxytag: member="OpenSim::Storage::_fp" ref="a55e8a172ee5db206cbed4733c0a21f60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* <a class="el" href="classOpenSim_1_1Storage.html#a55e8a172ee5db206cbed4733c0a21f60">OpenSim::Storage::_fp</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a766fbc5ee487820620ba477d29cae595"></a><!-- doxytag: member="OpenSim::Storage::_headerToken" ref="a766fbc5ee487820620ba477d29cae595" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classOpenSim_1_1Storage.html#a766fbc5ee487820620ba477d29cae595">OpenSim::Storage::_headerToken</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Token used to mark the end of the description in a file. </p>

</div>
</div>
<a class="anchor" id="aac082a43ac237c03ccbab990aefbf3a9"></a><!-- doxytag: member="OpenSim::Storage::_keyValueMap" ref="aac082a43ac237c03ccbab990aefbf3a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MapKeysToValues <a class="el" href="classOpenSim_1_1Storage.html#aac082a43ac237c03ccbab990aefbf3a9">OpenSim::Storage::_keyValueMap</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Map between keys in file header and values. </p>

</div>
</div>
<a class="anchor" id="a903a7fef57c6d4d91237c57f58e9f23c"></a><!-- doxytag: member="OpenSim::Storage::_lastI" ref="a903a7fef57c6d4d91237c57f58e9f23c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Storage.html#a903a7fef57c6d4d91237c57f58e9f23c">OpenSim::Storage::_lastI</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Last index at which a search was started. </p>

</div>
</div>
<a class="anchor" id="ab3769ffec960c64a6623a374acb2dae9"></a><!-- doxytag: member="OpenSim::Storage::_name" ref="ab3769ffec960c64a6623a374acb2dae9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classOpenSim_1_1Storage.html#ab3769ffec960c64a6623a374acb2dae9">OpenSim::Storage::_name</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name and Description. </p>

<p>Reimplemented from <a class="el" href="classOpenSim_1_1Object.html#a8d744cee8565c0a26412675d5f58c50e">OpenSim::Object</a>.</p>

</div>
</div>
<a class="anchor" id="ade3e3b6dea78c4a25ec81e29285c57f4"></a><!-- doxytag: member="OpenSim::Storage::_stepInterval" ref="ade3e3b6dea78c4a25ec81e29285c57f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Storage.html#ade3e3b6dea78c4a25ec81e29285c57f4">OpenSim::Storage::_stepInterval</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Step interval at which states in a simulation are stored. </p>
<p>See <a class="el" href="classOpenSim_1_1Storage.html#ad7c2ae9160a2833c8faa4417de6768d8" title="Store a simulation vector.">store()</a>. </p>

</div>
</div>
<a class="anchor" id="a6a3ca0a579d96363c2e79e691f34b5a3"></a><!-- doxytag: member="OpenSim::Storage::_storage" ref="a6a3ca0a579d96363c2e79e691f34b5a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt;<a class="el" href="classOpenSim_1_1StateVector.html">StateVector</a>&gt; <a class="el" href="classOpenSim_1_1Storage.html#a6a3ca0a579d96363c2e79e691f34b5a3">OpenSim::Storage::_storage</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Array.html">Array</a> of StateVectors. </p>

</div>
</div>
<a class="anchor" id="a465e44061bc8b343bb505089d6716048"></a><!-- doxytag: member="OpenSim::Storage::_units" ref="a465e44061bc8b343bb505089d6716048" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Units.html">Units</a> <a class="el" href="classOpenSim_1_1Storage.html#a465e44061bc8b343bb505089d6716048">OpenSim::Storage::_units</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Units.html" title="A class implementing various units for measuring quantities.">Units</a> in which the data is represented. </p>

</div>
</div>
<a class="anchor" id="a466c205541be980bfc0218db76d77ce8"></a><!-- doxytag: member="OpenSim::Storage::_writeSIMMHeader" ref="a466c205541be980bfc0218db76d77ce8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOpenSim_1_1Storage.html#a466c205541be980bfc0218db76d77ce8">OpenSim::Storage::_writeSIMMHeader</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flag for whether or not to insert a SIMM style header. </p>

</div>
</div>
<a class="anchor" id="ab66065724f81afd76dc9360694a9f82d"></a><!-- doxytag: member="OpenSim::Storage::DEFAULT_HEADER_SEPARATOR" ref="ab66065724f81afd76dc9360694a9f82d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classOpenSim_1_1Storage.html#ab66065724f81afd76dc9360694a9f82d">Storage::DEFAULT_HEADER_SEPARATOR</a> = &quot; \t\r\n&quot;<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae58dd0c88d6e40845142ea5c1f27abc8"></a><!-- doxytag: member="OpenSim::Storage::DEFAULT_HEADER_TOKEN" ref="ae58dd0c88d6e40845142ea5c1f27abc8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classOpenSim_1_1Storage.html#ae58dd0c88d6e40845142ea5c1f27abc8">Storage::DEFAULT_HEADER_TOKEN</a> = &quot;endheader&quot;<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default token used to mark the end of the storage description in a file. </p>

</div>
</div>
<a class="anchor" id="a165f803c99ae3e1cefa9c71b6e12d68f"></a><!-- doxytag: member="OpenSim::Storage::MAX_RESAMPLE_SIZE" ref="a165f803c99ae3e1cefa9c71b6e12d68f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classOpenSim_1_1Storage.html#a165f803c99ae3e1cefa9c71b6e12d68f">Storage::MAX_RESAMPLE_SIZE</a> = 100000<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6348da7e089075920caf7d40e38b5ca4"></a><!-- doxytag: member="OpenSim::Storage::simmReservedKeys" ref="a6348da7e089075920caf7d40e38b5ca4" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classOpenSim_1_1Storage.html#a6348da7e089075920caf7d40e38b5ca4">Storage::simmReservedKeys</a><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
                                                                  <span class="stringliteral">&quot;#&quot;</span>,
                                                                  <span class="stringliteral">&quot;range&quot;</span>, <span class="stringliteral">&quot;Range&quot;</span>,
                                                                  <span class="stringliteral">&quot;wrap&quot;</span>, <span class="stringliteral">&quot;Wrap&quot;</span>, <span class="stringliteral">&quot;WRAP&quot;</span>,
                                                                  <span class="stringliteral">&quot;event&quot;</span>,
                                                                  <span class="stringliteral">&quot;enforce_loops&quot;</span>,
                                                                  <span class="stringliteral">&quot;enforce_constraints&quot;</span>,
                                                                  <span class="stringliteral">&quot;calc_derivatives&quot;</span>}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>OpenSim/Common/Storage.h</li>
<li>OpenSim/Common/Storage.cpp</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Mon Nov 8 15:37:06 2010 for OpenSim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
