// rdSecondOrderTarget.cpp
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Copyright (c) 2006 Stanford University and Realistic Dynamics, Inc.
// Contributors: Frank C. Anderson, Ph.D.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject
// to the following conditions:
// 
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS,
// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
// THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// This software, originally developed by Realistic Dynamics, Inc., was
// transferred to Stanford University on November 1, 2006.
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//==============================================================================
// INCLUDES
//==============================================================================
#include "rdSecondOrderTarget.h"
#include <iostream>
#include <NMBLTK/Tools/rdException.h>

using namespace std;


//==============================================================================
// DESTRUCTOR & CONSTRUCTIOR(S)
//==============================================================================
//______________________________________________________________________________
/**
 * Destructor.
 */
rdSecondOrderTarget::~rdSecondOrderTarget()
{
}
//______________________________________________________________________________
/**
 * Constructor.
 */
rdSecondOrderTarget::rdSecondOrderTarget(int aNX,rdCMC *aController) :
	rdOptimizationTarget(aNX),
	_y(0.0), _dqdt(0.0), _dudt(0.0)
{
	setNull();

	// CONTROLLER
	_controller = aController;

	// NUMBER OF CONTROLS
	_nx = aNX;
	if(_nx<=0) {
		throw(rdException("rdSecondOrderTarget: ERROR- no controls.\n"));
	}

	// ALLOCATE STATE ARRAYS
	rdModel *model = _controller->getModel();
	if(model==NULL) {
		throw(rdException("rdSecondOrderTarget: ERROR- no model.\n"));
	}
	int ny = model->getNY();
	int nq = model->getNQ();
	int nu = model->getNU();
	_y.setSize(ny);
	_dqdt.setSize(nq);
	_dudt.setSize(nu);

	// NUMBERS OF CONSTRAINTS
	_nineqn = 0;
	_nineq = 0;
	_neqn = 0;
	_neq = 0;

	// DERIVATIVE PERTURBATION SIZES;
	setDX(1.0e-6);
}


//==============================================================================
// CONSTRUCTION AND DESTRUCTION
//==============================================================================
//______________________________________________________________________________
/**
 * Set all member variables to their NULL values.
 */
void rdSecondOrderTarget::
setNull()
{
	_controller = NULL;
	_y = NULL;
	_dqdt = NULL;
	_dudt = NULL;
}


//==============================================================================
// SET AND GET
//==============================================================================



//==============================================================================
// PERFORMANCE AND CONSTRAINTS
//==============================================================================
//------------------------------------------------------------------------------
// PERFORMANCE AND CONSTRAINTS
//------------------------------------------------------------------------------
//______________________________________________________________________________
/**
 * Compute performance and the constraints given x.
 * Note - used by paramopt.
 */
int rdSecondOrderTarget::
compute(double *x,double *p,double *c)
{
	int status = 0;
	return(status);
}
//______________________________________________________________________________
/**
 * Compute the gradients of the performance and the constraints given x.
 * The array dx is an array of perturbation sizes which can be used to
 * compute the gradients numerically.
 *
 * Note- used by paramopt.
 */
int rdSecondOrderTarget::
computeGradients(double *dx,double *x,double *dpdx,double *dcdx)
{
	int status = 0;
	return(status);
}

//------------------------------------------------------------------------------
// PERFORMANCE
//------------------------------------------------------------------------------
//______________________________________________________________________________
/**
 * Compute performance given x.
 */
int rdSecondOrderTarget::
computePerformance(double *aX,double *rP)
{
	rdModel *model = _controller->getModel();
	rdCMC_TaskSet *taskSet = _controller->getTaskSet();

	// COMPUTE STATE DERIVATIVES
	double t = model->getTime();
	double tReal = t * model->getTimeNormConstant();
	model->getStates(&_y[0]);
	model->deriv(t,aX,&_y[0],&_dqdt[0],&_dudt[0]);

	// COMPUTE ACCELERATIONS
	taskSet->computeAccelerations();
	taskSet->computeDesiredAccelerations(tReal);
	rdArray<double> &w = taskSet->getWeights();
	rdArray<double> &aDes = taskSet->getDesiredAccelerations();
	rdArray<double> &a = taskSet->getAccelerations();

	// PERFORMANCE
	int i;
	int nx = model->getNX();
	int na = aDes.getSize();
	double px,pa;
	for(px=0.0,i=0;i<model->getNX();i++) {
		px += aX[i]*aX[i];
	}
	for(pa=0.0,i=0;i<na;i++) {
		//cout<<w[i]<<" "<<aDes[i]<<" "<<a[i]<<endl;
		pa += w[i]*(aDes[i]-a[i])*(aDes[i]-a[i]);
	}
	//cout<<"pa = "<<pa<<endl;
	*rP = px + pa;

	return(0);
}
//______________________________________________________________________________
/**
 * Compute the gradient of performance given x.
 */
int rdSecondOrderTarget::
computePerformanceGradient(double *x,double *dpdx)
{
	int status = rdFSQP::CentralDifferences(this,_dx,x,dpdx);
	return(status);
}

//------------------------------------------------------------------------------
// CONSTRAINT
//------------------------------------------------------------------------------
//______________________________________________________________________________
/**
 * Compute constraint i given x.
 * Note that the indexing starts at 1;
 */
int rdSecondOrderTarget::
computeConstraint(double *x,int ic,double *c)
{
	int status = 0;
	return(status);
}
//______________________________________________________________________________
/**
 * Compute the gradient of constraint i given x.
 */
int rdSecondOrderTarget::
computeConstraintGradient(double *x,int ic,double *dcdx)
{
	// COMPUTE GRADIENT
	int status = rdFSQP::CentralDifferencesConstraint(this,_dx,x,ic,dcdx);
	return(0);
}

