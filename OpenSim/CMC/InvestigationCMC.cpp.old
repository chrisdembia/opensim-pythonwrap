// InvestigationCMC.cpp
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Copyright 2006 Realistic Dynamics, Inc.
// All rights reserved.
//
// Please do not read, copy, distribute, or use without permission.
// Contact: Frank C. Anderson, fc.anderson@RealisticDynamics.com
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//=============================================================================
// INCLUDES
//=============================================================================
#include "InvestigationCMC.h"
#include <OpenSim/Tools/IO.h>
#include <OpenSim/Tools/GCVSplineSet.h>
#include <OpenSim/Tools/VectorGCVSplineR1R3.h>
#include <OpenSim/Simulation/Model/Model.h>
#include <OpenSim/Simulation/Model/DerivCallbackSet.h>
#include <OpenSim/Simulation/Model/AnalysisSet.h>
#include <OpenSim/Simulation/Model/ModelIntegrand.h>
#include <OpenSim/Simulation/Model/ModelIntegrandForActuators.h>
#include <OpenSim/Simulation/Manager/Manager.h>
#include <OpenSim/Simulation/Control/ControlLinear.h>
#include <OpenSim/Simulation/Control/ControlSet.h>
#include <RDI/CMC/rdCMC.h>
#include <RDI/CMC/rdCMC_Joint.h>
#include <RDI/CMC/rdCMC_TaskSet.h>
#include <RDI/CMC/rdActuatorForceTarget.h>
#include <RDI/CMC/rdActuatorForceTargetFast.h>

using namespace std;
using namespace OpenSim;


//=============================================================================
// CONSTRUCTOR(S) AND DESTRUCTOR
//=============================================================================
//_____________________________________________________________________________
/**
 * Destructor.
 */
InvestigationCMC::~InvestigationCMC()
{
}
//_____________________________________________________________________________
/**
 * Default constructor.
 */
InvestigationCMC::InvestigationCMC() :
	Investigation(),
	_desiredKinematicsFileName(_desiredKinematicsFileNameProp.getValueStr()),
	_taskSetFileName(_taskSetFileNameProp.getValueStr()),
	_constraintsFileName(_constraintsFileNameProp.getValueStr()),
	_qFileName(_qFileNameProp.getValueStr()),
	_yFileName(_yFileNameProp.getValueStr()),
	_targetDT(_targetDTProp.getValueDbl()),
	_convergenceCriterion(_convergenceCriterionProp.getValueDbl()),
	_useFastTarget(_useFastTargetProp.getValueBool()),
	_printLevel(_printLevelProp.getValueInt())
{
	setType("InvestigationCMC");
	setNull();
}
//_____________________________________________________________________________
/**
 * Construct from file.
 *
 * The object is constructed from the root element of the XML document.
 * The type of object is the tag name of the XML root element.
 *
 * @param aFileName File name of the document.
 */
InvestigationCMC::InvestigationCMC(const string &aFileName) :
	Investigation(aFileName),
	_desiredKinematicsFileName(_desiredKinematicsFileNameProp.getValueStr()),
	_taskSetFileName(_taskSetFileNameProp.getValueStr()),
	_constraintsFileName(_constraintsFileNameProp.getValueStr()),
	_qFileName(_qFileNameProp.getValueStr()),
	_yFileName(_yFileNameProp.getValueStr()),
	_targetDT(_targetDTProp.getValueDbl()),
	_convergenceCriterion(_convergenceCriterionProp.getValueDbl()),
	_useFastTarget(_useFastTargetProp.getValueBool()),
	_printLevel(_printLevelProp.getValueInt())
{
	setType("InvestigationCMC");
	setNull();
	updateFromXMLNode();
}
//_____________________________________________________________________________
/**
 * Construct from a DOMElement.
 */
InvestigationCMC::InvestigationCMC(DOMElement *aElement) :
	Investigation(aElement),
	_desiredKinematicsFileName(_desiredKinematicsFileNameProp.getValueStr()),
	_taskSetFileName(_taskSetFileNameProp.getValueStr()),
	_constraintsFileName(_constraintsFileNameProp.getValueStr()),
	_qFileName(_qFileNameProp.getValueStr()),
	_yFileName(_yFileNameProp.getValueStr()),
	_targetDT(_targetDTProp.getValueDbl()),
	_convergenceCriterion(_convergenceCriterionProp.getValueDbl()),
	_useFastTarget(_useFastTargetProp.getValueBool()),
	_printLevel(_printLevelProp.getValueInt())
{
	setType("InvestigationCMC");
	setNull();
	updateFromXMLNode();
}
//_____________________________________________________________________________
/**
 * Copy constructor.
 *
 * Copy constructors for all Investigation's only copy the non-XML variable
 * members of the object; that is, the object's DOMnode and XMLDocument
 * are not copied but set to NULL.  The reason for this is that for the
 * object and all its derived classes to establish the correct connection
 * to the XML document nodes, the the object would need to reconstruct based
 * on the XML document not the values of the object's member variables.
 *
 * There are three proper ways to generate an XML document for an Investigation:
 *
 * 1) Construction based on XML file (@see Investigation(const char *aFileName)).
 * In this case, the XML document is created by parsing the XML file.
 *
 * 2) Construction by Investigation(const XMLDocument *aDocument).
 * This constructor explictly requests construction based on an
 * XML document.  In this way the proper connection between an object's node
 * and the corresponding node within the XML document is established.
 * This constructor is a copy constructor of sorts because all essential
 * Investigation member variables should be held within the XML document.
 * The advantage of this style of construction is that nodes
 * within the XML document, such as comments that may not have any
 * associated Investigation member variable, are preserved.
 *
 * 3) A call to generateDocument().
 * This method generates an XML document for the Investigation from scratch.
 * Only the essential document nodes are created (that is, nodes that
 * correspond directly to member variables.).
 *
 * @param aInvestigation Object to be copied.
 * @see Investigation(const XMLDocument *aDocument)
 * @see Investigation(const char *aFileName)
 * @see generateDocument()
 */
InvestigationCMC::
InvestigationCMC(const InvestigationCMC &aInvestigation) :
	Investigation(aInvestigation),
	_desiredKinematicsFileName(_desiredKinematicsFileNameProp.getValueStr()),
	_taskSetFileName(_taskSetFileNameProp.getValueStr()),
	_constraintsFileName(_constraintsFileNameProp.getValueStr()),
	_qFileName(_qFileNameProp.getValueStr()),
	_yFileName(_yFileNameProp.getValueStr()),
	_targetDT(_targetDTProp.getValueDbl()),
	_convergenceCriterion(_convergenceCriterionProp.getValueDbl()),
	_useFastTarget(_useFastTargetProp.getValueBool()),
	_printLevel(_printLevelProp.getValueInt())
{
	setType("InvestigationCMC");
	setNull();
	*this = aInvestigation;
}

//_____________________________________________________________________________
/**
 * Virtual copy constructor.
 */
Object* InvestigationCMC::
copy() const
{
	InvestigationCMC *object = new InvestigationCMC(*this);
	return(object);
}
//_____________________________________________________________________________
/**
 * Virtual copy constructor from DOMElement.
 */
Object* InvestigationCMC::
copy(DOMElement *aElement) const
{
	InvestigationCMC *object = new InvestigationCMC(aElement);
	*object = *this;
	object->updateFromXMLNode();
	return(object);
}

//_____________________________________________________________________________
/**
 * Set all member variables to their null or default values.
 */
void InvestigationCMC::
setNull()
{
	setupProperties();

	_desiredKinematicsFileName = "";
	_taskSetFileName = "";
	_constraintsFileName = "";
	_yFileName = "";
	_targetDT = 0.010;
	_convergenceCriterion = 1.0e-6;
	_useFastTarget = true;
	_printLevel = 0;
}
//_____________________________________________________________________________
/**
 * Connect properties to local pointers.
 */
void InvestigationCMC::setupProperties()
{
	_desiredKinematicsFileNameProp.setName("desired_kinematics_file_name");
	_propertySet.append( &_desiredKinematicsFileNameProp );

	_taskSetFileNameProp.setName("task_set_file_name");
	_propertySet.append( &_taskSetFileNameProp );

	_constraintsFileNameProp.setName("constraints_file_name");
	_propertySet.append( &_constraintsFileNameProp );

	_qFileNameProp.setName("coordinates_file_name");
	_propertySet.append( &_qFileNameProp );

	_yFileNameProp.setName("initial_states_file_name");
	_propertySet.append( &_yFileNameProp );

	_targetDTProp.setName("cmc_time_window");
	_propertySet.append( &_targetDTProp );

	_convergenceCriterionProp.setName("optimizer_convergence_criterion");
	_propertySet.append( &_convergenceCriterionProp );

	_useFastTargetProp.setName("use_fast_optimization_target");
	_propertySet.append( &_useFastTargetProp );

	_printLevelProp.setName("optimizer_print_level");
	_propertySet.append( &_printLevelProp );

}


//=============================================================================
// OPERATORS
//=============================================================================
//_____________________________________________________________________________
/**
 * Assignment operator.
 *
 * @return Reference to this object.
 */
InvestigationCMC& InvestigationCMC::
operator=(const InvestigationCMC &aInvestigation)
{
	// BASE CLASS
	Investigation::operator=(aInvestigation);

	// MEMEBER VARIABLES
	_desiredKinematicsFileName = aInvestigation._desiredKinematicsFileName;
	_taskSetFileName = aInvestigation._taskSetFileName;
	_constraintsFileName = aInvestigation._constraintsFileName;
	_targetDT = aInvestigation._targetDT;
	_convergenceCriterion = aInvestigation._convergenceCriterion;
	_useFastTarget = aInvestigation._useFastTarget;
	_printLevel = aInvestigation._printLevel;

	return(*this);
}

//=============================================================================
// GET AND SET
//=============================================================================


//=============================================================================
// RUN
//=============================================================================
//_____________________________________________________________________________
/**
 * Run the investigation.
 */
void InvestigationCMC::run()
{
	cout<<"Running investigation "<<getName()<<".\n";

	// CHECK FOR A MODEL
	if(_model==NULL) {
		string msg = "ERROR- A model has not been set.";
		cout<<endl<<msg<<endl;
		throw(Exception(msg,__FILE__,__LINE__));
	}

	// SET OUTPUT PRECISION
	IO::SetPrecision(_outputPrecision);

	// ASSIGN NUMBERS OF THINGS
	int i;
	int nx = _model->getNX();
	int ny = _model->getNY();
	int nq = _model->getNQ();
	int nu = _model->getNU();
	int na = _model->getNA();
	int nb = _model->getNB();


	// ---- INPUT ----
	// Desired kinematics
	if(_desiredKinematicsFileName=="") {
		cout<<"ERROR- a desired kinematics file was not specified.\n\n";
		return;
	}
	Storage desiredKinStore(_desiredKinematicsFileName.c_str());
	//_model->convertDegreesToRadians(&desiredKinStore);
	//_model->convertAnglesToQuaternions(&desiredKinStore);
	GCVSplineSet desiredKinSet(5,&desiredKinStore);

	// Task set
	if(_taskSetFileName=="") {
		cout<<"ERROR- a task set was not specified\n\n";
		return;
	}
	rdCMC_TaskSet taskSet(_taskSetFileName.c_str());
	cout<<"\n\n taskSet size = "<<taskSet.getSize()<<endl<<endl;
	taskSet.setModel(_model);
	taskSet.setParametersBasedOnName();
	taskSet.setFunctions(desiredKinSet);
	// Control constraints file
	ControlSet *controlConstraints = NULL;
	if(_constraintsFileName!="") {
		controlConstraints = new ControlSet(_constraintsFileName);
	}

	// Coordinates file
	Storage *qStore = NULL;
	GCVSplineSet *qSet = NULL;
	if(_qFileName=="") {
		cout<<"ERROR- A file containing the trajectory of the generalized coordinates was not\n";
		cout<<"specified. In this implementation of the cmc algorithm, the user must specify a set of\n";
		cout<<"generalized coordates in a motion (.mot) or storage (.sto) file.\n";
		return;
	} else {
		qStore = new Storage(_qFileName.c_str());
		_model->convertDegreesToRadians(qStore);
		_model->convertAnglesToQuaternions(qStore);
		qSet = new GCVSplineSet(5,qStore);
	}

	// Initial states file
	Storage *yiStore = NULL;
	if(_yFileName!="") {
		yiStore = new Storage(_yFileName.c_str());
	}


	// ---- INITIAL AND FINAL TIME ----
	// Initial Time
	int index = desiredKinStore.findIndex(_ti);
	if(index<0) {
		_ti = desiredKinStore.getFirstTime();
		cout<<"\nThe initial time set for the cmc run precedes the first time\n";
		cout<<"in the desired kinematics file.  Setting the initial time to the first\n";
		cout<<"in the desired kinematics file (ti = "<<_ti<<").\n\n";
	}
	// Final time
	double tf = desiredKinStore.getLastTime();
	if(_tf>tf) {
		cout<<"\n\nWARN- The final time set for the cmc run is past the last time stamp\n";
		cout<<"in the desired kinematics file "<<_desiredKinematicsFileName<<".\n";
		cout<<"Resetting the final time from "<<_tf<<" to "<<tf<<".\n\n";
		_tf = tf;
	}


	// ---- INITIAL STATES ----
	Array<double> yi(0.0,ny);
	_model->getInitialStates(&yi[0]);
	bool specifyInitialStatesExplicitly = (yiStore!=NULL)&&(yiStore->getSize()>0);
	bool specifyInitialConfiguration = (qStore!=NULL)&&(qStore->getSize()>0)&(!specifyInitialStatesExplicitly);

	// Specify all initial states explicitly, no changes at all.
	if(specifyInitialStatesExplicitly) {
		yiStore->getDataAtTime(_ti,ny,&yi[0]);
		cout<<"Using the generalized coordinates specified in "<<_yFileName<<" to set the initial states.\n";

	// Specify initial configuration (q's and u's)
	} else if(specifyInitialConfiguration) {
		cout<<"Using the generalized coordinates specified in "<<_qFileName<<" to set the initial configuration.\n";
		Storage *uStore = qSet->constructStorage(1);
		Array<double> q(0.0,nq);
		Array<double> u(0.0,nu);
		qStore->getDataAtTime(_ti,nq,&q[0]);
		uStore->getDataAtTime(_ti,nu,&u[0]);
		for(i=0;i<nq;i++) yi[i] = q[i];
		for(i=0;i<nu;i++) yi[i+nq] = u[i];

	// Default 
	} else {
		cout<<"A set of initial states was not specified. Using the default initial states of the model.\n";
	}
	_model->setInitialStates(&yi[0]);


	// ---- CMC CONTROLLER ----
	// Controller
	rdCMC controller(_model,&taskSet);
	controller.setTargetDT(_targetDT);
	controller.setControlConstraints(controlConstraints);

	// Actuator force predictor
	// This requires the trajectories of the generalized coordinates
	// to be specified.
	ModelIntegrandForActuators cmcIntegrand(_model);
	cmcIntegrand.setCoordinateTrajectories(qSet);
	ControlSet *rootSet = cmcIntegrand.getControlSet();
	for(i=0;i<rootSet->getSize();i++) {
		ControlLinear *control = (ControlLinear*)rootSet->get(i);
		control->setUseSteps(true);
		control->getNodeArray().setSize(0);
	}
	VectorFunctionForActuators *predictor =
		new VectorFunctionForActuators(&cmcIntegrand);
	controller.setActuatorForcePredictor(predictor);

	// Optimization target
	rdOptimizationTarget *target = NULL;
	if(_useFastTarget) {
		target = new rdActuatorForceTargetFast(na,&controller);
	} else {
		target = new rdActuatorForceTarget(na,&controller);
	}
	controller.setOptimizationTarget(target);
	controller.setCheckTargetTime(true);

	// Optimizer settings
	rdFSQP *sqp = controller.getOptimizer();
	sqp->setPrintLevel(_printLevel);
	sqp->setConvergenceCriterion(_convergenceCriterion);


	// ---- ANALYSES ----
	Analysis *analysis;
	int size = getAnalysisSet().getSize();
	for(i=0;i<size;i++) {
		analysis = getAnalysisSet().get(i);
		if(analysis==NULL) continue;
		analysis->setModel(_model);
		_model->addAnalysis(analysis);
	}

	
	// ---- SIMULATION ----
	// Manager
	ModelIntegrand integrand(_model);
	integrand.setController(&controller);
	Manager manager(&integrand);
	manager.setSessionName(getName());
	manager.setInitialTime(_ti);
	manager.setFinalTime(_tf);

	// Integrator settings
	IntegRKF *integ = manager.getIntegrator();
	integ->setMaximumNumberOfSteps(_maxSteps);
	integ->setMaxDT(_maxDT);
	integ->setTolerance(_errorTolerance);
	integ->setFineTolerance(_fineTolerance);

	// Initial auxilliary states
	if(specifyInitialConfiguration) {
		cout<<"Computing values for the initial auxiliary states (e.g., muscle states).\n"; 
		controller.computeInitialStates(_ti,&yi[0]);
		_model->setInitialStates(&yi[0]);
	}

	// Set controls to use steps.
	ControlSet *controlSet = integrand.getControlSet();
		for(i=0;i<controlSet->getSize();i++) {
		ControlLinear *control = (ControlLinear*)controlSet->get(i);
		control->setUseSteps(true);
	}

	// ---- INTEGRATE ----
	cout<<"\n\nIntegrating from "<<_ti<<" to "<<_tf<<endl;
	manager.integrate();


	// ---- RESULTS -----
	controlSet->print("controls.xml");
	printResults(getName().c_str(),"./Results");
}


//=============================================================================
// UTILITY
//=============================================================================
//_____________________________________________________________________________
/**
 * Compute a set of generalized coordinates and speeds given .
 */
void InvestigationCMC::
computeInitialStatesFromCoordinates(
	const FunctionSet &aQSet,Array<double> &rYI)
{




}
