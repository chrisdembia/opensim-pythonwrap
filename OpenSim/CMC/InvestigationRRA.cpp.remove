// InvestigationRRA.cpp
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//=============================================================================
// INCLUDES
//=============================================================================
#include "InvestigationRRA.h"
#include <string>
#include <iostream>
#include <algorithm>
#include <cctype>
#include <fstream>
#include <OpenSim/Simulation/Model/Model.h>
#include <OpenSim/Simulation/Model/LoadModel.h>
#include <OpenSim/Simulation/Model/AnalysisSet.h>
#include <OpenSim/Simulation/Model/DerivCallbackSet.h>
#include <OpenSim/Simulation/Model/ModelIntegrandForActuators.h>
#include <OpenSim/Simulation/Control/ControlLinear.h>
#include <OpenSim/Simulation/Control/ControlConstant.h>
#include <OpenSim/Simulation/Control/ControlSet.h>
#include <OpenSim/Simulation/Manager/Manager.h>
#include <OpenSim/Tools/rdMath.h>
#include <OpenSim/Tools/Array.h>
#include <OpenSim/Tools/IO.h>
#include <OpenSim/Tools/VectorGCVSplineR1R3.h>
#include <OpenSim/Tools/GCVSplineSet.h>
#include <OpenSim/Analyses/ForceApplier.h>
#include <OpenSim/Analyses/TorqueApplier.h>
#include <OpenSim/Analyses/Kinematics.h>
#include <OpenSim/Analyses/Actuation.h>
#include <RDI/CMC/rdCMC.h>
#include <RDI/CMC/rdCMC_TaskSet.h>
#include <RDI/CMC/rdCMC_Joint.h>
#include <RDI/CMC/rdActuatorForceTarget.h>
#include <RDI/CMC/rdActuatorForceTargetFast.h>


#define PI 3.14159265359


using namespace std;
using namespace OpenSim;


//=============================================================================
// CONSTRUCTOR(S) AND DESTRUCTOR
//=============================================================================
//_____________________________________________________________________________
/**
 * Destructor.
 */
InvestigationRRA::~InvestigationRRA()
{
}
//_____________________________________________________________________________
/**
 * Default constructor.
 */
InvestigationRRA::InvestigationRRA() :
	Investigation(),
	_trackingFileName(_trackingFileNameProp.getValueStr()),
	_constraintsFileName(_constraintsFileNameProp.getValueStr()),
	_prefix(_prefixProp.getValueStr()),
	_kineticsFileName(_kineticsFileNameProp.getValueStr()),
	_computeCorrections(_computeCorrectionsProp.getValueBool()),
	_torsoxWeight(_torsoxWeightProp.getValueDbl()),
	_torsozWeight(_torsozWeightProp.getValueDbl()),
	_lumbarExtensionWeight(_lumbarExtensionWeightProp.getValueDbl()),
	_lumbarBendingWeight(_lumbarBendingWeightProp.getValueDbl()),
	_torsoxPerturbation(_torsoxPerturbationProp.getValueDbl()),
	_torsoyPerturbation(_torsoyPerturbationProp.getValueDbl()),
	_torsozPerturbation(_torsozPerturbationProp.getValueDbl()),
	_lumbarExtensionPerturbation(_lumbarExtensionPerturbationProp.getValueDbl()),
	_lumbarBendingPerturbation(_lumbarBendingPerturbationProp.getValueDbl()),
	_lumbarRotationPerturbation(_lumbarRotationPerturbationProp.getValueDbl()),
	_rightCopxPerturbation(_rightCopxPerturbationProp.getValueDbl()),
	_rightCopyPerturbation(_rightCopyPerturbationProp.getValueDbl()),
	_rightCopzPerturbation(_rightCopzPerturbationProp.getValueDbl()),
	_leftCopxPerturbation(_leftCopxPerturbationProp.getValueDbl()),
	_leftCopyPerturbation(_leftCopyPerturbationProp.getValueDbl()),
	_leftCopzPerturbation(_leftCopzPerturbationProp.getValueDbl())
{
	setType("InvestigationRRA");
	setNull();
}
//_____________________________________________________________________________
/**
 * Construct from file.
 *
 * The object is constructed from the root element of the XML document.
 * The type of object is the tag name of the XML root element.
 *
 * @param aFileName File name of the document.
 */
InvestigationRRA::InvestigationRRA(const string &aFileName) :
	Investigation(aFileName),
	_trackingFileName(_trackingFileNameProp.getValueStr()),
	_constraintsFileName(_constraintsFileNameProp.getValueStr()),
	_prefix(_prefixProp.getValueStr()),
	_kineticsFileName(_kineticsFileNameProp.getValueStr()),
	_computeCorrections(_computeCorrectionsProp.getValueBool()),
	_torsoxWeight(_torsoxWeightProp.getValueDbl()),
	_torsozWeight(_torsozWeightProp.getValueDbl()),
	_lumbarExtensionWeight(_lumbarExtensionWeightProp.getValueDbl()),
	_lumbarBendingWeight(_lumbarBendingWeightProp.getValueDbl()),
	_torsoxPerturbation(_torsoxPerturbationProp.getValueDbl()),
	_torsoyPerturbation(_torsoyPerturbationProp.getValueDbl()),
	_torsozPerturbation(_torsozPerturbationProp.getValueDbl()),
	_lumbarExtensionPerturbation(_lumbarExtensionPerturbationProp.getValueDbl()),
	_lumbarBendingPerturbation(_lumbarBendingPerturbationProp.getValueDbl()),
	_lumbarRotationPerturbation(_lumbarRotationPerturbationProp.getValueDbl()),
	_rightCopxPerturbation(_rightCopxPerturbationProp.getValueDbl()),
	_rightCopyPerturbation(_rightCopyPerturbationProp.getValueDbl()),
	_rightCopzPerturbation(_rightCopzPerturbationProp.getValueDbl()),
	_leftCopxPerturbation(_leftCopxPerturbationProp.getValueDbl()),
	_leftCopyPerturbation(_leftCopyPerturbationProp.getValueDbl()),
	_leftCopzPerturbation(_leftCopzPerturbationProp.getValueDbl())
{
	setType("InvestigationRRA");
	setNull();
	// Do the maneuver to change then restore working directory 
	// so that the parsing code behaves properly if called from a different directory.
	string saveWorkingDirectory = IO::getCwd(0, 256);
	string directoryOfSetupFile = IO::getParentDirectory(aFileName);
	IO::chDir(directoryOfSetupFile.c_str());

	updateFromXMLNode();
	if (_model) addAnalysisSetToModel();
	IO::chDir(saveWorkingDirectory.c_str());
}
//_____________________________________________________________________________
/**
 * Construct from a DOMElement.
 */
InvestigationRRA::InvestigationRRA(DOMElement *aElement) :
	Investigation(aElement),
	_trackingFileName(_trackingFileNameProp.getValueStr()),
	_constraintsFileName(_constraintsFileNameProp.getValueStr()),
	_prefix(_prefixProp.getValueStr()),
	_kineticsFileName(_kineticsFileNameProp.getValueStr()),
	_computeCorrections(_computeCorrectionsProp.getValueBool()),
	_torsoxWeight(_torsoxWeightProp.getValueDbl()),
	_torsozWeight(_torsozWeightProp.getValueDbl()),
	_lumbarExtensionWeight(_lumbarExtensionWeightProp.getValueDbl()),
	_lumbarBendingWeight(_lumbarBendingWeightProp.getValueDbl()),
	_torsoxPerturbation(_torsoxPerturbationProp.getValueDbl()),
	_torsoyPerturbation(_torsoyPerturbationProp.getValueDbl()),
	_torsozPerturbation(_torsozPerturbationProp.getValueDbl()),
	_lumbarExtensionPerturbation(_lumbarExtensionPerturbationProp.getValueDbl()),
	_lumbarBendingPerturbation(_lumbarBendingPerturbationProp.getValueDbl()),
	_lumbarRotationPerturbation(_lumbarRotationPerturbationProp.getValueDbl()),
	_rightCopxPerturbation(_rightCopxPerturbationProp.getValueDbl()),
	_rightCopyPerturbation(_rightCopyPerturbationProp.getValueDbl()),
	_rightCopzPerturbation(_rightCopzPerturbationProp.getValueDbl()),
	_leftCopxPerturbation(_leftCopxPerturbationProp.getValueDbl()),
	_leftCopyPerturbation(_leftCopyPerturbationProp.getValueDbl()),
	_leftCopzPerturbation(_leftCopzPerturbationProp.getValueDbl())
{
	setType("InvestigationRRA");
	setNull();
	updateFromXMLNode();
}
//_____________________________________________________________________________
/**
 * Copy constructor.
 *
 * Copy constructors for all Investigation's only copy the non-XML variable
 * members of the object; that is, the object's DOMnode and XMLDocument
 * are not copied but set to NULL.  The reason for this is that for the
 * object and all its derived classes to establish the correct connection
 * to the XML document nodes, the the object would need to reconstruct based
 * on the XML document not the values of the object's member variables.
 *
 * There are three proper ways to generate an XML document for an Investigation:
 *
 * 1) Construction based on XML file (@see Investigation(const char *aFileName)).
 * In this case, the XML document is created by parsing the XML file.
 *
 * 2) Construction by Investigation(const XMLDocument *aDocument).
 * This constructor explictly requests construction based on an
 * XML document.  In this way the proper connection between an object's node
 * and the corresponding node within the XML document is established.
 * This constructor is a copy constructor of sorts because all essential
 * Investigation member variables should be held within the XML document.
 * The advantage of this style of construction is that nodes
 * within the XML document, such as comments that may not have any
 * associated Investigation member variable, are preserved.
 *
 * 3) A call to generateDocument().
 * This method generates an XML document for the Investigation from scratch.
 * Only the essential document nodes are created (that is, nodes that
 * correspond directly to member variables.).
 *
 * @param aInvestigation Object to be copied.
 * @see Investigation(const XMLDocument *aDocument)
 * @see Investigation(const char *aFileName)
 * @see generateDocument()
 */
InvestigationRRA::
InvestigationRRA(const InvestigationRRA &aInvestigation) :
	Investigation(aInvestigation),
	_trackingFileName(_trackingFileNameProp.getValueStr()),
	_constraintsFileName(_constraintsFileNameProp.getValueStr()),
	_prefix(_prefixProp.getValueStr()),
	_kineticsFileName(_kineticsFileNameProp.getValueStr()),
	_computeCorrections(_computeCorrectionsProp.getValueBool()),
	_torsoxWeight(_torsoxWeightProp.getValueDbl()),
	_torsozWeight(_torsozWeightProp.getValueDbl()),
	_lumbarExtensionWeight(_lumbarExtensionWeightProp.getValueDbl()),
	_lumbarBendingWeight(_lumbarBendingWeightProp.getValueDbl()),
	_torsoxPerturbation(_torsoxPerturbationProp.getValueDbl()),
	_torsoyPerturbation(_torsoyPerturbationProp.getValueDbl()),
	_torsozPerturbation(_torsozPerturbationProp.getValueDbl()),
	_lumbarExtensionPerturbation(_lumbarExtensionPerturbationProp.getValueDbl()),
	_lumbarBendingPerturbation(_lumbarBendingPerturbationProp.getValueDbl()),
	_lumbarRotationPerturbation(_lumbarRotationPerturbationProp.getValueDbl()),
	_rightCopxPerturbation(_rightCopxPerturbationProp.getValueDbl()),
	_rightCopyPerturbation(_rightCopyPerturbationProp.getValueDbl()),
	_rightCopzPerturbation(_rightCopzPerturbationProp.getValueDbl()),
	_leftCopxPerturbation(_leftCopxPerturbationProp.getValueDbl()),
	_leftCopyPerturbation(_leftCopyPerturbationProp.getValueDbl()),
	_leftCopzPerturbation(_leftCopzPerturbationProp.getValueDbl())
{
	setType("InvestigationRRA");
	setNull();
	*this = aInvestigation;
}

//_____________________________________________________________________________
/**
 * Virtual copy constructor.
 */
Object* InvestigationRRA::
copy() const
{
	InvestigationRRA *object = new InvestigationRRA(*this);
	return(object);
}
//_____________________________________________________________________________
/**
 * Virtual copy constructor from DOMElement.
 */
Object* InvestigationRRA::
copy(DOMElement *aElement) const
{
	InvestigationRRA *object = new InvestigationRRA(aElement);
	*object = *this;
	object->updateFromXMLNode();
	return(object);
}

//_____________________________________________________________________________
/**
 * Set all member variables to their null or default values.
 */
void InvestigationRRA::
setNull()
{
	setupProperties();

	_trackingFileName = "";
	_constraintsFileName = "";
	_prefix = "";
	_kineticsFileName = "";
	_computeCorrections = true;
	_torsoxWeight = 0.0;
	_torsozWeight = 0.0;
	_lumbarExtensionWeight = 0.0;
	_lumbarBendingWeight = 0.0;
	_torsoxPerturbation = 0.0;
	_torsoyPerturbation = 0.0;
	_torsozPerturbation = 0.0;
	_lumbarExtensionPerturbation = 0.0;
	_lumbarBendingPerturbation = 0.0;
	_lumbarRotationPerturbation = 0.0;
	_rightCopxPerturbation = 0.0;
	_rightCopyPerturbation = 0.0;
	_rightCopzPerturbation = 0.0;
	_leftCopxPerturbation = 0.0;
	_leftCopyPerturbation = 0.0;
	_leftCopzPerturbation = 0.0;
}
//_____________________________________________________________________________
/**
 * Connect properties to local pointers.
 */
void InvestigationRRA::setupProperties()
{
	string comment;

	comment = "Name of the tracking file to load.";
	_trackingFileNameProp.setComment(comment);
	_trackingFileNameProp.setName("tracking_file_name_prop");
	_propertySet.append( &_trackingFileNameProp );

	comment = "Name of the file containing constraints on the controls.";
	_constraintsFileNameProp.setComment(comment);
	_constraintsFileNameProp.setName("constraints_file_name");
	_propertySet.append( &_constraintsFileNameProp );

	comment = "Name of the prefix for this subject's motion and result files.";
	_prefixProp.setComment(comment);
	_prefixProp.setName("prefix_prop");
	_propertySet.append( &_prefixProp );

	comment = "Name of the kinetics file containing ground reaction data.";
	_kineticsFileNameProp.setComment(comment);
	_kineticsFileNameProp.setName("kinetics_file_name_prop");
	_propertySet.append( &_kineticsFileNameProp );

	comment = "Whether or not to compute corrections in this pass of RRA.";
	_computeCorrectionsProp.setComment(comment);
	_computeCorrectionsProp.setName("compute_corrections_prop");
	_propertySet.append( &_computeCorrectionsProp );

	comment = "Amount by which to weight torso x coordinate correction.";
	_torsoxWeightProp.setComment(comment);
	_torsoxWeightProp.setName("torso_x_weight_prop");
	_propertySet.append( &_torsoxWeightProp );

	comment = "Amount by which to weight torso z coordinate correction.";
	_torsozWeightProp.setComment(comment);
	_torsozWeightProp.setName("torso_z_weight_prop");
	_propertySet.append( &_torsozWeightProp );

	comment = "Amount by which to weight lumbar extension correction.";
	_lumbarExtensionWeightProp.setComment(comment);
	_lumbarExtensionWeightProp.setName("lumbar_extension_weight_prop");
	_propertySet.append( &_lumbarExtensionWeightProp );

	comment = "Amount by which to weight lumbar bending correction.";
	_lumbarBendingWeightProp.setComment(comment);
	_lumbarBendingWeightProp.setName("lumbar_bending_weight_prop");
	_propertySet.append( &_lumbarBendingWeightProp );

	comment = "Extra user-specified perturbation for torso x.";
	_torsoxPerturbationProp.setComment(comment);
	_torsoxPerturbationProp.setName("torso_x_perturbation_prop");
	_propertySet.append( &_torsoxPerturbationProp );

	comment = "Extra user-specified perturbation for torso y.";
	_torsoyPerturbationProp.setComment(comment);
	_torsoyPerturbationProp.setName("torso_y_perturbation_prop");
	_propertySet.append( &_torsoyPerturbationProp );

	comment = "Extra user-specified perturbation for torso z.";
	_torsozPerturbationProp.setComment(comment);
	_torsozPerturbationProp.setName("torso_z_perturbation_prop");
	_propertySet.append( &_torsozPerturbationProp );

	comment = "Extra user-specified perturbation for lumbar extension.";
	_lumbarExtensionPerturbationProp.setComment(comment);
	_lumbarExtensionPerturbationProp.setName("lumbar_extension_perturbation_prop");
	_propertySet.append( &_lumbarExtensionPerturbationProp );
	
	comment = "Extra user-specified perturbation for lumbar bending.";
	_lumbarBendingPerturbationProp.setComment(comment);
	_lumbarBendingPerturbationProp.setName("lumbar_bending_perturbation_prop");
	_propertySet.append( &_lumbarBendingPerturbationProp );
	
	comment = "Extra user-specified perturbation for lumbar rotation.";
	_lumbarRotationPerturbationProp.setComment(comment);
	_lumbarRotationPerturbationProp.setName("lumbar_rotation_perturbation_prop");
	_propertySet.append( &_lumbarRotationPerturbationProp );

	comment = "Extra user-specified perturbation for right foot COP x.";
	_rightCopxPerturbationProp.setComment(comment);
	_rightCopxPerturbationProp.setName("right_cop_x_perturbation_prop");
	_propertySet.append( &_rightCopxPerturbationProp );
	
	comment = "Extra user-specified perturbation for right foot COP y.";
	_rightCopyPerturbationProp.setComment(comment);
	_rightCopyPerturbationProp.setName("right_cop_y_perturbation_prop");
	_propertySet.append( &_rightCopyPerturbationProp );

	comment = "Extra user-specified perturbation for right foot COP z.";
	_rightCopzPerturbationProp.setComment(comment);
	_rightCopzPerturbationProp.setName("right_cop_z_perturbation_prop");
	_propertySet.append( &_rightCopzPerturbationProp );

	comment = "Extra user-specified perturbation for left foot COP x.";
	_leftCopxPerturbationProp.setComment(comment);
	_leftCopxPerturbationProp.setName("left_cop_x_perturbation_prop");
	_propertySet.append( &_leftCopxPerturbationProp );
	
	comment = "Extra user-specified perturbation for left foot COP y.";
	_leftCopyPerturbationProp.setComment(comment);
	_leftCopyPerturbationProp.setName("left_cop_y_perturbation_prop");
	_propertySet.append( &_leftCopyPerturbationProp );

	comment = "Extra user-specified perturbation for left foot COP z.";
	_leftCopzPerturbationProp.setComment(comment);
	_leftCopzPerturbationProp.setName("left_cop_z_perturbation_prop");
	_propertySet.append( &_leftCopzPerturbationProp );
}


//=============================================================================
// OPERATORS
//=============================================================================
//_____________________________________________________________________________
/**
 * Assignment operator.
 *
 * @return Reference to this object.
 */
InvestigationRRA& InvestigationRRA::
operator=(const InvestigationRRA &aInvestigation)
{
	// BASE CLASS
	Investigation::operator=(aInvestigation);

	// MEMBER VARIABLES
	_trackingFileName = aInvestigation._trackingFileName;
	_constraintsFileName = aInvestigation._constraintsFileName;
	_prefix = aInvestigation._prefix;
	_kineticsFileName = aInvestigation._kineticsFileName;
	_computeCorrections = aInvestigation._computeCorrections;
	_torsoxWeight = aInvestigation._torsoxWeight;
	_torsozWeight = aInvestigation._torsozWeight;
	_lumbarExtensionWeight = aInvestigation._lumbarExtensionWeight;
	_lumbarBendingWeight = aInvestigation._lumbarBendingWeight;
	_torsoxPerturbation = aInvestigation._torsoxPerturbation;
	_torsoyPerturbation = aInvestigation._torsoyPerturbation;
	_torsozPerturbation = aInvestigation._torsozPerturbation;
	_lumbarExtensionPerturbation = aInvestigation._lumbarExtensionPerturbation;
	_lumbarBendingPerturbation = aInvestigation._lumbarBendingPerturbation;
	_lumbarRotationPerturbation = aInvestigation._lumbarRotationPerturbation;
	_rightCopxPerturbation = aInvestigation._rightCopxPerturbation;
	_rightCopyPerturbation = aInvestigation._rightCopyPerturbation;
	_rightCopzPerturbation = aInvestigation._rightCopzPerturbation;
	_leftCopxPerturbation = aInvestigation._leftCopxPerturbation;
	_leftCopyPerturbation = aInvestigation._leftCopyPerturbation;
	_leftCopzPerturbation = aInvestigation._leftCopzPerturbation;

	return(*this);
}

//=============================================================================
// GET AND SET
//=============================================================================


//=============================================================================
// RUN
//=============================================================================
//_____________________________________________________________________________
/**
 * Run the investigation.
 */
void InvestigationRRA::run()
{
	cout<<"Running investigation "<<getName()<<".\n";

	// Do the maneuver to change then restore working directory 
	// so that the parsing code behaves properly if called from a different directory
	string aFileName = string(getDocument()->getFileName());
	string saveWorkingDirectory = IO::getCwd(0, 256);
	string directoryOfSetupFile = IO::getParentDirectory(aFileName);
	IO::chDir(directoryOfSetupFile.c_str());

	IO::makeDir(getResultsDir().c_str()); // make sure directory exists -- TODO: use results directory specified in xml

	// SET OUTPUT PRECISION
	IO::SetPrecision(_outputPrecision);

	
	//=======================
	// PARSE COMMAND LINE
	//=======================

	double perturb[12];
	perturb[0]  = _torsoxPerturbation;
	perturb[1]  = _torsoyPerturbation;
	perturb[2]  = _torsozPerturbation;
	perturb[3]  = _lumbarExtensionPerturbation;
	perturb[4]  = _lumbarBendingPerturbation;
	perturb[5]  = _lumbarRotationPerturbation;
	perturb[6]  = _rightCopxPerturbation;
	perturb[7]  = _rightCopyPerturbation;
	perturb[8]  = _rightCopzPerturbation;
	perturb[9]  = _leftCopxPerturbation;
	perturb[10] = _leftCopyPerturbation;
	perturb[11] = _leftCopzPerturbation;

	bool computingCorrections = _computeCorrections;
	double txweight = _torsoxWeight;
	double tzweight = _torsozWeight;
	double leweight = _lumbarExtensionWeight;
	double lbweight = _lumbarBendingWeight;

	bool changeTorso = (txweight != 0.0 || tzweight != 0.0);
	bool changeBack  = (leweight != 0.0 || lbweight != 0.0);


	//=======================
	// CONSTRUCT MODEL
	//=======================

	Model *model = getModel();
	if (model==NULL){
		throw (new Exception("Model not found or could not be loaded"));
	}
	model->setIncludePipelineActuators(false);
	model->printDetailedInfo(cout);


	//============================
	// ALTER TORSO AND BACK
	//============================

	// Load desired trajectories
	string kinematicsFileName = _prefix + ".mot";
	Storage motionStore(kinematicsFileName.c_str());

	// Perform corrections suggested by RRA if user said to do so
	Array<double> btj(0.0);
	btj.setSize(3);
	int iTorso = model->getBodyIndex("torso");
	if (changeTorso || changeBack)
	{
		string rraCorrectFileName = _prefix + "_rra.txt";
		ifstream rraCorrectFile;
		rraCorrectFile.open(rraCorrectFileName.c_str());
		// If file is valid, read and incorporate alterations
		if(!rraCorrectFile.fail())
		{
			if (changeTorso) // Incorporate torso COM alterations
			{
				double changeTx, changeTz;
				rraCorrectFile >> changeTx >> changeTz;
				model->getBodyToJointBodyLocal(iTorso,&btj[0]);
				cout << "Original torso COM is " << "("
					 << btj[0] << ", " << btj[1] << ", " << btj[2] << ").\n\n";
				btj[0] += txweight * changeTx;
				btj[2] += tzweight * changeTz;
				model->setBodyToJointBodyLocal(iTorso,&btj[0]);
				cout << "Torso center of mass has been altered by RRA.\n";
			}
			if (changeBack) // Incorporate back angle alterations
			{
				// Read correction arrays from file
				Array<double> lExtCorr(0.0);
				lExtCorr.setSize(motionStore.getSize());
				Array<double> lBendCorr(0.0);
				lBendCorr.setSize(motionStore.getSize());
				// Assumption: lExtCorr is listed as an array with
				// one number per line in the correction file, and
				// the size of the array is equal to
				// motionStore.getSize(); lBendCorr is listed right
				// after lExtCorr and also has the same format and
				// size
				for (int i = 0; i < motionStore.getSize(); i++)
				{
					rraCorrectFile >> lExtCorr[i];
				}
				for (int i = 0; i < motionStore.getSize(); i++)
				{
					rraCorrectFile >> lBendCorr[i];
				}

				// Temporarily convert to radians for corrections below
				model->convertDegreesToRadians(&motionStore);

				// Initialize data arrays
				double *lExtData = 0, *lBendData = 0;

				// Note: trajectory angles are in radians
				int lExtIndex = motionStore.getColumnIndex("lumbar_extension");
				int lBendIndex = motionStore.getColumnIndex("lumbar_bending");
				motionStore.getDataColumn(lExtIndex, lExtData);
				motionStore.getDataColumn(lBendIndex, lBendData);

				if (leweight != 0.0)
				{
					for (int i = 0; i < motionStore.getSize(); i++)
					{
						lExtCorr[i] = lExtData[i] + leweight * lExtCorr[i];
					}
					motionStore.setDataColumn(lExtIndex, lExtCorr);
				}
				if (lbweight != 0.0)
				{
					for (int i = 0; i < motionStore.getSize(); i++)
					{
						lBendCorr[i] = lBendData[i] + lbweight * lBendCorr[i];
					}
					motionStore.setDataColumn(lBendIndex, lBendCorr);
				}

				// Convert back to degrees now that corrections are done
				model->convertRadiansToDegrees(&motionStore);

				cout << "Back angles have been altered.\n";
			}
		}
		else
		{
			cout << "Unexpected end-of-file in " << rraCorrectFileName.c_str() << "\n";
		}
		rraCorrectFile.close();
	}
	else
	{
		cout << "Not applying any corrections in this pass of RRA." << "\n";
	}
    
	// Alter the center of mass of the torso if
	// user specified an alteration amount
	for(int i = 0; i < 3; i++)
	{
		if (perturb[i] != 0.0)
		{
			model->getBodyToJointBodyLocal(iTorso,&btj[0]);
			btj[i] += perturb[i];
			model->setBodyToJointBodyLocal(iTorso,&btj[0]);
		}
	}
	
	// Print out new torso center of mass coordinates if they were changed
	if (perturb[0] != 0.0 || perturb[1] != 0.0 || perturb[2] != 0.0 || changeTorso)
	{
		cout << "Changed torso COM to " << "("
			 << btj[0] << ", " << btj[1] << ", " << btj[2] << ").\n\n";
	}


	//=====================================
	// COMPUTE TRAJECTORIES FROM .MOT FILE
	//=====================================
	int nq = model->getNQ();
	Storage *trajectories;
	Storage *uCompleteStore;
	model->formCompleteStorages(motionStore,trajectories,uCompleteStore);


	//=======================
	// SET UP TRACKING
	//=======================
	// Alter back angles if user said so
	if (perturb[3] != 0.0)
	{
		int columnIndex = trajectories->getColumnIndex("lumbar_extension");
		trajectories->add(columnIndex, perturb[3]);
	}
	if (perturb[4] != 0.0)
	{
		int columnIndex = trajectories->getColumnIndex("lumbar_bending");
		trajectories->add(columnIndex, perturb[4]);
	}
	if (perturb[5] != 0.0)
	{
		int columnIndex = trajectories->getColumnIndex("lumbar_rotation");
		trajectories->add(columnIndex, perturb[5]);
	}

	// Convert to radians
	model->convertDegreesToRadians(trajectories);

	// Set initial and final times
	double ti,tf;
	ti = trajectories->getFirstTime() + 0.01;
	tf = trajectories->getLastTime() - 0.01;
	// If initial and final times are specified in the RRA setup file,
	// use those times (_ti, _tf) if they are within the valid window
	// which is the time interval [ti, tf]
	ti = max(ti, _ti);
	tf = min(tf, _tf);
	cout<<endl<<endl<<"ti="<<ti<<" tf="<<tf<<endl<<endl;

	// Write unfiltered values
	{
		GCVSplineSet qSet(5,trajectories);
		Storage *posStore = qSet.constructStorage(0);
		posStore->print((getResultsDir()+"/unfiltered_positions.sto").c_str());
		Storage *velStore = qSet.constructStorage(1);
		velStore->print((getResultsDir()+"/unfiltered_velocities.sto").c_str());
		Storage *accelStore = qSet.constructStorage(2);
		accelStore->print((getResultsDir()+"/unfiltered_accelerations.sto").c_str());
	}

	// Filter
	trajectories->pad(60);
	trajectories->print((getResultsDir()+"/pad.sto").c_str());
	int order = 50;
	double cutoff = 6.0;
	trajectories->lowpassFIR(order,cutoff);

	// Construct splines for trajectories
	GCVSplineSet qSet(5,trajectories);
	Storage *trajectoriesVel = qSet.constructStorage(1);
	GCVSplineSet uSet(5,trajectoriesVel);

	// Convert to quaternions
	model->convertAnglesToQuaternions(trajectories);

	// Construct task set
	rdCMC_TaskSet taskSet(_trackingFileName.c_str());
	taskSet.setModel(model);
	taskSet.setParametersBasedOnName();
	taskSet.setFunctions(qSet);
	cout<<"\n\nTracking "<<taskSet.getSize()<<" trajectories->\n\n";

	// Check trajectories
	trajectories->print((getResultsDir() + "/filtered.sto").c_str());
	Storage *checkPositions = qSet.constructStorage(0);
	checkPositions->print((getResultsDir() + "/checkPositions.sto").c_str());
	delete checkPositions;
	Storage *checkVelocities = qSet.constructStorage(1);
	checkVelocities->print((getResultsDir() + "/checkVelocities.sto").c_str());
	delete checkVelocities;
	Storage *checkAccelerations = qSet.constructStorage(2);
	checkAccelerations->print((getResultsDir() + "/checkAccelerations.sto").c_str());
	delete checkAccelerations;


	//=======================
	// INITIAL STATES
	//=======================
	int nu = model->getNU();
	int ny = model->getNY();
	Array<double> yi(0.0,ny);
	model->getInitialStates(&yi[0]);
	Array<double> q(0.0,nq),u(0.0,nu);
	qSet.evaluate(q,0,ti);
	uSet.evaluate(u,0,ti);
	for(int i=0;i<nq;i++) yi[i] = q[i];
	for(int i=0;i<nu;i++) yi[i+nq] = u[i];
	model->setInitialStates(&yi[0]);

	// Bodies
	cout<<endl<<endl<<"Bodies:"<<endl;
	int nb = model->getNB();
	for(int i=0;i<nb;i++) {
		cout<<"body["<<i<<"]= "<<model->getBodyName(i)<<endl;
	}
	cout<<endl;


	//=======================
	// GROUND REACTION FORCES
	//=======================
	// Read in ground reaction data from kinetics file.
	Storage kineticsStore(_kineticsFileName.c_str());
	int copSize = kineticsStore.getSize();

	// Read the indices of all the ground reaction data columns.
	// We assume that the right foot's data appears before the left foot's data
	// when reading the kinetics file's columns from left to right.
	int rightForceX  = kineticsStore.getColumnIndex("ground_force_vx");
	int rightForceY  = kineticsStore.getColumnIndex("ground_force_vy");
	int rightForceZ  = kineticsStore.getColumnIndex("ground_force_vz");
	int leftForceX   = kineticsStore.getColumnIndex("ground_force_vx", rightForceX + 2);
	int leftForceY   = kineticsStore.getColumnIndex("ground_force_vy", rightForceY + 2);
	int leftForceZ   = kineticsStore.getColumnIndex("ground_force_vz", rightForceZ + 2);
	int rightCopX    = kineticsStore.getColumnIndex("ground_force_px");
	int rightCopY    = kineticsStore.getColumnIndex("ground_force_py");
	int rightCopZ    = kineticsStore.getColumnIndex("ground_force_pz");
	int leftCopX     = kineticsStore.getColumnIndex("ground_force_px", rightCopX + 2);
	int leftCopY     = kineticsStore.getColumnIndex("ground_force_py", rightCopY + 2);
	int leftCopZ     = kineticsStore.getColumnIndex("ground_force_pz", rightCopZ + 2);
	int rightTorqueX = kineticsStore.getColumnIndex("ground_torque_x");
	int rightTorqueY = kineticsStore.getColumnIndex("ground_torque_y");
	int rightTorqueZ = kineticsStore.getColumnIndex("ground_torque_z");
	int leftTorqueX  = kineticsStore.getColumnIndex("ground_torque_x", rightTorqueX + 2);
	int leftTorqueY  = kineticsStore.getColumnIndex("ground_torque_y", rightTorqueY + 2);
	int leftTorqueZ  = kineticsStore.getColumnIndex("ground_torque_z", rightTorqueZ + 2);

	// Get body indices.
	int rightFoot = model->getBodyIndex("calcn_r");
	int  leftFoot = model->getBodyIndex("calcn_l");
	int    ground = model->getGroundID();

	// Alter the right foot COP location if user said so.
	if (perturb[6] != 0.0) {kineticsStore.add(rightCopX, perturb[6]);}
	if (perturb[7] != 0.0) {kineticsStore.add(rightCopY, perturb[7]);}
	if (perturb[8] != 0.0) {kineticsStore.add(rightCopZ, perturb[8]);}

	// Alter the left foot COP location if user said so.
	if (perturb[ 9] != 0.0) {kineticsStore.add(leftCopX, perturb[ 9]);}
	if (perturb[10] != 0.0) {kineticsStore.add(leftCopY, perturb[10]);}
	if (perturb[11] != 0.0) {kineticsStore.add(leftCopZ, perturb[11]);}

	// CREATE FORCE AND TORQUE APPLIERS

	ForceApplier *rightForceApp, *leftForceApp;
	TorqueApplier *rightTorqueApp, *leftTorqueApp;

	rightForceApp = new ForceApplier(model, ground, rightFoot, &kineticsStore,
	                                 rightForceX, rightForceY, rightForceZ,
	                                 rightCopX, rightCopY, rightCopZ,
	                                 trajectories, trajectoriesVel);
	leftForceApp  = new ForceApplier(model, ground, leftFoot, &kineticsStore,
	                                 leftForceX, leftForceY, leftForceZ,
	                                 leftCopX, leftCopY, leftCopZ,
	                                 trajectories, trajectoriesVel);
	rightTorqueApp = new TorqueApplier(model, ground, rightFoot, &kineticsStore,
	                                   rightTorqueX, rightTorqueY, rightTorqueZ);
	leftTorqueApp  = new TorqueApplier(model, ground, leftFoot, &kineticsStore,
	                                   leftTorqueX, leftTorqueY, leftTorqueZ);

	// Add force and torque appliers as derivative callbacks for model.
	// Set input in global frame is true by default--we're just being
	// paranoid here by setting it to true for sure.
	rightForceApp->setInputForcesInGlobalFrame(true);
	leftForceApp->setInputForcesInGlobalFrame(true);
	rightTorqueApp->setInputTorquesInGlobalFrame(true);
	leftTorqueApp->setInputTorquesInGlobalFrame(true);
	model->addDerivCallback(rightForceApp);
	model->addDerivCallback(leftForceApp);
	model->addDerivCallback(rightTorqueApp);
	model->addDerivCallback(leftTorqueApp);

	//=======================
	// ANALYSES
	//=======================
	Actuation *actuation=0;
	Kinematics *kin=0;
	for (int i=0; i<model->getAnalysisSet()->getSize(); i++) {
		if (!actuation && model->getAnalysisSet()->get(i)->getType() == "Actuation") {
			actuation = dynamic_cast<Actuation*>(model->getAnalysisSet()->get(i));
		}
		if (!kin && model->getAnalysisSet()->get(i)->getType() == "Kinematics") {
			kin = dynamic_cast<Kinematics*>(model->getAnalysisSet()->get(i));
			kin->getPositionStorage()->setWriteSIMMHeader(true);
		}
	}
	int stepInterval = 1;
	if (!actuation) {
		std::cout << "No Actuation analysis found in analysis set -- adding one" << std::endl;
		actuation = new Actuation(model);
	actuation->setStepInterval(stepInterval);
	model->addAnalysis(actuation);
	}
	if (!kin) {
		std::cout << "No Kinematics analysis found in analysis set -- adding one" << std::endl;
		kin = new Kinematics(model);
	kin->setStepInterval(stepInterval);
	kin->getPositionStorage()->setWriteSIMMHeader(true);
	model->addAnalysis(kin);
	}

	// TRACKING CONTROLLER----
	// CONTROLLER
	rdCMC controller(model,&taskSet);
	controller.setTargetDT(0.010);

	// CONSTRAINTS ON THE CONTROLS
	if(_constraintsFileName!="") {
		cout << "Reading constraints from '" << _constraintsFileName << "'" << endl;
		ControlSet *controlConstraints = new ControlSet(_constraintsFileName);
		controller.setControlConstraints(controlConstraints);
	}

	// OPTIMIZATION TARGET
	int na = model->getNA();
	//rdActuatorForceTargetFast target(na,&controller);
	rdActuatorForceTarget target(na,&controller);
	controller.setOptimizationTarget(&target);
	controller.setCheckTargetTime(true);
	target.setDX(1.0e-4);

	// ACTUATOR FORCE PREDICTOR
	// Integrand
	//ModelIntegrand cmcIntegrand(&model);
	ModelIntegrandForActuators cmcIntegrand(model);
	cmcIntegrand.setCoordinateTrajectories(&qSet);
	cmcIntegrand.setSpeedTrajectories(&uSet);
	ControlSet *rootSet = cmcIntegrand.getControlSet();
	for(int i=0;i<rootSet->getSize();i++) {
		ControlLinear *control = (ControlLinear*)rootSet->get(i);
		//control->setUseSteps(true);
		control->setUseSteps(false);
		control->getNodeArray().setSize(0);
		control->setDefaultParameterMin(-1.0);
		control->setDefaultParameterMax(1.0);
	}
	VectorFunctionForActuators *predictor =
		new VectorFunctionForActuators(&cmcIntegrand);
	controller.setActuatorForcePredictor(predictor);


	// OPTIMIZATION SETTINGS
	rdFSQP *sqp = controller.getOptimizer();
	sqp->setPrintLevel(0);
	sqp->setConvergenceCriterion(1.0e-6);


	// SIMULATION SETUP----
	// Manager
	ModelIntegrand integrand(model);
	integrand.setController(&controller);
	Manager manager(&integrand);
	manager.setSessionName("RRA");
	manager.setInitialTime(ti);
	manager.setFinalTime(tf);

	// CREATE CONTROL SET
	ControlSet *controlSet = integrand.getControlSet();
	int size = controlSet->getSize();
	for(int i=0;i<size;i++) {
		ControlLinear *control = (ControlLinear*)controlSet->get(i);
		control->setUseSteps(false);
		control->setControlValueMin(0.0,-1.0);
		control->setControlValueMax(0.0,1.0);
		control->setDefaultParameterMin(-1.0);
		control->setDefaultParameterMax(1.0);

		/* Commented out PD follower.  Clay Wed 20060920
		// Turn on PD follower filter for the residuals, which are
		// governed by the first six controls; only in RRA pass 2.
		if ((0<=i) && (i<=5) && !computingCorrections) {
			control->setFilterOn(true);
			control->setKp(100);
			control->setKv(20);
		}
		*/
	}

	// Integrator settings
	int maxSteps = 20000;
	IntegRKF *integ = manager.getIntegrator();
	integ->setMaximumNumberOfSteps(maxSteps);
	integ->setUseConstantDT(false);
	//integ->setDT(0.00087);
	integ->setMaxDT(5.0e-4);
	integ->setTolerance(1.0e-5);
	integ->setFineTolerance(5.0e-7);


	// INTEGRATE
	cout<<"\n\nIntegrating from "<<ti<<" to "<<tf<<endl;
	manager.integrate();


	// RESULTS
	// Prefix
	double dt = 0.001;
	string stoFileName, newprefix;
	if (changeTorso || changeBack) // some correction is being used
	{
		newprefix = _prefix + "_rra";
	}
	else
	{
		newprefix = _prefix;
	}

	// Controls
	string controlSetName = newprefix + "_controls.xml";
	controlSet->print(controlSetName);

	// Storage
	Storage *yStore = integrand.getStateStorage();
	Storage *ypStore = integrand.getPseudoStateStorage();
	Storage *xStore = integrand.getControlStorage();
	stoFileName= getResultsDir() + "/" + newprefix + "_controls.sto";
	xStore->print(stoFileName.c_str(),dt);
	stoFileName= getResultsDir() + "/" + newprefix + "_states.sto";
	yStore->print(stoFileName.c_str(),dt);

	printResults(newprefix.c_str(),getResultsDir().c_str(),dt); // Prints results of analysis set

	stoFileName= getResultsDir() + "/" + newprefix + "_pErr.sto";
	controller.getPositionErrorStorage()->print(stoFileName.c_str());
	stoFileName= getResultsDir() + "/" + newprefix + "_stressTermWeight.sto";
	controller.getStressTermWeightStorage()->print(stoFileName.c_str());

	// Print ground reaction force and torque application results
	rightForceApp->printResults(newprefix.c_str(), getResultsDir().c_str(), dt);
	rightTorqueApp->printResults(newprefix.c_str(), getResultsDir().c_str(), dt);
	leftForceApp->printResults(newprefix.c_str(), getResultsDir().c_str(), dt);
	leftTorqueApp->printResults(newprefix.c_str(), getResultsDir().c_str(), dt);


	// COMPUTE NEEDED DC OFFSETS
	Storage *forceStore = actuation->getForceStorage();
	int ncols = forceStore->getSmallestNumberOfStates();
	int iFX,iFY,iFZ,iMX,iMY,iMZ;
	//iFX = forceStore->getColumnIndex("FX");
	//iFY = forceStore->getColumnIndex("FY");
	//iFZ = forceStore->getColumnIndex("FZ");
	//iMX = forceStore->getColumnIndex("MX");
	//iMY = forceStore->getColumnIndex("MY");
	//iMZ = forceStore->getColumnIndex("MZ");
	//iFX = forceStore->getColumnIndex("state_0");
	//iFY = forceStore->getColumnIndex("state_1");
	//iFZ = forceStore->getColumnIndex("state_2");
	//iMX = forceStore->getColumnIndex("state_3");
	//iMY = forceStore->getColumnIndex("state_4");
	//iMZ = forceStore->getColumnIndex("state_5");

	// TO DO - change these back to FX, FY, FZ... which is commented out above
	// Must have Actuation_force.sto and residuals.sto files properly printing
	// out column names as FX, FY, etc., instead of state_0, etc., before making
	// the change here
	iFX = 0;
	iFY = 1;
	iFZ = 2;
	iMX = 3;
	iMY = 4;
	iMZ = 5;

	Storage residuals(6, "Residuals");
	string colLabels = "time\tFX\tFY\tFZ\tMX\tMY\tMZ";
	residuals.setColumnLabels(colLabels.c_str());
	double tempTime;
	// Temporary array to store each row of residual data
	double resid[6];
	for (int i = 0; i < forceStore->getSize(); i++)
	{
		// t := ith time value
		forceStore->getTime(i, tempTime);
		// Read the values of FX, FY, FZ, MX, MY, and MZ
		// in the ith row of the forceStore object
		forceStore->getData(i, iFX, resid[0]);
		forceStore->getData(i, iFY, resid[1]);
		forceStore->getData(i, iFZ, resid[2]);
		forceStore->getData(i, iMX, resid[3]);
		forceStore->getData(i, iMY, resid[4]);
		forceStore->getData(i, iMZ, resid[5]);
		// Add the row (tempTime,resid[0],resid[1],...,resid[5]) to
		// the residual storage object.  Note that FX=resid[0],
		// FY=resid[1], FZ=resid[2], MX=resid[3], MY=resid[4],
		// and MZ=resid[5].
		residuals.append(tempTime, 6, resid);
	}

	// Print residuals out to a file
	stoFileName = getResultsDir() + "/" + newprefix + "_residuals.sto";
	residuals.print(stoFileName.c_str(),dt);

	// Now actually compute the DC offsets like we promised
	Array<double> ave(0.0);
	ave.setSize(ncols);
	forceStore->computeAverage(ncols,&ave[0]);
	cout<<"\n\nAverage residuals:\n";
	cout<<"FX="<<ave[iFX]<<" FY="<<ave[iFY]<<" FZ="<<ave[iFZ]<<endl;
	cout<<"MX="<<ave[iMX]<<" MY="<<ave[iMY]<<" MZ="<<ave[iMZ]<<endl<<endl<<endl;

	// Write the average residuals (DC offsets) out to a file
	ofstream residualFile;
	stoFileName = getResultsDir() + "/" + newprefix + "_avgResiduals.txt";
	residualFile.open (stoFileName.c_str());
	residualFile << "Average Residuals:\n\n";
	residualFile << "FX average = " << ave[iFX] << "\n";
	residualFile << "FY average = " << ave[iFY] << "\n";
	residualFile << "FZ average = " << ave[iFZ] << "\n";
	residualFile << "MX average = " << ave[iMX] << "\n";
	residualFile << "MY average = " << ave[iMY] << "\n";
	residualFile << "MZ average = " << ave[iMZ] << "\n";
	residualFile.close();

	// End program if not computing corrections.  Otherwise, proceed.
	if (!computingCorrections)
	{
		// Print torso center of mass to space-delimited text file for CMC
		string rraTorsoComFileName = "rra_newTorsoBTJ.txt";
		ofstream rraTorsoComFile;
		rraTorsoComFile.open(rraTorsoComFileName.c_str());
		model->getBodyToJointBodyLocal(iTorso,&btj[0]);
		rraTorsoComFile << btj[0] << " " << btj[1] << " " << btj[2] << "\n";
		rraTorsoComFile.close();

		// Write out final motion file for CMC
		string finalMotFileName = _prefix + "_rra.mot";
		motionStore.setWriteSIMMHeader(true);
		motionStore.print(finalMotFileName.c_str());
		cout << "Wrote final .mot file: " << finalMotFileName.c_str() << endl;
		cout << "Not computing corrections, so RRA is done." << endl;
		IO::chDir(saveWorkingDirectory.c_str());
		return;
	}

	//=======================
	// COMPUTE CORRECTIONS
	//=======================

	// Compute torso weight
	double torsoMass = model->getMass(iTorso);
	double torsoWeight = 9.81 * torsoMass;

	// Compute torso moment arm and torque
	int iPelvis = model->getBodyIndex("pelvis");
	Array<double> pelvis(0.0);
	pelvis.setSize(3);
	model->getBodyToJointBodyLocal(iTorso, &btj[0]);
	model->getBodyToJointBodyLocal(iPelvis,&pelvis[0]);
	double rx = pelvis[0] - btj[0];
	double ry = pelvis[1] - btj[1];
	double rz = pelvis[2] - btj[2];
	double torsoMomentArm = sqrt(rx*rx + ry*ry + rz*rz);
	double torsoTorque = torsoWeight * torsoMomentArm;

	// Boolean flags for whether or not each correction is within
	// a reasonable threshold amount (+/- 10 degrees for angles,
	// +/- 10 cm for distances)
	bool txOkay = true, tzOkay = true, leOkay = true, lbOkay = true;

	// COMPUTE TORSO CENTER OF MASS CORRECTION AMOUNTS

	double txOutput = 0.0, tzOutput = 0.0;
	double dTx =  ave[iMZ] / torsoWeight;
	double dTz = -ave[iMX] / torsoWeight;

	if (dTx < -0.1 || dTx > 0.1)
	{
		cout << "Torso COM x needs to be changed too much." << endl;
		cout << "Continuing without changing torso COM x." << endl;
		txOkay = false;
	}
	if (dTz < -0.1 || dTz > 0.1)
	{
		cout << "Torso COM z needs to be changed too much." << endl;
		cout << "Continuing without changing torso COM z." << endl;
		tzOkay = false;
	}


	if (txOkay) txOutput = dTx;
	if (tzOkay) tzOutput = dTz;

	// COMPUTE BACK ANGLE CORRECTION AMOUNTS

	// Convert angles from degrees to radians for computations below
	model->convertDegreesToRadians(&motionStore);

	// Compute back angle corrections
	Array<double> lExtCorr(0.0);
	lExtCorr.setSize(motionStore.getSize());
	Array<double> lBendCorr(0.0);
	lBendCorr.setSize(motionStore.getSize());
	double *lExtData = 0, *lBendData = 0;

	// Note: trajectory angles are in radians
	int lExtIndex = motionStore.getColumnIndex("lumbar_extension");
	int lBendIndex = motionStore.getColumnIndex("lumbar_bending");
	motionStore.getDataColumn(lExtIndex, lExtData);
	motionStore.getDataColumn(lBendIndex, lBendData);
	double tenDegrees = 10.0 * PI / 180.0; // 10 degrees in radians
	for (int i = 0; i < motionStore.getSize() && (leOkay || lbOkay); i++)
	{
		if (leOkay) lExtCorr[i] = -ave[iMZ] / torsoTorque / cos(lExtData[i]);
		if (lExtCorr[i] < -tenDegrees || lExtCorr[i] > tenDegrees)
		{
			cout << "Lumbar extension needs to be changed too much." << endl;
			cout << "Continuing without changing lumbar extension." << endl;
			leOkay = false;
		}
		if (lbOkay) lBendCorr[i] = -ave[iMX] / torsoTorque / cos(lBendData[i]);
		if (lBendCorr[i] < -tenDegrees || lBendCorr[i] > tenDegrees)
		{
			cout << "Lumbar bending needs to be changed too much." << endl;
			cout << "Continuing without changing lumbar bending." << endl;
			lbOkay = false;
		}
	}

	// Prepare to output all zeros for lumbar extension
	// correction if any desired change was too high
	if (!leOkay)
	{
		for (int i = 0; i < motionStore.getSize(); i++)
		{
			lExtCorr[i] = 0.0;
		}
	}
	// Prepare to output all zeros for lumbar bending
	// correction if any desired change was too high
	if (!lbOkay)
	{
		for (int i = 0; i < motionStore.getSize(); i++)
		{
			lBendCorr[i] = 0.0;
		}
	}

	// All angles are changed back to degrees
	model->convertRadiansToDegrees(&motionStore);

	// Write torso COM and back angle corrections to a file
	ofstream correctionFile;
	stoFileName = newprefix + "_rra.txt";
	correctionFile.open (stoFileName.c_str());
	// Write torso x and z change amounts to file
	correctionFile << txOutput << "\n";
	correctionFile << tzOutput << "\n";
	// Write lumbar extension change array to file
	for (int i = 0; i < motionStore.getSize(); i++)
	{
		correctionFile << lExtCorr[i] << "\n";
	}
	// Write lumbar bending change array to file
	for (int i = 0; i < motionStore.getSize(); i++)
	{
		correctionFile << lBendCorr[i] << "\n";
	}
	correctionFile.close();

	// Note: even if torso and back angles are never altered,
	// a corrections file is still written out for ease of automation

	// If data cannot be corrected, say so
	if (!txOkay && !tzOkay && !leOkay && !lbOkay)
	{
		cout << "This data cannot be corrected.\n";
	}
	IO::chDir(saveWorkingDirectory.c_str());
}

