#ifndef OPENSIM_Millard2012EquilibriumMuscle_h__
#define OPENSIM_Millard2012EquilibriumMuscle_h__

// Millard2012EquilibriumMuscle.h
/*    Author: Matthew Millard
/*
 * Permission is hereby granted, free of charge, to any person obtaining a    *
 * copy of this software and associated documentation files (the "Software"), *
 * to deal in the Software without restriction, including without limitation  *
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,   *
 * and/or sell copies of the Software, and to permit persons to whom the      *
 * Software is furnished to do so, subject to the following conditions:       *
 *                                                                            *
 * The above copyright notice and this permission notice shall be included in *
 * all copies or substantial portions of the Software.                        *
 *                                                                            *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   *
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    *
 * THE AUTHORS, CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,    *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR      *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE  *
 * USE OR OTHER DEALINGS IN THE SOFTWARE.                                     *
 * -------------------------------------------------------------------------- */


// INCLUDE
#include <OpenSim/Actuators/osimActuatorsDLL.h>

#include <simbody/internal/common.h>
#include <OpenSim/Simulation/Model/Muscle.h>
/*
The parent class, Muscle.h, provides 
    1. max_isometric_force
    2. optimal_fiber_length
    3. tendon_slack_length
    4. pennation_angle_at_optimal
    5. max_contraction_velocity
*/
#include <OpenSim/Simulation/Model/Muscle.h>

//All of the sub-models required for a muscle model:
#include <OpenSim/Actuators/MuscleFirstOrderActivationDynamicModel.h>
#include <OpenSim/Actuators/MuscleFixedWidthPennationModel.h>

#include <OpenSim/Actuators/ActiveForceLengthCurve.h>
#include <OpenSim/Actuators/ForceVelocityCurve.h>
#include <OpenSim/Actuators/ForceVelocityInverseCurve.h>
#include <OpenSim/Actuators/FiberForceLengthCurve.h>
#include <OpenSim/Actuators/FiberCompressiveForceLengthCurve.h>
#include <OpenSim/Actuators/FiberCompressiveForceCosPennationCurve.h>
#include <OpenSim/Actuators/TendonForceLengthCurve.h>


#ifdef SWIG
    #ifdef OSIMACTUATORS_API
        #undef OSIMACTUATORS_API
        #define OSIMACTUATORS_API
    #endif
#endif

namespace OpenSim {


/**
This class implements a 2 state (activation and fiber length) equilibrium muscle 
model that has additional terms in its state equations to ensure that 
the singularity conditions typical of equilibrium models 
(when \f$\mathbf{a}(t) \rightarrow 0\f$,\f$\phi \rightarrow 90^\circ\f$, and 
\f$ \mathbf{f}_L(\hat{l}_{CE}) \rightarrow 0 \f$) are prevented. 

\image html fig_Millard2012EquilibriumMuscle.png


Physically 
these modifications mean that this muscle model is always activated 
(\f$\mathbf{a}(t) > 0\f$), the fiber will stop contracting when a pennation
angle of 90 degrees is approached (\f$\phi < 90^\circ\f$), and the fiber will
also stop contracting as its length approaches a lower bound 
(\f$ \hat{l}_{CE} > lowerbound\f$), typically around half the fiber's resting 
length ( to ensure \f$ \mathbf{f}_L(\hat{l}_{CE}) > 0 \f$). As is typical 
of an equilibrium model, the force generated by the tendon and the force 
generated by the fiber are assumed to be equal and opposite:

\f[
 f_{ISO}\Big(\mathbf{a}(t) \mathbf{f}_L(\hat{l}_{CE}) \mathbf{f}_V(\hat{v}_{CE}) 
+ \mathbf{f}_{PE}(\hat{l}_{CE}) - \mathbf{f}_K(\hat{l}_{CE})\Big) \cos \phi
-  f_{ISO} \Big(\mathbf{f}_{c\phi}(\cos \phi) 
+ \mathbf{f}_{SE}(\hat{l}_{T})\Big) = 0
\f]

As with any other equilibrium model, the above equation is rearranged to 
isolate for \f$ \mathbf{f}_V(\hat{v}_{CE}) \f$, which is inverted to solve for 
\f$ \hat{v}_{CE} \f$,  and then is numerically integrated during simulation:

\f[
 \hat{v}_{CE} = \mathbf{f}_V ^{-1} (
 \frac{ ( \mathbf{f}_{c\phi}(\cos \phi) + \mathbf{f}_{SE}(\hat{l}_{T}) ) / 
 \cos \phi
  - ( \mathbf{f}_{PE}(\hat{l}_{CE}) - \mathbf{f}_K(\hat{l}_{CE} ) )}
  { \mathbf{a}(t) \mathbf{f}_L(\hat{l}_{CE})} )
\f]


As with any equilibrium muscle model, the numerical stiffness of the above 
equation increases when terms in the denominator approach zero (when 
\f$\mathbf{a}(t) \rightarrow 0\f$,\f$\phi \rightarrow 90^\circ\f$, or
\f$ \mathbf{f}_L(\hat{l}_{CE}) \rightarrow 0 \f$) or additionally when the 
slope of \f$\mathbf{f}_V ^{-1}\f$ is steep (which occurs at fiber velocities
close to the maximum concentric and maximum eccentric fiber velocities).


For more information on these new terms please see the
doxygen for FiberCompressiveForceLengthCurve, 
FiberCompressiveForceCosPennationCurve, and 
MuscleFirstOrderActivationDynamicModel.


@author Matt Millard
*/
class OSIMACTUATORS_API Millard2012EquilibriumMuscle : public Muscle {
OpenSim_DECLARE_CONCRETE_OBJECT(Millard2012EquilibriumMuscle, Muscle);

//class OSIMACTUATORS_API Millard2012EquilibriumMuscle : public Muscle {

public:
//==============================================================================
// PROPERTIES
//==============================================================================
    /** @name Property declarations 
    These are the serializable properties associated with this class. **/
    /**@{**/
    OpenSim_DECLARE_PROPERTY( default_activation, double,
                       "assumed initial activation level if none is assigned.");

    OpenSim_DECLARE_PROPERTY( default_fiber_length, double,
                       "assumed initial fiber length if none is assigned.");

    OpenSim_DECLARE_PROPERTY(   activation_model, 
                                MuscleFirstOrderActivationDynamicModel,
                                "activation dynamics model with a lower bound");   
    
    OpenSim_DECLARE_PROPERTY(   active_force_length_curve,
                                ActiveForceLengthCurve,
                                "active force length curve");

    OpenSim_DECLARE_PROPERTY(   force_velocity_inverse_curve,
                                ForceVelocityInverseCurve,
                                "force velocity inverse curve");

    OpenSim_DECLARE_PROPERTY(   fiber_force_length_curve,
                                FiberForceLengthCurve,
                                "fiber force length curve");

    OpenSim_DECLARE_PROPERTY(   tendon_force_length_curve,
                                TendonForceLengthCurve,
                                "Tendon force length curve");

    //Should this be serialized at all? Normally an update to the left hand
    //point of the active force length curve should be accompanied by an update
    //to the engagment point of this curve. I bet many users might miss this
    //subtlety 
    OpenSim_DECLARE_PROPERTY(   fiber_compressive_force_length_curve,
                                FiberCompressiveForceLengthCurve,
                                "fiber compressive force length curve");
    

    OpenSim_DECLARE_PROPERTY(   fiber_compressive_force_cospennation_curve,
                                FiberCompressiveForceCosPennationCurve,
                           "fiber compressive force cos(pennationAngle) curve");
    /**@}**/



//=============================================================================
// Construction
//=============================================================================
    /**Default constructor: produces a non-functional empty muscle*/
    Millard2012EquilibriumMuscle();
    /**Default destructor*/
    ~Millard2012EquilibriumMuscle();

    /**Constructs a functional muscle using all of the default curves and
       activation model.

       @param aName The name of the muscle.

       @param aMaxIsometricForce 
        The force generated by the muscle when it at its optimal resting length,
        has a contraction velocity of zero, and is fully activated 
        (Newtons).
       
       @param aOptimalFiberLength
        The optimal length of the muscle fiber (meters).
                                
       @param aTendonSlackLength
        The resting length of the tendon (meters).

       @param aPennationAngle
        The angle of the fiber relative to the tendon when the fiber is at its
        optimal resting length (radians).
    */
    Millard2012EquilibriumMuscle(const std::string &aName,
                                double aMaxIsometricForce,
                                double aOptimalFiberLength,
                                double aTendonSlackLength,
                                double aPennationAngle);

    


//==============================================================================
// Get Properties
//==============================================================================
   /**
   @param s the state of the system
   @return the normalized force term associated with the compressive force length
          element, \f$\mathbf{f}_K(\hat{l}_{CE})\f$, in the equilibrium equation
   */
   double getFiberCompressiveForceLengthMultiplier(SimTK::State& s) const;

   /**
   @param s the state of the system
   @return the normalized force term associated with the compressive force 
           cosine pennation element, \f$\mathbf{f}_{c\phi}(\cos \phi)\f$, in the 
           equilibrium equation
   */
   double getFiberCompressiveForceCosPennationMultiplier(SimTK::State& s) const;


   /**
   @param s the state of the system
   @return the normalized force term associated with tendon element,
            \f$\mathbf{f}_{SE}(\hat{l}_{T})\f$, in the equilibrium equation 
   */
   double getTendonForceMultiplier(SimTK::State& s) const;

   /**
   @returns the MuscleFirstOrderActivationDynamicModel 
            that this muscle model uses
   */
    MuscleFirstOrderActivationDynamicModel getActivationModel() const;

    /**
    @returns the ActiveForceLengthCurve that this muscle model uses
    */
    ActiveForceLengthCurve getActiveForceLengthCurve() const;

    /**
    @returns the ForceVelocityInverseCurve that this muscle model uses
    */
    ForceVelocityInverseCurve getForceVelocityInverseCurve() const;

    /**
    @returns the FiberForceLengthCurve that this muscle model uses
    */
    FiberForceLengthCurve getFiberForceLengthCurve() const;

    /**
    @returns the TendonForceLengthCurve that this muscle model uses
    */
    TendonForceLengthCurve getTendonForceLengthCurve() const;

    /**
    @returns the FiberCompressiveForceLengthCurve that this muscle model uses
    */
    FiberCompressiveForceLengthCurve 
        getFiberCompressiveForceLengthCurve() const;

    /**
    @returns the FiberCompressiveForceCosPennationCurve that this muscle 
             model uses.
    */
    FiberCompressiveForceCosPennationCurve 
        getFiberCompressiveForceCosPennationCurve() const;

    /**
    @returns the stiffness of the muscle fibers along the tendon (N/m)
    */
    double getFiberStiffnessAlongTendon(const SimTK::State& s) const;

//==============================================================================
// Set Properties
//==============================================================================

    /**
    @param aActivationMdl the MuscleFirstOrderActivationDynamicModel that this
                          muscle model uses to simulate activation dynamics
    */
    void setActivationModel(
            MuscleFirstOrderActivationDynamicModel& aActivationMdl);

    /**
    @param aActiveForceLengthCurve the ActiveForceLengthCurve that this muscle
                            model uses to scale active fiber force as a function
                            of length
    */
    void setActiveForceLengthCurve(
            ActiveForceLengthCurve& aActiveForceLengthCurve);

    /**
    @param aForceVelocityInverseCurve the ForceVelocityInverseCurve that this
                            muscle model uses to calculate the derivative of
                            fiber length.
    */
    void setForceVelocityInverseCurve(
            ForceVelocityInverseCurve& aForceVelocityInverseCurve);

    /**
    @param aFiberForceLengthCurve the FiberForceLengthCurve that this muscle 
                            model uses to calculate the passive force the muscle
                            fiber generates as the length of the fiber changes
    */
    void setFiberForceLengthCurve(
            FiberForceLengthCurve& aFiberForceLengthCurve);
    
    /**
    @param aTendonForceLengthCurve the TendonForceLengthCurve that this muscle
                            model uses to define the tendon force length curve
    */
    void setTendonForceLengthCurve(
            TendonForceLengthCurve& aTendonForceLengthCurve);

    /**
    @param aFiberCompressiveForceLengthCurve the 
            FiberCompressiveForceLengthCurve that this muscle model uses to 
            ensure the length of the fiber is always greater than a physically
            realistic lower bound.
    */
    void setFiberCompressiveForceLengthCurve(
            FiberCompressiveForceLengthCurve& 
            aFiberCompressiveForceLengthCurve);

    /**
    @param aFiberCompressiveForceCosPennationCurve the
            FiberCompressiveForceCosPennationCurve that this muscle model uses
            to prevent pennation angles from approaching 90 degrees, which is
            associated with a singularity in this model.
    */
    void setFiberCompressiveForceCosPennationCurve(
            FiberCompressiveForceCosPennationCurve& 
            aFiberCompressiveForceCosPennationCurve);


//==============================================================================
// State Variable Related Functions
//==============================================================================
    /**
    @returns the default activation level that is used as an initial condition
             if none is provided by the user.
    */
    double getDefaultActivation() const;

    /**
    @returns the default fiber length that is used as an initial condition
             if none is provided by the user.
    */
    double getDefaultFiberLength() const;

    /**
    @param s The state of the system
    @returns the time derivative of activation
    */
    double getActivationRate(const SimTK::State& s) const;

    /**
    @param s The state of the system
    @returns the velocity of the fiber (m/s)
    */
    double getFiberVelocity(const SimTK::State& s) const;

    /**
    @param activation the default activation level that is used to initialize
           the muscle
    */
    void setDefaultActivation(double activation);

    /**
    @param fiberLength the default fiber length that is used to initialize
           the muscle
    */
    void setDefaultFiberLength(double fiberLength);

    /**
    @param s the state of the system
    @param activation the desired activation level
    */
    void setActivation(SimTK::State& s, double activation) const;

    /**
    @param s the state of the system
    @param fiberLength the desired fiber length (m)
    */
    void setFiberLength(SimTK::State& s, double fiberLength) const;

    /**
    @returns A string arraw of the state variable names
    */
    Array<std::string> getStateVariableNames() const FINAL_11;

    /**
    @param stateVariableName the name of the state varaible in question
    @returns The system index of the state variable in question
    */
    SimTK::SystemYIndex getStateVariableSystemIndex(
        const std::string &stateVariableName) const FINAL_11;

//==============================================================================
// Public Computations Muscle.h
//==============================================================================

    /**
    @param s the state of the system
    @returns the tensile force the muscle is generating in N
    */
    double computeActuation(const SimTK::State& s) const FINAL_11;


    /** This function computes the fiber length such that muscle fiber and 
        tendon are developing the same force, and so that the velocity of
        the entire muscle-tendon is spread between the fiber and the tendon
        according to their relative compliances.
        
        @param s the state of the system
    */
    void computeInitialFiberEquilibrium(SimTK::State& s) const FINAL_11;
    

protected:
    /** Courtesy of Ajay*/
    void postScale(const SimTK::State& s, const ScaleSet& aScaleSet);

        /** Calculate activation rate */
    double calcActivationRate(const SimTK::State& s) const; 


//==============================================================================
//Muscle Inferface requirements
//==============================================================================

    /**calculate muscle's position related values such fiber and tendon lengths,
    normalized lengths, pennation angle, etc... */
    void calcMuscleLengthInfo(const SimTK::State& s, 
                              MuscleLengthInfo& mli) const FINAL_11;  


    /** calculate muscle's velocity related values such fiber and tendon 
        velocities,normalized velocities, pennation angular velocity, etc... */
    virtual void  calcFiberVelocityInfo(const SimTK::State& s, 
                                      FiberVelocityInfo& fvi) const FINAL_11;

    /** calculate muscle's active and passive force-length, force-velocity, 
        tendon force, relationships and their related values */
    virtual void  calcMuscleDynamicsInfo(const SimTK::State& s, 
                                    MuscleDynamicsInfo& mdi) const FINAL_11;

//==============================================================================
//ModelComponent Interface requirements
//==============================================================================
    /**Sets up the ModelComponent from the model, if necessary*/
    void setup(Model& model) FINAL_11;

    /**Creates the ModelComponent so that it can be used in simulation*/
	void createSystem(SimTK::MultibodySystem& system) const FINAL_11;

    /**Initializes the state of the ModelComponent*/
	void initState(SimTK::State& s) const FINAL_11;
    
    /**Sets the default state for ModelComponent*/
    void setDefaultsFromState(const SimTK::State& s) FINAL_11;
	
    /**computes state variable derivatives*/
    SimTK::Vector computeStateVariableDerivatives(
        const SimTK::State& s) const FINAL_11;

//==============================================================================
//State derivative helper methods
//==============================================================================
	
    /**
    Set the derivative of an actuator state, specified by name
    @param s the state    
    @param aStateName The name of the state to set.
    @param aValue The value to set the state to.
    */
    void setStateVariableDeriv( const SimTK::State& s, 
                                const std::string &aStateName, 
                                double aValue) const;
   
    /**
     Get the derivative of an actuator state, by index.
     @param s the state 
     @param aStateName the name of the state to get.
     @return The value of the state derivative
    */
	double getStateVariableDeriv(   const SimTK::State& s, 
                                    const std::string &aStateName) const;

//Trying this with char* defined in the CPP file
//	static const std::string STATE_ACTIVATION_NAME;
//	static const std::string STATE_FIBER_LENGTH_NAME;   


private:
    ///The name used to access the activation state
    static const std::string STATE_ACTIVATION_NAME;
    ///The name used to access the fiber length state
	static const std::string STATE_FIBER_LENGTH_NAME;

    
    void setNull();
    void constructProperties();
    
    /**Builds all of the components that are necessary to use this 
    muscle model in simulation*/
    void buildMuscle();

    /**Checks to make sure that none of the muscle model's properties have
    changed. If they have changed, then the muscle is rebuilt.*/
    void ensureMuscleUpToDate() const;

    /**
    Calculates the force-velocity multiplier
    @param a activation
    @param fal the fiber active force length multiplier
    @param fpe the fiber force length multiplier
    @param fk the fiber compressive force length multiplier
    @param fcphi the fiber compressive force cos pennation multiplier
    @param fse the tendon force length multiplier
    @param cosphi the cosine of the pennation angle
    @param caller the name of the function calling this function. This name
           is provided to generate meaningful exception messages

    @return the force velocity multiplier
    */
    double calcFv(  double a, 
                    double fal, 
                    double fpe, 
                    double fk,                     
                    double fcphi, 
                    double fse, 
                    double cosphi,
                    std::string& caller) const;

    /**
    
    @param fiso the maximum isometric force the fiber can generate  
    @param a activation
    @param fal the fiber active force length multiplier
    @param fv the fiber force velocity multiplier
    @param fpe the fiber compressive force length multiplier
    @param fk the fiber compressive force length multiplier
    @param fcphi the fiber compressive force cos pennation multiplier   
    @param cosphi the cosine of the pennation angle    

    @return the force generated by the fiber, in the direction of the fiber
    */
    double calcFiberForce(  double fiso, 
                            double a, 
                            double fal,
                            double fv,                             
                            double fpe,
                            double fk, 
                            double fcphi,
                            double cosPhi) const;    


    /**
    @param fiso the maximum isometric force the fiber can generate  
    @param a activation
    @param fal the fiber active force length multiplier
    @param fv the fiber force velocity multiplier
    @param fpe the fiber compressive force length multiplier
    @param fk the fiber compressive force length multiplier
    @param fcphi the fiber compressive force cos pennation multiplier   
    @param cosphi the cosine of the pennation angle    

    @return the force generated by the fiber, in the direction of the tendon
    */
    double calcFiberForceAlongTendon(  double fiso, 
                                        double a, 
                                        double fal,
                                        double fv,                             
                                        double fpe,
                                        double fk, 
                                        double fcphi,
                                        double cosPhi) const;  


    /**
    @param fiso the maximum isometric force the fiber can generate  
    @param a activation
    @param fal the fiber active force length multiplier
    @param fv the fiber force velocity multiplier
    @param fpe the fiber compressive force length multiplier
    @param fk the fiber compressive force length multiplier
    @param fcphi the fiber compressive force cos pennation multiplier   
    @param sinphi the sine of the pennation angle
    @param cosphi the cosine of the pennation angle    
    @param lce the fiber length
    @param lceN the normalized fiber length
    @param optFibLen the optimal fiber length

    @return the stiffness (d_Fm/d_lce) of the fiber in the direction of the fiber
    */
    double calcFiberStiffness(  double fiso, 
                                double a, 
                                double fal,
                                double fv,                             
                                double fpe,
                                double fk, 
                                double fcphi,
                                double sinPhi,
                                double cosPhi,
                                double lce,
                                double lceN,
                                double optFibLen) const;

    /**
    @param dFm_d_lce the stiffness of the fiber in the direction of the fiber
    @param sinphi the sine of the pennation angle
    @param cosphi the cosine of the pennation angle    
    @param lce the fiber length

    @return the stiffness (d_FmAT/d_lceAT) of the fiber in the direction of 
            the tendon.
    */
    double calc_DFiberForceAT_DFiberLengthAT(  double dFm_d_lce,                                               
                                               double sinPhi,
                                               double cosPhi,
                                               double lce) const;
    /**
    @param fiso the maximum isometric force the fiber can generate  
    @param a activation
    @param fal the fiber active force length multiplier
    @param fv the fiber force velocity multiplier
    @param fpe the fiber compressive force length multiplier
    @param fk the fiber compressive force length multiplier
    @param fcphi the fiber compressive force cos pennation multiplier   
    @param sinphi the sine of the pennation angle
    @param cosphi the cosine of the pennation angle    
    @param lce the fiber length
    @param lceN the normalized fiber length
    @param optFibLen the optimal fiber length

    @return the partial derivative of fiber force along the tendon with respect
            to small changes in fiber length (in the direction of the fiber)
    */
    double calc_DFiberForceAT_DFiberLength( double fiso, 
                                            double a, 
                                            double fal,
                                            double fv,                             
                                            double fpe,
                                            double fk, 
                                            double fcphi,
                                            double sinPhi,
                                            double cosPhi,
                                            double lce,
                                            double lceN,
                                            double optFibLen) const;

    /**
    @param dFt_d_tl the partial derivative of tendon force with respect to small
                    changes in tendon length (tendon stiffness) in (N/m)
    @param lce the fiber length
    @param sinphi the sine of the pennation angle
    @param cosphi the cosine of the pennation angle        
    @return the partial derivative of tendon force with respect to small changes 
            in fiber length
    */
    double calc_DTendonForce_DFiberLength(  double dFt_d_tl, 
                                            double lce,
                                            double sinphi,
                                            double cosphi,
                                            std::string& caller) const;

    //=====================================================================
    // Private Utility Class Members
    //      -Computes activation dynamics and fiber kinematics
    //=====================================================================

    /**This object defines the pennation model used for this muscle model*/
    mutable MuscleFixedWidthPennationModel *penMdl;

    /**
    @param s the system state
    @param aActivation the initial activation of the muscle
    @param aSolTolerance the desired relative tolerance of the equilibrium 
           solution
    @param aMaxIterations the maximum number of Newton steps allowed before
           attempts to initialize the model are given up, and an exception is 
           thrown.
    */
    SimTK::Vector initMuscleState(SimTK::State& s, double aActivation,
                             double aSolTolerance, int aMaxIterations) const;
    
};    

} // end of namespace OpenSim

#endif // OPENSIM_Millard2012EquilibriumMuscle_h__
