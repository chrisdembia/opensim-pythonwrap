#ifndef OPENSIM_Millard2012EquilibriumMuscle_h__
#define OPENSIM_Millard2012EquilibriumMuscle_h__
/* -------------------------------------------------------------------------- *
 *                  OpenSim:  Millard2012EquilibriumMuscle.h                  *
 * -------------------------------------------------------------------------- *
 * The OpenSim API is a toolkit for musculoskeletal modeling and simulation.  *
 * See http://opensim.stanford.edu and the NOTICE file for more information.  *
 * OpenSim is developed at Stanford University and supported by the US        *
 * National Institutes of Health (U54 GM072970, R24 HD065690) and by DARPA    *
 * through the Warrior Web program.                                           *
 *                                                                            *
 * Copyright (c) 2005-2012 Stanford University and the Authors                *
 * Author(s): Matthew Millard                                                 *
 *                                                                            *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may    *
 * not use this file except in compliance with the License. You may obtain a  *
 * copy of the License at http://www.apache.org/licenses/LICENSE-2.0.         *
 *                                                                            *
 * Unless required by applicable law or agreed to in writing, software        *
 * distributed under the License is distributed on an "AS IS" BASIS,          *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
 * See the License for the specific language governing permissions and        *
 * limitations under the License.                                             *
 * -------------------------------------------------------------------------- */


// INCLUDE
#include <OpenSim/Actuators/osimActuatorsDLL.h>

#include <simbody/internal/common.h>
#include <OpenSim/Simulation/Model/Muscle.h>
/*
The parent class, Muscle.h, provides 
    1. max_isometric_force
    2. optimal_fiber_length
    3. tendon_slack_length
    4. pennation_angle_at_optimal
    5. max_contraction_velocity
*/
#include <OpenSim/Simulation/Model/Muscle.h>

//All of the sub-models required for a muscle model:
#include <OpenSim/Actuators/MuscleFirstOrderActivationDynamicModel.h>
#include <OpenSim/Actuators/MuscleFixedWidthPennationModel.h>

#include <OpenSim/Actuators/ActiveForceLengthCurve.h>
#include <OpenSim/Actuators/ForceVelocityCurve.h>
#include <OpenSim/Actuators/ForceVelocityInverseCurve.h>
#include <OpenSim/Actuators/FiberForceLengthCurve.h>
//#include <OpenSim/Actuators/FiberCompressiveForceLengthCurve.h>
//#include <OpenSim/Actuators/FiberCompressiveForceCosPennationCurve.h>
#include <OpenSim/Actuators/TendonForceLengthCurve.h>


#ifdef SWIG
    #ifdef OSIMACTUATORS_API
        #undef OSIMACTUATORS_API
        #define OSIMACTUATORS_API
    #endif
#endif

namespace OpenSim {


/**
This class implements a configurable equilibrium muscle model. An equilibrium 
model assumes that the force generated by the tendon and the force generated by 
the fiber are assumed to be equal and opposite:

\f[
 f_{ISO}\Big(\mathbf{a}(t) \mathbf{f}_L(\hat{l}_{CE}) \mathbf{f}_V(\hat{v}_{CE}) 
+ \mathbf{f}_{PE}(\hat{l}_{CE}) + \beta \hat{v}_{CE})\Big) \cos \phi
-  f_{ISO}\mathbf{f}_{SE}(\hat{l}_{T}) = 0
\f]

\image html fig_Millard2012EquilibriumMuscle.png

This model can be simulated in a number of different ways by setting using the
following configuration options:

<B>Tendon Configuration</B>

\li ignore_tendon_compliance: when set to true makes the tendon rigid. This 
assumption is usually reasonable for short tendons, and results in a simulation
speedup because fiber length is no longer a state. 

<B>Fiber Configuration</B>

\li ignore_activation_dynamics: when set to true, excitation is treated as 
activation. This results in faster simulation times because the state vector
is smaller.

\li use_fiber_damping: when set to true \f$\beta\f$ is set to a non-zero value.
The addition of damping allows a different method simulataneously allows 
the muscle to be more physiologically correct (it can have an activation of 
zero, its active force length curve can go to zero, and its force velocity curve
can be asymptotic) while reducing simulation time.


<B>Elastic Tendon, No Fiber Damping</B>

The most typical configuration used in the literature is to simulate a muscle
with an elastic tendon, full fiber dynamics, and activation dynamics. The 
resulting formulation suffers from several singularities:
\f$\mathbf{a}(t) \rightarrow 0\f$,\f$\phi \rightarrow 90^\circ\f$, and 
\f$ \mathbf{f}_L(\hat{l}_{CE}) \rightarrow 0 \f$. These singularities are all
mananaged carefully in this model to ensure that this model does not produce
singularities, nor intolerably long simulation times.

These singularities arise from the manner in which the equilibrium equation
is rearranged to yield an ordinary differential equation (ODE). The above 
equation is rearranged to  isolate for \f$ \mathbf{f}_V(\hat{v}_{CE}) \f$, 
which is inverted to solve for \f$ \hat{v}_{CE} \f$,  and then is numerically 
integrated during simulation:

\f[
 \hat{v}_{CE} = \mathbf{f}_V ^{-1} (
 \frac{ ( \mathbf{f}_{SE}(\hat{l}_{T}) ) / 
 \cos \phi
  -  \mathbf{f}_{PE}(\hat{l}_{CE}) }
  { \mathbf{a}(t) \mathbf{f}_L(\hat{l}_{CE})} )
\f]


The above equation becomes numerical stiff when terms in the denominator 
approach zero (when \f$\mathbf{a}(t) \rightarrow 0\f$,\f$\phi 
\rightarrow 90^\circ\f$, or \f$ \mathbf{f}_L(\hat{l}_{CE}) \rightarrow 0 \f$) 
or additionally when the slope of \f$\mathbf{f}_V ^{-1}\f$ is steep (which
occurs at fiber velocities close to the maximum concentric and maximum 
eccentric fiber velocities).

Physically singularity management means that this muscle model is always 
activated (\f$\mathbf{a}(t) > 0\f$), the fiber will stop contracting when a 
pennation angle of 90 degrees is approached (\f$\phi < 90^\circ\f$), and the 
fiber will also stop contracting as its length approaches a lower bound 
(\f$ \hat{l}_{CE} > lowerbound\f$), typically around half the fiber's resting 
length ( to ensure \f$ \mathbf{f}_L(\hat{l}_{CE}) > 0 \f$). The fiber length is
 prevented from achieving either an unphysiological length, or its maximum
 pennation angle, through the use of a unilateral constraint. Additionally, the
 force velocity curve is modified so that it is invertible.

 When an elastic tendon without fiber damping is selected, the minimum active
 force length value is set to 0.1,  the minimum activation allowed is set
 to 0.01, and the maximum pennation angle permitted is set to acos(0.1) or 
 84.3 degrees. This is done as a convenience for the user, to prevent the model 
 from taking an unreasonable amount of time to simulate. 

 <B>(Rigid Tendon) or (Elastic Tendon with Fiber Damping)</B>

 Neither of these formulations have any singularities. This allows the lower 
 bound of the active force length curve to be 0 
 (min( \f$ \mathbf{f}_L(\hat{l}_{CE})) = 0 \f$), activation can go to 0, and 
 the force velocity curve need not be invertible.

 Physically this means that the muscle can be turned off, and its characteristic
 curves do not need to be modified (active force length can go to 0, and the 
 force velocity curve does not have to be invertible).

 The rigid tendon formulation removes these singularities by ignoring the 
 elasticity of the tendon. This assumption is reasonable for many muscles, but
 is up to the musculoskeletal model designer and user to determine when this 
 assumption can be made. 
 
 The elastic tendon with fiber damping removes singularities by solving the
 equilibrium equation using Newton's method. This is possible because the 
 partial derivative of the equilibrium equation with respect to fiber velocity
 is always positive if \f$ \beta > 0\f$, and thus permits Newton's method to
 find a solution to the equilibrium equation.

 When either of these singularity-free formulations are selected, the minimum 
 active force length value is set to 0.0, the minimum activation allowed is 
 set to 0.0. This is done as a convenience for the user, as these changes make 
 the results of the model more realistic yet incurr no performance penality. The
 maximum pennation angle is left as acos(0.1) or 84.3 degrees, because allowing
 pennation angles higher than this results in a stiff fiber velocity state
 at high pennation angles.

 <B> Usage </B>
    This object should be updated through the set methods provided. 
    These set methods will take care of rebuilding the muscle correctly. If you
    modify the properties directly, the muscle will not be rebuilt, and upon
    calling any functions that have a SimTK::State with an input, an 
    exception will be thrown because the muscle is out of date with its 
    properties.

 <B>Example</B>

 @code
 double fiso = 5000;
 double optFiberLength = 0.025;
 double tendonSlackLen = 0.25;
 double pennationAngle = 30.0*(SimTK::Pi/180.0);

 bool ignoreTendonCompliance = false;
 bool ignoreActivationDynamics = false;
 bool useFiberDamping = true;

 Millard2012EquilibriumMuscle muscle(aConfig.muscleName,
                                        aConfig.fiso,
                                        aConfig.optFiberLen,
                                        aConfig.tendonSlackLen,
                                        aConfig.pennationAngle);

 muscle.setMuscleConfiguration(ignoreTendonCompliance,
                                ignoreActivationDynamics,
                                useFiberDamping);

    
 @endcode

 <B>Further Information...</B>

For more information please see the
doxygen for the properties that are objects themselves ( such as 
MuscleFirstOrderActivationDynamicModel, MuscleFixedWidthPennationModel,
ActiveForceLengthCurve, FiberForceLengthCurve, TendonForceLengthCurve, and
ForceVelocityInverseCurve ).


@author Matt Millard
*/
class OSIMACTUATORS_API Millard2012EquilibriumMuscle : public Muscle {
OpenSim_DECLARE_CONCRETE_OBJECT(Millard2012EquilibriumMuscle, Muscle);
//class OSIMACTUATORS_API Millard2012EquilibriumMuscle : public Muscle {

public:
//==============================================================================
// PROPERTIES
//==============================================================================
    /** @name Property declarations 
    These are the serializable properties associated with this class. **/
    /**@{**/

    OpenSim_DECLARE_PROPERTY( use_fiber_damping, bool,
        "Include fiber damping. This cannot be applied in the reduced model");

    OpenSim_DECLARE_PROPERTY( fiber_damping, double,
        "The linear damping of the fiber. Not included in reduced model.");

    OpenSim_DECLARE_PROPERTY( default_activation, double,
                       "assumed initial activation level if none is assigned.");

    OpenSim_DECLARE_PROPERTY( default_fiber_length, double,
                       "assumed initial fiber length if none is assigned.");
    

    OpenSim_DECLARE_UNNAMED_PROPERTY( 
                                MuscleFirstOrderActivationDynamicModel,
                                "activation dynamics model with a lower bound");   
    
    OpenSim_DECLARE_UNNAMED_PROPERTY(
                                ActiveForceLengthCurve,
                                "active force length curve");

    OpenSim_DECLARE_UNNAMED_PROPERTY(
                                ForceVelocityInverseCurve,
                                "force velocity inverse curve");

    OpenSim_DECLARE_UNNAMED_PROPERTY(
                                FiberForceLengthCurve,
                                "fiber force length curve");

    OpenSim_DECLARE_UNNAMED_PROPERTY(
                                TendonForceLengthCurve,
                                "Tendon force length curve");
    



//=============================================================================
// Construction
//=============================================================================
    /**Default constructor: produces a non-functional empty muscle*/
    Millard2012EquilibriumMuscle();

    /**Constructs a functional muscle using all of the default curves and
       activation model. The tendon is assumed to be elastic, full fiber
       dynamics are solved, and activation dynamics are included.

       @param aName The name of the muscle.

       @param aMaxIsometricForce 
        The force generated by the muscle when it at its optimal resting length,
        has a contraction velocity of zero, and is fully activated 
        (Newtons).
       
       @param aOptimalFiberLength
        The optimal length of the muscle fiber (meters).
                                
       @param aTendonSlackLength
        The resting length of the tendon (meters).

       @param aPennationAngle
        The angle of the fiber relative to the tendon when the fiber is at its
        optimal resting length (radians).
    */
    Millard2012EquilibriumMuscle(const std::string &aName,
                                double aMaxIsometricForce,
                                double aOptimalFiberLength,
                                double aTendonSlackLength,
                                double aPennationAngle);

    


//==============================================================================
// Get Properties
//==============================================================================   
  

   /**
   @param s the state of the system
   @return the normalized force term associated with tendon element,
            \f$\mathbf{f}_{SE}(\hat{l}_{T})\f$, in the equilibrium equation 
   */
   double getTendonForceMultiplier(SimTK::State& s) const;

   /**
   @returns the MuscleFirstOrderActivationDynamicModel 
            that this muscle model uses
   */
    const MuscleFirstOrderActivationDynamicModel& getActivationModel() const;

    /**
   @returns the MuscleFixedWidthPennationModel 
            that this muscle model uses
   */
    const MuscleFixedWidthPennationModel& getPennationModel() const;

    /**
    @returns the ActiveForceLengthCurve that this muscle model uses
    */
    const ActiveForceLengthCurve& getActiveForceLengthCurve() const;

    /**
    @returns the ForceVelocityInverseCurve that this muscle model uses
    */
    const ForceVelocityInverseCurve& getForceVelocityInverseCurve() const;

    /**
    @returns the FiberForceLengthCurve that this muscle model uses
    */
    const FiberForceLengthCurve& getFiberForceLengthCurve() const;

    /**
    @returns the TendonForceLengthCurve that this muscle model uses
    */
    const TendonForceLengthCurve& getTendonForceLengthCurve() const;

    

    /**
    @returns the stiffness of the muscle fibers along the tendon (N/m)
    */
    double getFiberStiffnessAlongTendon(const SimTK::State& s) const;
    
    /**
     @returns the minimum fiber length, which is the maximum of two values:
        the smallest fiber length allowed by the pennation model, and the 
        minimum fiber length in the active force length curve. When the fiber
        length reaches this value, it is constrained to this value until the 
        fiber velocity goes positive.
    */
    double getMinimumFiberLength() const;

    /**
     @returns the minimum fiber length along the tendon, which is the maximum of 
        two values:
        the smallest fiber length along the teond allowed by the pennation 
        model, and the minimum fiber length along the tendon in the active force
        length curve. When the fiber length reaches this value, it is 
        constrained to this length along the tendon until the fiber velocity 
        goes positive.
    */
    double getMinimumFiberLengthAlongTendon() const;

    /**
    @returns the minimum activation level allowed by the muscle model. Note that
             this equilibrium model, like all equilibrium models has a 
             singularity when activation goes to 0.0, which means that a 
             non-zero lower bound is required.
    */
    double getMinimumActivation() const;

    /**
    @returns the maximum pennation angle allowed by this muscle model. Note that
            this equilibrium model, like all equilibrium models has a 
            singularity when pennation hits Pi/2.0. This requires that the 
            maximum pennation angle must be less than Pi/2.0.
    */
    double getMaximumPennationAngle() const;


    bool getUseFiberDamping() const;

//==============================================================================
// Set Properties
//==============================================================================

    /**
    @param aActivationMdl the MuscleFirstOrderActivationDynamicModel that this
                          muscle model uses to simulate activation dynamics
    */
    void setActivationModel(
            MuscleFirstOrderActivationDynamicModel& aActivationMdl);

    //This is now set automatically depending on the configuration of the muscle
    /*
    @param minActivation will set the minimum activation property in the 
            Activation model. This function is provided to ensure that the 
            desired minimum activation will not cause a numerical singularity 
            in this model.
    @returns true if the value was acceptable and the property was set
    */
    //bool setMinimumActivation(double minActivation);


    /**
    @param aActiveForceLengthCurve the ActiveForceLengthCurve that this muscle
                            model uses to scale active fiber force as a function
                            of length
    */
    void setActiveForceLengthCurve(
            ActiveForceLengthCurve& aActiveForceLengthCurve);

    /**
    @param aForceVelocityInverseCurve the ForceVelocityInverseCurve that this
                            muscle model uses to calculate the derivative of
                            fiber length.
    */
    void setForceVelocityInverseCurve(
            ForceVelocityInverseCurve& aForceVelocityInverseCurve);

    /**
    @param aFiberForceLengthCurve the FiberForceLengthCurve that this muscle 
                            model uses to calculate the passive force the muscle
                            fiber generates as the length of the fiber changes
    */
    void setFiberForceLengthCurve(
            FiberForceLengthCurve& aFiberForceLengthCurve);
    
    /**
    @param aTendonForceLengthCurve the TendonForceLengthCurve that this muscle
                            model uses to define the tendon force length curve
    */
    void setTendonForceLengthCurve(
            TendonForceLengthCurve& aTendonForceLengthCurve);

    /**
    @param ignoreTendonCompliance when set true uses a rigid tendon formulation
    @param ignoreActivationDynamics when set true ignores activation dynamics
                                    and treats the control signal as activation
    @param useDamping when set true enables the damped fiber method of solving
    */
    void setMuscleConfiguration(bool ignoreTendonCompliance,
                                bool ignoreActivationDynamics,
                                bool useDamping);



//==============================================================================
// State Variable Related Functions
//==============================================================================
    /**
    @returns the default activation level that is used as an initial condition
             if none is provided by the user.
    */
    double getDefaultActivation() const;

    /**
    @returns the default fiber length that is used as an initial condition
             if none is provided by the user.
    */
    double getDefaultFiberLength() const;

    /**
    @param s The state of the system
    @returns the time derivative of activation
    */
    double getActivationRate(const SimTK::State& s) const;

    /**
    @param s The state of the system
    @returns the velocity of the fiber (m/s)
    */
    double getFiberVelocity(const SimTK::State& s) const;

    /**
    @param activation the default activation level that is used to initialize
           the muscle
    */
    void setDefaultActivation(double activation);

    /**
    @param fiberLength the default fiber length that is used to initialize
           the muscle
    */
    void setDefaultFiberLength(double fiberLength);

    /**
    @param s the state of the system
    @param activation the desired activation level
    */
    void setActivation(SimTK::State& s, double activation) const;

    /**
    @param s the state of the system
    @param fiberLength the desired fiber length (m)
    */
    void setFiberLength(SimTK::State& s, double fiberLength) const;

    

    /**
    @returns A string arraw of the state variable names
    */
    Array<std::string> getStateVariableNames() const FINAL_11;

    /**
    @param stateVariableName the name of the state varaible in question
    @returns The system index of the state variable in question
    */
    SimTK::SystemYIndex getStateVariableSystemIndex(
        const std::string &stateVariableName) const FINAL_11;

//==============================================================================
// Public Computations Muscle.h
//==============================================================================

    /**
    @param s the state of the system
    @returns the tensile force the muscle is generating in N
    */
    double computeActuation(const SimTK::State& s) const FINAL_11;


    /** This function computes the fiber length such that muscle fiber and 
        tendon are developing the same force, and so that the velocity of
        the entire muscle-tendon is spread between the fiber and the tendon
        according to their relative compliances.
        
        @param s the state of the system
    */
    void computeInitialFiberEquilibrium(SimTK::State& s) const OVERRIDE_11;
    

    ///@cond TO BE DEPRECATED. 
    /*  Once the ignore_tendon_compliance flag is implemented correctly get rid 
        of this method as it duplicates code in calcMuscleLengthInfo,
        calcFiberVelocityInfo, and calcMuscleDynamicsInfo
    */
    /*
    @param activation of the muscle [0-1]
    @param fiberLength in (m)
    @param fiberVelocity in (m/s)
    @returns the force component generated by the fiber that is associated only
             with activation (the parallel element is not included)   
    */
    double calcActiveFiberForceAlongTendon( double activation, 
                                            double fiberLength, 
                                            double fiberVelocity) const; 

    /**
    @param s the state of the system
    @param aActivation the activation of the muscle
    @returns the active fiber force generated by a rigid tendon equilibrium
             muscle model.
    */
    virtual double calcInextensibleTendonActiveFiberForce(SimTK::State& s, 
                                             double aActivation) const FINAL_11;
    ///@endcond
protected:
    /** Courtesy of Ajay*/
    void postScale(const SimTK::State& s, const ScaleSet& aScaleSet);

        /** Calculate activation rate */
    double calcActivationRate(const SimTK::State& s) const; 


//==============================================================================
//Muscle Inferface requirements
//==============================================================================

    /**calculate muscle's position related values such fiber and tendon lengths,
    normalized lengths, pennation angle, etc... */
    void calcMuscleLengthInfo(const SimTK::State& s, 
                              MuscleLengthInfo& mli) const OVERRIDE_11;  


    /** calculate muscle's velocity related values such fiber and tendon 
        velocities,normalized velocities, pennation angular velocity, etc... */
    void  calcFiberVelocityInfo(const SimTK::State& s, 
                                FiberVelocityInfo& fvi) const OVERRIDE_11;

    /** calculate muscle's active and passive force-length, force-velocity, 
        tendon force, relationships and their related values */
    void  calcMuscleDynamicsInfo(const SimTK::State& s, 
                                 MuscleDynamicsInfo& mdi) const OVERRIDE_11;

//==============================================================================
//ModelComponent Interface requirements
//==============================================================================
    /**Sets up the ModelComponent from the model, if necessary*/
    void connectToModel(Model& model) FINAL_11;

    /**Creates the ModelComponent so that it can be used in simulation*/
	void addToSystem(SimTK::MultibodySystem& system) const OVERRIDE_11;

    /**Initializes the state of the ModelComponent*/
	void initStateFromProperties(SimTK::State& s) const OVERRIDE_11;
    
    /**Sets the default state for ModelComponent*/
    void setPropertiesFromState(const SimTK::State& s) OVERRIDE_11;
	
    /**computes state variable derivatives*/
    SimTK::Vector computeStateVariableDerivatives(
        const SimTK::State& s) const OVERRIDE_11;

//==============================================================================
//State derivative helper methods
//==============================================================================
	
    /**
    Set the derivative of an actuator state, specified by name
    @param s the state    
    @param aStateName The name of the state to set.
    @param aValue The value to set the state to.
    */
    void setStateVariableDeriv( const SimTK::State& s, 
                                const std::string &aStateName, 
                                double aValue) const;
   
    /**
     Get the derivative of an actuator state, by index.
     @param s the state 
     @param aStateName the name of the state to get.
     @return The value of the state derivative
    */
	double getStateVariableDeriv(   const SimTK::State& s, 
                                    const std::string &aStateName) const;

private:
    //The name used to access the activation state
    static const std::string STATE_ACTIVATION_NAME;
    //The name used to access the fiber length state
	static const std::string STATE_FIBER_LENGTH_NAME;
    
    //static const std::string PREVIOUS_FIBER_LENGTH_NAME;
    //static const std::string PREVIOUS_FIBER_VELOCITY_NAME;

    void setNull();
    void constructProperties();
    
    /*Builds all of the components that are necessary to use this 
    muscle model in simulation*/
    void buildMuscle();

    /*Checks to make sure that none of the muscle model's properties have
    changed. If they have changed, then the muscle is rebuilt.*/
    void ensureMuscleUpToDate();
    

    //Approximate muscle dynamics are the same as the regular 
    //equilibrium muscle dynamics

     /*
    Calculates the fiber velocity that satisfies the equilibrium equation given
    a fixed fiber length
    @param a activation
    @param fal active force length multiplier
    @param fpe passive force length multiplier
    @param fse series elastic force length multiplier
    @param beta damping coefficent
    @param lce the fiber length
    @param lceN the normalized fiber length
    @param cosPhi cosine of the pennation angle
    @returns [0] dlceN_dt
             [1] err
             [2] converged
    */
    SimTK::Vec3 calcDampedNormFiberVelocity(  double fiso,
                                        double a,
                                        double fal,
                                        double fpe,
                                        double fse,
                                        double beta,                                       
                                        double cosPhi) const;

    /*
    Calculates the force-velocity multiplier
    @param a activation
    @param fal the fiber active force length multiplier
    @param fp the total normalized parallel fiber force multiplier
    @param fse the tendon force length multiplier
    @param cosphi the cosine of the pennation angle
    @param caller the name of the function calling this function. This name
           is provided to generate meaningful exception messages

    @return the force velocity multiplier
    */
    double calcFv(  double a, 
                    double fal, 
                    double fp,                                         
                    double fse, 
                    double cosphi,
                    std::string& caller) const;

    /*
    
    @param fiso the maximum isometric force the fiber can generate  
    @param a activation
    @param fal the fiber active force length multiplier
    @param fv the fiber force velocity multiplier
    @param fpe the fiber force length multiplier  
    @param dlceN the normalized fiber velocity
    @param cosphi the cosine of the pennation angle    

    @return Vec3
        [0] total fiber force
        [1] active fiber force
        [2] passive fiber force
    */
    SimTK::Vec3 calcFiberForce( double fiso, 
                                double a, 
                                double fal,
                                double fv,                                 
                                double fpe,
                                double dlceN) const;    


    /*
    @param total force developed by the fiber
    @param cosphi the cosine of the pennation angle    

    @return the force generated by the fiber, in the direction of the tendon
    */
    double calcFiberForceAlongTendon(   double fiberForce,                                       
                                        double cosPhi) const;  


    /*
    @param fiso the maximum isometric force the fiber can generate  
    @param a activation
    @param fal the fiber active force length multiplier
    @param fv the fiber force velocity multiplier
    @param fpe the fiber force length multiplier
    @param sinphi the sine of the pennation angle
    @param cosphi the cosine of the pennation angle    
    @param lce the fiber length
    @param lceN the normalized fiber length
    @param optFibLen the optimal fiber length

    @return the stiffness (d_Fm/d_lce) of the fiber in the direction of the fiber
    */
    double calcFiberStiffness(  double fiso, 
                                double a, 
                                double fv,                             
                                double lceN,
                                double optFibLen) const;

    /*    
    @param fiso the maximum isometric force the fiber can generate  
    @param a activation
    @param fal the fiber active force length multiplier 
    @param beta damping coefficient
    @param s damping force scaling
    @param ds_d_dlce derivative of the damping scaling w.r.t. fiber length
    @param dlceN_dt normalized fiber velocity 
           (where 1 is the maximum fiber velocity)
    @param the maximum contraction velocity in m/s
    @return the partial derivative of fiber force 
            w.r.t normalized fiber velocity
    */
    double calc_DFiberForce_DNormFiberVelocity( double fiso, 
                                                double a, 
                                                double fal,
                                                double beta,                                                
                                                double dlceN_dt) const;

    /*
    @param fiberForce the force, in Newtons, developed by the fiber
    @param fiberStiffness the stiffness, in N/m, of the fiber
    @param lce the fiber length
    @param sinphi the sine of the pennation angle
    @param cosphi the cosine of the pennation angle    

    @return the partial derivative of fiber force along the tendon with respect
            to small changes in fiber length (in the direction of the fiber)
    */
    double calc_DFiberForceAT_DFiberLength( double fiberForce,
                                            double fiberStiffness,
                                            double lce,
                                            double sinPhi,
                                            double cosPhi) const;

    /*
    @param dFm_d_lce the stiffness of the fiber in the direction of the fiber
    @param sinphi the sine of the pennation angle
    @param cosphi the cosine of the pennation angle    
    @param lce the fiber length

    @return the stiffness (d_FmAT/d_lceAT) of the fiber in the direction of 
            the tendon.
    */
    double calc_DFiberForceAT_DFiberLengthAT(  double dFm_d_lce,                                               
                                               double sinPhi,
                                               double cosPhi,
                                               double lce) const;
    

    /*
    @param dFt_d_tl the partial derivative of tendon force with respect to small
                    changes in tendon length (tendon stiffness) in (N/m)
    @param lce the fiber length
    @param sinphi the sine of the pennation angle
    @param cosphi the cosine of the pennation angle        
    @return the partial derivative of tendon force with respect to small changes 
            in fiber length
    */
    double calc_DTendonForce_DFiberLength(  double dFt_d_tl, 
                                            double lce,
                                            double sinphi,
                                            double cosphi,
                                            std::string& caller) const;

    //=====================================================================
    // Private Utility Class Members
    //      -Computes activation dynamics and fiber kinematics
    //=====================================================================

    // This object defines the pennation model used for this muscle model.
    // Using a ClonePtr saves us from having to write a destructor, copy
    // constructor, or copy assignment. This will be zeroed on construction,
    // cleaned up on destruction, and cloned when copying.
    //SimTK::ClonePtr<MuscleFixedWidthPennationModel> penMdl;
    MuscleFixedWidthPennationModel penMdl;

    //Used in muscle initialization, and by every muscle model configuration
    //except the equilibrium model that does not have fiber damping
    ForceVelocityCurve fvCurve;

    //Here I'm using the 'm_' to prevent me from trashing this variable with
    //a poorly chosen local variable.
    double m_minimumFiberLength;
    double m_minimumFiberLengthAlongTendon;

    /*
    Solves fiber length and velocity to satisfy the equilibrium equations. 
    Fiber velocity is shared between the tendon and the fiber based on their
    relative mechanical stiffnesses. 

    @param aActivation the initial activation of the muscle
    @param pathLength length of the whole muscle
    @param pathLengtheningSpeed lengthening speed of the muscle path
    @param aSolTolerance the desired relative tolerance of the equilibrium 
           solution
    @param aMaxIterations the maximum number of Newton steps allowed before
           attempts to initialize the model are given up, and an exception is 
           thrown.
    */
    SimTK::Vector estimateMuscleFiberState(double aActivation, 
                            double pathLength, double pathLengtheningSpeed,
                            double aSolTolerance, int aMaxIterations) const;
    
   

    //Returns true if the fiber length is currently shorter than the minimum
    //value allowed by the pennation model and the active force length curve
    bool isFiberStateClamped(double lce, 
                            double dlceN) const;

    //Returns the maximum of the minimum fiber length, and the current fiber 
    //length
    double clampFiberLength(double lce) const;

    //Returns true if fiber length is a state
    bool isFiberLengthAState() const;
    //Returns true if the tendon is elastic
    bool isTendonElastic() const;
    //Returns true if activation is a state
    bool isActivationAState() const;
    
    //If the model configuration has a state equation with singularities in it, 
    //this will return true, else it will return false.
    bool canStateGoSingular() const;
    //Returns the simulation method called prior to the call to initSystem
    int getSimulationMethod() const;
    //Calculates a flag that indicates the exact configuration of the simulation
    int calcSimulationMethod(bool ignoreTendonCompliance, 
                             bool ignoreActivationDynamics,
                             bool useFiberDamping) const;
    
    

};    

} // end of namespace OpenSim

#endif // OPENSIM_Millard2012EquilibriumMuscle_h__
