<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenSim: OpenSim::Mtx Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>OpenSim</b>::<a class="el" href="classOpenSim_1_1Mtx.html">Mtx</a>
  </div>
</div>
<div class="contents">
<h1>OpenSim::Mtx Class Reference</h1><!-- doxytag: class="OpenSim::Mtx" -->
<p>A class for performing vector and matrix operations.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Mtx.h&gt;</code></p>

<p><a href="classOpenSim_1_1Mtx-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a84a9f672c7a4b1947d1d1a8444f0cc43">Angle</a> (const SimTK::Vec3 &amp;aV1, const SimTK::Vec3 &amp;aV2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the angle between two vectors: theta = acos( aV1*aV2/(|aV1|*|aV2|)).  <a href="#a84a9f672c7a4b1947d1d1a8444f0cc43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#ad5f53c31a9f74dc8408711d857e08015">Normalize</a> (int aN, const SimTK::Vec3 &amp;aV, SimTK::Vec3 &amp;rV)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize a vector.  <a href="#ad5f53c31a9f74dc8408711d857e08015"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a6f18fdb7caa4dbca057740d46782ea74">Magnitude</a> (int aN, const SimTK::Vec3 &amp;aV)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the magnitude of a vector.  <a href="#a6f18fdb7caa4dbca057740d46782ea74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a1b19c5bf6aa788d41143e26f6c5eceef">DotProduct</a> (int aN, const SimTK::Vec3 &amp;aV1, const SimTK::Vec3 &amp;aV2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the dot product of two vectors.  <a href="#a1b19c5bf6aa788d41143e26f6c5eceef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#acd63b086de1a6a4abf580a4eb57ec8cf">CrossProduct</a> (SimTK::Vec3 &amp;aV1, SimTK::Vec3 &amp;aV2, SimTK::Vec3 &amp;aV)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the cross product of two vectors.  <a href="#acd63b086de1a6a4abf580a4eb57ec8cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a14cafdebc8ee9c3dca9bd2b249589ba4">PerpendicularUnitVector</a> (SimTK::Vec3 &amp;aV, SimTK::Vec3 &amp;rV)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a unit vector that is perpendicular to a specified vector.  <a href="#a14cafdebc8ee9c3dca9bd2b249589ba4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a19cff909fc23ce8082a8baf36b6d9acd">Interpolate</a> (int aN, double aT1, double *aY1, double aT2, double *aY2, double t, double *aY)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linearly interpolate or extrapolate an array of data.  <a href="#a19cff909fc23ce8082a8baf36b6d9acd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a29291590ff292de2dfd877bd609a8a5d">Interpolate</a> (double aT1, double aY1, double aT2, double aY2, double t)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linearly interpolate or extrapolate two data points.  <a href="#a29291590ff292de2dfd877bd609a8a5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a09bb683efbc7e0d210104340b24b82a0">Translate</a> (double aX, double aY, double aZ, const double aP[3], double rP[3])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Translate a point by a specified amount.  <a href="#a09bb683efbc7e0d210104340b24b82a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#aa4a8376ed67d59beb8bbac20b0351728">Rotate</a> (int aXYZ, double aRadians, const double aP[3], double rP[3])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a point about the X, Y, or Z axis by a specified amount.  <a href="#aa4a8376ed67d59beb8bbac20b0351728"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#aac95571668b93346367715dbea233ba5">Rotate</a> (const double aAxis[3], double aRadians, const double aP[3], double rP[3])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a point about a specified axis by a specified amount.  <a href="#aac95571668b93346367715dbea233ba5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a2c859e8887f5adcb75ae2c43833fa05d">RotateDeg</a> (int aXYZ, double aDegrees, const double aP[3], double rP[3])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a point about the X axis by a specified amount.  <a href="#a2c859e8887f5adcb75ae2c43833fa05d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a62fd381bd5b3ded32492b41486f58bf3">RotateDeg</a> (const double aAxis[3], double aDegrees, const double aP[3], double rP[3])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a point about a specified axis by a specified amount.  <a href="#a62fd381bd5b3ded32492b41486f58bf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a99b9df77f69a9ad8e4f1efb04ff1be50">Identity</a> (int aNR, double *rI)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a square matrix to the identidy matrix: rI = I.  <a href="#a99b9df77f69a9ad8e4f1efb04ff1be50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a0a935fd55c109ad1751d308d1a7ac0ee">Add</a> (int aNR, int aNC, const double *aM1, const double *aM2, double *aM)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign all elements of a matrix to a specified value: rMij = aScalar.  <a href="#a0a935fd55c109ad1751d308d1a7ac0ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a67f289b99381c1cc63b21191b0c26a5a">Subtract</a> (int aNR, int aNC, const double *aM1, const double *aM2, double *aM)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract two matrices.  <a href="#a67f289b99381c1cc63b21191b0c26a5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a2bc39e8f77c1b8c312cfe078f9d99ef3">Multiply</a> (int aNR, int aNC, const double *aM, double aScalar, double *rM)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a matrix by a scalar.  <a href="#a2bc39e8f77c1b8c312cfe078f9d99ef3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a5c019658b8f4f306e0ac45c7b2fcff6d">Multiply</a> (int aNR1, int aNCR, int aNC2, const double *aM1, const double *aM2, double *aM)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two matrices.  <a href="#a5c019658b8f4f306e0ac45c7b2fcff6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#acbeaa0249243d9bd095ea59e48a76fc3">Invert</a> (int aN, const double *aM, double *aMInv)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the inverse of a matrix.  <a href="#acbeaa0249243d9bd095ea59e48a76fc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#af7b31ee051201f26c498e989aa1acecc">Transpose</a> (int aNR, int aNC, const double *aM, double *aMT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a matrix.  <a href="#af7b31ee051201f26c498e989aa1acecc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#ad32f90785839f91ab1ac25f304d5aa0f">Print</a> (int aNR, int aNC, const double *aM, int aPrecision=8)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print a matrix.  <a href="#ad32f90785839f91ab1ac25f304d5aa0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a71651dc65c06440d56ba3a2100be377a">FindIndex</a> (int aStartIndex, double aTime, int aNT, double *aT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starting at aIndex, move through the array aT and find the index of the element whose value is closest to but less than aTime.  <a href="#a71651dc65c06440d56ba3a2100be377a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a302c70a5d9ba007a09f9b846f4b6cde1">FindIndexLess</a> (int aNX, double *aX, double aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scan from the beginning of the array, aX, and find the index of the element such that the element's value is less than or equal to aValue and the next element's value is greater than aValue.  <a href="#a302c70a5d9ba007a09f9b846f4b6cde1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#aa1aa80053c392c58477e819d3232a356">FindIndexGreater</a> (int aNX, double *aX, double aValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scan from the end of the array, aX, and find the index of the element such that the element's value is greater than or equal to aValue and such that the next element's value is less than aValue.  <a href="#aa1aa80053c392c58477e819d3232a356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a5dadc16b30a301e6d5f4d33be48dbbb2">ComputeIndex</a> (int i2, int n1, int i1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the index for an element of a three dimensional matrix as though the matrix were laid out in one dimension.  <a href="#a5dadc16b30a301e6d5f4d33be48dbbb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a112d80e365d81646166369b9f8536742">ComputeIndex</a> (int i3, int n2, int i2, int n1, int i1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the index for an element of a three dimensional matrix as though the matrix were laid out in one dimension.  <a href="#a112d80e365d81646166369b9f8536742"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a4fb5eb079b4486b83b72f4864071442e">GetDim3</a> (int n3, int n2, int n1, int i2, int i1, double *m, double *a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get elements *,i2,i1 of a three dimensional matrix as an array, where * varies along the 3rd dimension, i2 the 2nd, and i1 the 1st.  <a href="#a4fb5eb079b4486b83b72f4864071442e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#aca80e1fd289956c355cc79cadc0d65ef">SetDim3</a> (int n3, int n2, int n1, int i2, int i1, double *m, double *a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> elements *,i2,i1 of a three dimensional matrix to the values in array a, where * varies along the 3rd dimension, i2 the 2nd, and i1 the 1st.  <a href="#aca80e1fd289956c355cc79cadc0d65ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a2ae48ae125e993afa6fc057c5182d5ba">EnsureWorkSpaceCapacity</a> (int aN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure that the work space is at least of size aN.  <a href="#a2ae48ae125e993afa6fc057c5182d5ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#ad3548b814bf1e50a858b02fdedbe495b">EnsurePointerSpaceCapacity</a> (int aN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure that the pointer spaces is at least of size aN.  <a href="#ad3548b814bf1e50a858b02fdedbe495b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Mtx.html#a3d27a729cb9b168e9df7a417911fa392">FreeWorkAndPointerSpaces</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the work and pointer spaces.  <a href="#a3d27a729cb9b168e9df7a417911fa392"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A class for performing vector and matrix operations. </p>
<p>Most all the methods in this class are static. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0a935fd55c109ad1751d308d1a7ac0ee"></a><!-- doxytag: member="OpenSim::Mtx::Add" ref="a0a935fd55c109ad1751d308d1a7ac0ee" args="(int aNR, int aNC, const double *aM1, const double *aM2, double *aM)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::Add </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aM1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aM2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aM</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign all elements of a matrix to a specified value: rMij = aScalar. </p>
<p>It is permissible for</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aNR</em>&nbsp;</td><td>Number of rows in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aNC</em>&nbsp;</td><td>Number of columns in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aScalar</em>&nbsp;</td><td>Scalar value to which to set the element of the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rM</em>&nbsp;</td><td>Ouput matrix (rMij = aScalar for all i,j). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error.</dd></dl>
<p>int <a class="el" href="classOpenSim_1_1Mtx.html" title="A class for performing vector and matrix operations.">Mtx</a>:: Assign(int aNR,int aNC,double aScalar,double *rM) { if(rM==NULL) return(-1); if(aNR&lt;=0) return(-1); if(aNC&lt;=0) return(-1);</p>
<p>ASSIGN int i,n=aNR*aNC; for(i=0;i&lt;n;i++,rM++) *rM = aScalar;</p>
<p>return(0); } _____________________________________________________________________________ /** Assign two matrices: rM = aM.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aNR</em>&nbsp;</td><td>Number of rows in the matrices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aNC</em>&nbsp;</td><td>Number of columns in the matrices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aM</em>&nbsp;</td><td>Input matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rM</em>&nbsp;</td><td>Ouput matrix (rM = aM). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error.</dd></dl>
<p>int <a class="el" href="classOpenSim_1_1Mtx.html" title="A class for performing vector and matrix operations.">Mtx</a>:: Assign(int aNR,int aNC,const double *aM,double *rM) { if(aM==NULL) return(-1); if(rM==NULL) return(-1); if(aNR&lt;=0) return(-1); if(aNC&lt;=0) return(-1);</p>
<p>ASSIGN int i,n=aNR*aNC; for(i=0;i&lt;n;i++,aM++,rM++) *rM = *aM;</p>
<p>return(0); } _____________________________________________________________________________ /** Add a scalar to a matrix.</p>
<p>If the arguments are not valid, then a -1 is returned. Othersise, 0 is returned.</p>
<p>It is permissible for aM to coincide with aM1.</p>
<p>int <a class="el" href="classOpenSim_1_1Mtx.html" title="A class for performing vector and matrix operations.">Mtx</a>:: Add(int aNR,int aNC,const double *aM1,double aScalar,double *aM) { if(aM1==NULL) return(-1); if(aM ==NULL) return(-1); if(aNR&lt;=0) return(-1); if(aNC&lt;=0) return(-1);</p>
<p>MULTIPLY int i,n=aNR*aNC; for(i=0;i&lt;n;i++,aM1++,aM++) *aM = *aM1 + aScalar;</p>
<p>return(0); } _____________________________________________________________________________ /** Add two matrices.</p>
<p>If the arguments are not valid, then a -1 is returned. Othersise, 0 is returned.</p>
<p>It is permissible for aM to coincide with either aM1 or aM2. </p>

</div>
</div>
<a class="anchor" id="a84a9f672c7a4b1947d1d1a8444f0cc43"></a><!-- doxytag: member="OpenSim::Mtx::Angle" ref="a84a9f672c7a4b1947d1d1a8444f0cc43" args="(const SimTK::Vec3 &amp;aV1, const SimTK::Vec3 &amp;aV2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenSim::Mtx::Angle </td>
          <td>(</td>
          <td class="paramtype">const SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>aV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>aV2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the angle between two vectors: theta = acos( aV1*aV2/(|aV1|*|aV2|)). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aV1</em>&nbsp;</td><td>Vector 1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aV2</em>&nbsp;</td><td>Vector 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Angle between two vectors in radians. </dd></dl>

</div>
</div>
<a class="anchor" id="a112d80e365d81646166369b9f8536742"></a><!-- doxytag: member="OpenSim::Mtx::ComputeIndex" ref="a112d80e365d81646166369b9f8536742" args="(int i3, int n2, int i2, int n1, int i1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::ComputeIndex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the index for an element of a three dimensional matrix as though the matrix were laid out in one dimension. </p>

</div>
</div>
<a class="anchor" id="a5dadc16b30a301e6d5f4d33be48dbbb2"></a><!-- doxytag: member="OpenSim::Mtx::ComputeIndex" ref="a5dadc16b30a301e6d5f4d33be48dbbb2" args="(int i2, int n1, int i1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::ComputeIndex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the index for an element of a three dimensional matrix as though the matrix were laid out in one dimension. </p>

</div>
</div>
<a class="anchor" id="acd63b086de1a6a4abf580a4eb57ec8cf"></a><!-- doxytag: member="OpenSim::Mtx::CrossProduct" ref="acd63b086de1a6a4abf580a4eb57ec8cf" args="(SimTK::Vec3 &amp;aV1, SimTK::Vec3 &amp;aV2, SimTK::Vec3 &amp;aV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Mtx::CrossProduct </td>
          <td>(</td>
          <td class="paramtype">SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>aV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>aV2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>aV</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the cross product of two vectors. </p>
<p>If the arguments are not valid (aR=aS=NULL), -1 is returned. </p>

</div>
</div>
<a class="anchor" id="a1b19c5bf6aa788d41143e26f6c5eceef"></a><!-- doxytag: member="OpenSim::Mtx::DotProduct" ref="a1b19c5bf6aa788d41143e26f6c5eceef" args="(int aN, const SimTK::Vec3 &amp;aV1, const SimTK::Vec3 &amp;aV2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenSim::Mtx::DotProduct </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>aV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>aV2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the dot product of two vectors. </p>
<p>If the arguments are not valid (aV1=aV2=NULL), 0.0 is returned. </p>

</div>
</div>
<a class="anchor" id="ad3548b814bf1e50a858b02fdedbe495b"></a><!-- doxytag: member="OpenSim::Mtx::EnsurePointerSpaceCapacity" ref="ad3548b814bf1e50a858b02fdedbe495b" args="(int aN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::EnsurePointerSpaceCapacity </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensure that the pointer spaces is at least of size aN. </p>
<p>If the capacity could not be increased to aN, -1 is returned. Otherwise, 0 is returned. </p>

</div>
</div>
<a class="anchor" id="a2ae48ae125e993afa6fc057c5182d5ba"></a><!-- doxytag: member="OpenSim::Mtx::EnsureWorkSpaceCapacity" ref="a2ae48ae125e993afa6fc057c5182d5ba" args="(int aN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::EnsureWorkSpaceCapacity </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ensure that the work space is at least of size aN. </p>
<p>If the capacity could not be increased to aN, -1 is returned. Otherwise, 0 is returned. </p>

</div>
</div>
<a class="anchor" id="a71651dc65c06440d56ba3a2100be377a"></a><!-- doxytag: member="OpenSim::Mtx::FindIndex" ref="a71651dc65c06440d56ba3a2100be377a" args="(int aStartIndex, double aTime, int aNT, double *aT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::FindIndex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starting at aIndex, move through the array aT and find the index of the element whose value is closest to but less than aTime. </p>
<p>It is assumed that the array aT is monotonically increasing and has at least 2 elements.</p>
<p>If aTime lies outside the interval of aT, the index of either the first point or second to last point is returned depending on whether aTime is below or above the interval of aT.</p>
<p>-1 is if an error is encountered. </p>

</div>
</div>
<a class="anchor" id="aa1aa80053c392c58477e819d3232a356"></a><!-- doxytag: member="OpenSim::Mtx::FindIndexGreater" ref="aa1aa80053c392c58477e819d3232a356" args="(int aNX, double *aX, double aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::FindIndexGreater </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan from the end of the array, aX, and find the index of the element such that the element's value is greater than or equal to aValue and such that the next element's value is less than aValue. </p>
<p>If no value in the array is less than aValue, the index of the first element in the array is returned.</p>
<p>If no value in the array is greater than or equal to aValue, -1 is returned. </p>

</div>
</div>
<a class="anchor" id="a302c70a5d9ba007a09f9b846f4b6cde1"></a><!-- doxytag: member="OpenSim::Mtx::FindIndexLess" ref="a302c70a5d9ba007a09f9b846f4b6cde1" args="(int aNX, double *aX, double aValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::FindIndexLess </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan from the beginning of the array, aX, and find the index of the element such that the element's value is less than or equal to aValue and the next element's value is greater than aValue. </p>
<p>If no value in the array is greater than aValue, the index of the last element in the array is returned.</p>
<p>If no value in the array is less than or equal to aValue, -1 is returned. </p>

</div>
</div>
<a class="anchor" id="a3d27a729cb9b168e9df7a417911fa392"></a><!-- doxytag: member="OpenSim::Mtx::FreeWorkAndPointerSpaces" ref="a3d27a729cb9b168e9df7a417911fa392" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mtx::FreeWorkAndPointerSpaces </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the work and pointer spaces. </p>

</div>
</div>
<a class="anchor" id="a4fb5eb079b4486b83b72f4864071442e"></a><!-- doxytag: member="OpenSim::Mtx::GetDim3" ref="a4fb5eb079b4486b83b72f4864071442e" args="(int n3, int n2, int n1, int i2, int i1, double *m, double *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mtx::GetDim3 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>a</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get elements *,i2,i1 of a three dimensional matrix as an array, where * varies along the 3rd dimension, i2 the 2nd, and i1 the 1st. </p>
<p>The first dimension is the dimension which varies most rapidly when the data is laid out in a one dimensional array, and the second dimension is the one which varies second most rapidly, and so on.</p>
<p>For now, it is assumed that parameter a has enough memory allocated to hold the array. </p>

</div>
</div>
<a class="anchor" id="a99b9df77f69a9ad8e4f1efb04ff1be50"></a><!-- doxytag: member="OpenSim::Mtx::Identity" ref="a99b9df77f69a9ad8e4f1efb04ff1be50" args="(int aNR, double *rI)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::Identity </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>rI</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a square matrix to the identidy matrix: rI = I. </p>
<p>The matrix must be square.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aN</em>&nbsp;</td><td>Dimension of the matrix (aN=nRows, aN=nCols). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rI</em>&nbsp;</td><td>Ouput identity matrix (rI = I). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a29291590ff292de2dfd877bd609a8a5d"></a><!-- doxytag: member="OpenSim::Mtx::Interpolate" ref="a29291590ff292de2dfd877bd609a8a5d" args="(double aT1, double aY1, double aT2, double aY2, double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Mtx::Interpolate </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aY1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aY2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Linearly interpolate or extrapolate two data points. </p>

</div>
</div>
<a class="anchor" id="a19cff909fc23ce8082a8baf36b6d9acd"></a><!-- doxytag: member="OpenSim::Mtx::Interpolate" ref="a19cff909fc23ce8082a8baf36b6d9acd" args="(int aN, double aT1, double *aY1, double aT2, double *aY2, double t, double *aY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mtx::Interpolate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aY1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aT2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aY2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aY</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Linearly interpolate or extrapolate an array of data. </p>

</div>
</div>
<a class="anchor" id="acbeaa0249243d9bd095ea59e48a76fc3"></a><!-- doxytag: member="OpenSim::Mtx::Invert" ref="acbeaa0249243d9bd095ea59e48a76fc3" args="(int aN, const double *aM, double *aMInv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::Invert </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>rMInv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the inverse of a matrix. </p>
<p>If the arguments are not valid (aM==NULL), then -1 is returned. If the matrix is not invertible, then -2 is returned. Othersise, 0 is returned.</p>
<p>It is permissible for aM to overlap in memory with aMInv. </p>

</div>
</div>
<a class="anchor" id="a6f18fdb7caa4dbca057740d46782ea74"></a><!-- doxytag: member="OpenSim::Mtx::Magnitude" ref="a6f18fdb7caa4dbca057740d46782ea74" args="(int aN, const SimTK::Vec3 &amp;aV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenSim::Mtx::Magnitude </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>aV</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the magnitude of a vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aV</em>&nbsp;</td><td>Vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Square root of the dot product aV*aV. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c019658b8f4f306e0ac45c7b2fcff6d"></a><!-- doxytag: member="OpenSim::Mtx::Multiply" ref="a5c019658b8f4f306e0ac45c7b2fcff6d" args="(int aNR1, int aNCR, int aNC2, const double *aM1, const double *aM2, double *aM)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::Multiply </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNR1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNCR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNC2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aM1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aM2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>rM</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply two matrices. </p>
<p>If the arguments are not valid (aM1,aM2,aM==NULL), then a -1 is returned. Othersise, 0 is returned.</p>
<p>It is permissible for aM to overlap with either aM1 or aM2. </p>

</div>
</div>
<a class="anchor" id="a2bc39e8f77c1b8c312cfe078f9d99ef3"></a><!-- doxytag: member="OpenSim::Mtx::Multiply" ref="a2bc39e8f77c1b8c312cfe078f9d99ef3" args="(int aNR, int aNC, const double *aM, double aScalar, double *rM)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::Multiply </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aScalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>rM</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply a matrix by a scalar. </p>
<p>It is permissible for aM and rM to coincide in memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aNR</em>&nbsp;</td><td>Number of rows in aM. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aNC</em>&nbsp;</td><td>Number of columns in aM. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aM</em>&nbsp;</td><td>Matirx laid out in memory as aM[aNR][aNC]. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aScalar</em>&nbsp;</td><td>Scalar value by which to multiply aM. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rM</em>&nbsp;</td><td>Result of aScalar * aM. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 if an error is encountered, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5f53c31a9f74dc8408711d857e08015"></a><!-- doxytag: member="OpenSim::Mtx::Normalize" ref="ad5f53c31a9f74dc8408711d857e08015" args="(int aN, const SimTK::Vec3 &amp;aV, SimTK::Vec3 &amp;rV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenSim::Mtx::Normalize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>aV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>rV</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize a vector. </p>
<p>If aV has a magnitude of zero, all elements of rV are set to 0.0. It is permissible for aV and rV to coincide in memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aV</em>&nbsp;</td><td>Vector to be normalized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rV</em>&nbsp;</td><td>Result of the normalization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Magnitude of aV. </dd></dl>

</div>
</div>
<a class="anchor" id="a14cafdebc8ee9c3dca9bd2b249589ba4"></a><!-- doxytag: member="OpenSim::Mtx::PerpendicularUnitVector" ref="a14cafdebc8ee9c3dca9bd2b249589ba4" args="(SimTK::Vec3 &amp;aV, SimTK::Vec3 &amp;rV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Mtx::PerpendicularUnitVector </td>
          <td>(</td>
          <td class="paramtype">SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>aV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimTK::Vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>rV</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a unit vector that is perpendicular to a specified vector. </p>
<p>The unit vector is arbitrary, in the sense that it is one of an infinite number of vectors that are perpendicular to the original specified vector.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aV</em>&nbsp;</td><td>Input vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rV</em>&nbsp;</td><td>Perpendicular unit vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad32f90785839f91ab1ac25f304d5aa0f"></a><!-- doxytag: member="OpenSim::Mtx::Print" ref="ad32f90785839f91ab1ac25f304d5aa0f" args="(int aNR, int aNC, const double *aM, int aPrecision=8)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mtx::Print </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aPrecision</em> = <code>8</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print a matrix. </p>

</div>
</div>
<a class="anchor" id="aac95571668b93346367715dbea233ba5"></a><!-- doxytag: member="OpenSim::Mtx::Rotate" ref="aac95571668b93346367715dbea233ba5" args="(const double aAxis[3], double aRadians, const double aP[3], double rP[3])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mtx::Rotate </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>aAxis</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aRadians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>aP</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rP</em>[3]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a point about a specified axis by a specified amount. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aAxis</em>&nbsp;</td><td>Axis about which to rotate. The axis is not assumed to be a unit vector; however, if the axis is the zero vector, no rotation is performed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aRadians</em>&nbsp;</td><td>Amount of rotation in radians. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aP</em>&nbsp;</td><td>Point to rotate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rP</em>&nbsp;</td><td>Rotated point. aP and rP may coincide in memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4a8376ed67d59beb8bbac20b0351728"></a><!-- doxytag: member="OpenSim::Mtx::Rotate" ref="aa4a8376ed67d59beb8bbac20b0351728" args="(int aXYZ, double aRadians, const double aP[3], double rP[3])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mtx::Rotate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aXYZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aRadians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>aP</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rP</em>[3]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a point about the X, Y, or Z axis by a specified amount. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aXYZ</em>&nbsp;</td><td>Specify whether to rotate about the X (aXYZ=0), Y (aXYZ=1), or Z (aXYZ=2) axes. If aXYZ is not 0, 1, or 2, no rotation is performed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aRadians</em>&nbsp;</td><td>Amount of rotation in radians. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aP</em>&nbsp;</td><td>Point to rotate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rP</em>&nbsp;</td><td>Rotated point. aP and rP may coincide in memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62fd381bd5b3ded32492b41486f58bf3"></a><!-- doxytag: member="OpenSim::Mtx::RotateDeg" ref="a62fd381bd5b3ded32492b41486f58bf3" args="(const double aAxis[3], double aDegrees, const double aP[3], double rP[3])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mtx::RotateDeg </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>aAxis</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aDegrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>aP</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rP</em>[3]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a point about a specified axis by a specified amount. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aAxis</em>&nbsp;</td><td>Axis about which to rotate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aDegrees</em>&nbsp;</td><td>Amount of rotation in degrees. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aP</em>&nbsp;</td><td>Point to rotate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rP</em>&nbsp;</td><td>Rotated point. aP and rP may coincide in memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c859e8887f5adcb75ae2c43833fa05d"></a><!-- doxytag: member="OpenSim::Mtx::RotateDeg" ref="a2c859e8887f5adcb75ae2c43833fa05d" args="(int aXYZ, double aDegrees, const double aP[3], double rP[3])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mtx::RotateDeg </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aXYZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aDegrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>aP</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rP</em>[3]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate a point about the X axis by a specified amount. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aXYZ</em>&nbsp;</td><td>Specify whether to rotate about the X (aXYZ=0), Y (aXYZ=1), or Z (aXYZ=2) axis. If aXYZ is not 0, 1, or 2, no rotation is performed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aDegrees</em>&nbsp;</td><td>Amount of rotation in degrees. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aP</em>&nbsp;</td><td>Point to rotate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rP</em>&nbsp;</td><td>Rotated point. aP and rP may coincide in memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca80e1fd289956c355cc79cadc0d65ef"></a><!-- doxytag: member="OpenSim::Mtx::SetDim3" ref="aca80e1fd289956c355cc79cadc0d65ef" args="(int n3, int n2, int n1, int i2, int i1, double *m, double *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mtx::SetDim3 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>a</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> elements *,i2,i1 of a three dimensional matrix to the values in array a, where * varies along the 3rd dimension, i2 the 2nd, and i1 the 1st. </p>
<p>The first dimension is the dimension which varies most rapidly when the data is laid out in a one dimensional array, and the second dimension is the one which varies second most rapidly, and so on. </p>

</div>
</div>
<a class="anchor" id="a67f289b99381c1cc63b21191b0c26a5a"></a><!-- doxytag: member="OpenSim::Mtx::Subtract" ref="a67f289b99381c1cc63b21191b0c26a5a" args="(int aNR, int aNC, const double *aM1, const double *aM2, double *aM)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::Subtract </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aM1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aM2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>aM</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract two matrices. </p>
<p>If the arguments are not valid, then a -1 is returned. Othersise, 0 is returned.</p>
<p>It is permissible for aM to coincide with either aM1 or aM2. aM1 - aM2 </p>

</div>
</div>
<a class="anchor" id="a09bb683efbc7e0d210104340b24b82a0"></a><!-- doxytag: member="OpenSim::Mtx::Translate" ref="a09bb683efbc7e0d210104340b24b82a0" args="(double aX, double aY, double aZ, const double aP[3], double rP[3])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mtx::Translate </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>aZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>aP</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rP</em>[3]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translate a point by a specified amount. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aX</em>&nbsp;</td><td>Amount to translate in the X direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aY</em>&nbsp;</td><td>Amount to translate in the Y direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aZ</em>&nbsp;</td><td>Amount to translate in the Z direction. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aP</em>&nbsp;</td><td>Point to translate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rP</em>&nbsp;</td><td>Translated point. aP and rP may coincide in memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7b31ee051201f26c498e989aa1acecc"></a><!-- doxytag: member="OpenSim::Mtx::Transpose" ref="af7b31ee051201f26c498e989aa1acecc" args="(int aNR, int aNC, const double *aM, double *aMT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Mtx::Transpose </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>aNC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>aM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>rMT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transpose a matrix. </p>
<p>If the arguments are invalid (e.g.,aM==NULL), then a -1 is returned. Othersise, 0 is returned.</p>
<p>It is permissible for aM to overlap in memory with aMT. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>OpenSim/Common/Mtx.h</li>
<li>OpenSim/Common/Mtx.cpp</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Sep 25 00:19:48 2011 for OpenSim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
