package org.opensim.functioneditor;

import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.event.ItemEvent;
import java.awt.geom.Ellipse2D;
import java.io.Serializable;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Observable;
import java.util.Observer;
import javax.swing.event.EventListenerList;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.plot.CrosshairState;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRendererState;
import org.jfree.data.Range;
import org.jfree.data.xy.XYDataItem;
import org.jfree.data.xy.XYDataset;
import org.jfree.data.xy.XYSeriesCollection;
import org.openide.ErrorManager;
import org.openide.util.NbBundle;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;
import org.opensim.modeling.Function;
import org.opensim.modeling.Model;
import org.opensim.modeling.OpenSimObject;

/**
 * Top component which displays something.
 */
final public class FunctionEditorTopComponent extends TopComponent implements Observer {
    
   private static FunctionEditorTopComponent instance;
   /** path to the icon used by the component and its open action */
//   static final String ICON_PATH = "SET/PATH/TO/ICON/HERE";

   private static final String PREFERRED_ID = "FunctionEditorTopComponent";

   private JFreeChart chart = null;
   private FunctionPanel functionPanel = null;
   private FunctionRenderer renderer = null;
   private Function function = null;
   private String functionTitle = null;
   private String functionXLabel = null;
   private String functionYLabel = null;
   private Function savedFunction = null;
   private Model model = null; // the model this function is from
   private OpenSimObject object = null; // the object (muscle, joint, etc.) this function is from
   private FunctionXYSeries xySeries = null;
   private XYPlot xyPlot = null;
   private XYDataset xyDataset = null;
   private ArrayList<Integer> selectedNodes = new ArrayList<Integer>(0);
   private NumberFormat coordinatesFormat = new DecimalFormat("0.00000");
   private Paint highlightPaint = Color.YELLOW;
   private boolean pendingChanges = false;

   /** Storage for registered change listeners. */
   private transient EventListenerList listenerList;

   private FunctionEditorTopComponent() {
      initComponents();
      setName(NbBundle.getMessage(FunctionEditorTopComponent.class, "CTL_FunctionEditorTopComponent"));
      setToolTipText(NbBundle.getMessage(FunctionEditorTopComponent.class, "HINT_FunctionEditorTopComponent"));
//      setIcon(Utilities.loadImage(ICON_PATH, true));
      this.listenerList = new EventListenerList();
      setupComponent();
   }

   // TODO: there is currently no way to clear the function editor
   // (remove the current function), so there's no way to tell when
   // to remove FunctionChangeListeners. So for now, allow only one,
   // which is replaced every time the editor is set to a new function.
   public void addChangeListener(FunctionChangeListener listener) {
      this.listenerList = new EventListenerList();
      this.listenerList.add(FunctionChangeListener.class, listener);
   }

   public void removeChangeListener(FunctionChangeListener listener) {
      this.listenerList.remove(FunctionChangeListener.class, listener);
   }

   public void notifyListeners(FunctionChangeEvent event) {
       Object[] listeners = this.listenerList.getListenerList();
       for (int i = listeners.length - 2; i >= 0; i -= 2) {
           if (listeners[i] == FunctionChangeListener.class) {
               ((FunctionChangeListener) listeners[i + 1]).functionChanged(event);
           }
       }
   }

   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      FunctionEditorScrollPane = new javax.swing.JScrollPane();
      FunctionEditorPanel = new javax.swing.JPanel();
      xValueTextField = new javax.swing.JTextField();
      functionDescriptionLabel = new javax.swing.JLabel();
      functionJPanel = new javax.swing.JPanel();
      xValueLabel = new javax.swing.JLabel();
      yValueLabel = new javax.swing.JLabel();
      yValueTextField = new javax.swing.JTextField();
      typeLabel = new javax.swing.JLabel();
      typeComboBox = new javax.swing.JComboBox();
      backupFunctionButton = new javax.swing.JButton();
      restoreFunctionButton = new javax.swing.JButton();
      crosshairsCheckBox = new javax.swing.JCheckBox();

      xValueTextField.setMaximumSize(new java.awt.Dimension(100, 21));
      xValueTextField.setMinimumSize(new java.awt.Dimension(100, 21));
      xValueTextField.setPreferredSize(new java.awt.Dimension(100, 21));
      xValueTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            xValueActionPerformed(evt);
         }
      });
      xValueTextField.addFocusListener(new java.awt.event.FocusAdapter() {
         public void focusLost(java.awt.event.FocusEvent evt) {
            xValueFocusLost(evt);
         }
      });

      functionDescriptionLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
      org.openide.awt.Mnemonics.setLocalizedText(functionDescriptionLabel, "function name");

      functionJPanel.setMinimumSize(new java.awt.Dimension(25, 25));
      org.jdesktop.layout.GroupLayout functionJPanelLayout = new org.jdesktop.layout.GroupLayout(functionJPanel);
      functionJPanel.setLayout(functionJPanelLayout);
      functionJPanelLayout.setHorizontalGroup(
         functionJPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 493, Short.MAX_VALUE)
      );
      functionJPanelLayout.setVerticalGroup(
         functionJPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 234, Short.MAX_VALUE)
      );

      org.openide.awt.Mnemonics.setLocalizedText(xValueLabel, "X");

      org.openide.awt.Mnemonics.setLocalizedText(yValueLabel, "Y");

      yValueTextField.setMaximumSize(new java.awt.Dimension(100, 21));
      yValueTextField.setMinimumSize(new java.awt.Dimension(100, 21));
      yValueTextField.setPreferredSize(new java.awt.Dimension(100, 21));
      yValueTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            yValueActionPerformed(evt);
         }
      });
      yValueTextField.addFocusListener(new java.awt.event.FocusAdapter() {
         public void focusLost(java.awt.event.FocusEvent evt) {
            yValueFocusLost(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(typeLabel, "Type:");

      typeComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "natCubicSpline", "GCVSpline", "StepFunction", "LinearFunction" }));
      typeComboBox.setMaximumSize(new java.awt.Dimension(125, 24));
      typeComboBox.setMinimumSize(new java.awt.Dimension(125, 24));
      typeComboBox.setPreferredSize(new java.awt.Dimension(125, 24));
      typeComboBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            typeComboBoxActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(backupFunctionButton, "Backup function");
      backupFunctionButton.setMaximumSize(new java.awt.Dimension(125, 25));
      backupFunctionButton.setMinimumSize(new java.awt.Dimension(125, 25));
      backupFunctionButton.setPreferredSize(new java.awt.Dimension(125, 25));
      backupFunctionButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            backupFunctionActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(restoreFunctionButton, "Restore function");
      restoreFunctionButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            restoreFunctionActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(crosshairsCheckBox, "Crosshairs");
      crosshairsCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      crosshairsCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      crosshairsCheckBox.addItemListener(new java.awt.event.ItemListener() {
         public void itemStateChanged(java.awt.event.ItemEvent evt) {
            crosshairsCheckBoxStateChanged(evt);
         }
      });

      org.jdesktop.layout.GroupLayout FunctionEditorPanelLayout = new org.jdesktop.layout.GroupLayout(FunctionEditorPanel);
      FunctionEditorPanel.setLayout(FunctionEditorPanelLayout);
      FunctionEditorPanelLayout.setHorizontalGroup(
         FunctionEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(FunctionEditorPanelLayout.createSequentialGroup()
            .add(FunctionEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(FunctionEditorPanelLayout.createSequentialGroup()
                  .addContainerGap()
                  .add(typeLabel)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(typeComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .add(41, 41, 41)
                  .add(backupFunctionButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .add(34, 34, 34)
                  .add(restoreFunctionButton))
               .add(FunctionEditorPanelLayout.createSequentialGroup()
                  .add(90, 90, 90)
                  .add(functionDescriptionLabel))
               .add(FunctionEditorPanelLayout.createSequentialGroup()
                  .addContainerGap()
                  .add(FunctionEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(FunctionEditorPanelLayout.createSequentialGroup()
                        .add(10, 10, 10)
                        .add(xValueLabel)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(xValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(21, 21, 21)
                        .add(yValueLabel)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(yValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(28, 28, 28)
                        .add(crosshairsCheckBox))
                     .add(functionJPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
            .addContainerGap())
      );
      FunctionEditorPanelLayout.setVerticalGroup(
         FunctionEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(FunctionEditorPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(functionDescriptionLabel)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(functionJPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(FunctionEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(xValueLabel)
               .add(xValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(yValueLabel)
               .add(yValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(crosshairsCheckBox))
            .add(36, 36, 36)
            .add(FunctionEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(restoreFunctionButton)
               .add(typeComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(typeLabel)
               .add(backupFunctionButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addContainerGap())
      );
      FunctionEditorScrollPane.setViewportView(FunctionEditorPanel);

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(FunctionEditorScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 519, Short.MAX_VALUE)
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(FunctionEditorScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 374, Short.MAX_VALUE)
      );
   }// </editor-fold>//GEN-END:initComponents

   private void crosshairsCheckBoxStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_crosshairsCheckBoxStateChanged
      if (function != null && functionPanel != null) {
         if (evt.getStateChange() == ItemEvent.SELECTED)
            functionPanel.setMandatoryCrosshairs(true);
         else
            functionPanel.setMandatoryCrosshairs(false);
      }
   }//GEN-LAST:event_crosshairsCheckBoxStateChanged

   private void restoreFunctionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_restoreFunctionActionPerformed
      Function func = function;
      // function must be set to null before calling replaceFunction, but I'm not sure why.
      function = null;
      notifyListeners(new FunctionChangeEvent(model, object, func, savedFunction));
      restoreFunction();
      setupComponent();
      setPendingChanges(false, true);
      functionJPanel.validate();
      this.repaint();
   }//GEN-LAST:event_restoreFunctionActionPerformed

   private void backupFunctionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_backupFunctionActionPerformed
      backupFunction();
      setPendingChanges(false, true);
   }//GEN-LAST:event_backupFunctionActionPerformed

    private void typeComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_typeComboBoxActionPerformed
      if (function == null)
         return;
      String nameOfNewType = typeComboBox.getSelectedItem().toString();
      Function newFunction = Function.makeFunctionOfType(function, nameOfNewType);
      if (newFunction == null) {
         int foo = 3;
         return;
      }
      //TODO: put the following lines in a function? in functionPanel? backup other quantities?
      Range domainRange = functionPanel.getChart().getXYPlot().getDomainAxis().getRange();
      boolean domainAuto = functionPanel.getChart().getXYPlot().getDomainAxis().isAutoRange();
      Range rangeRange = functionPanel.getChart().getXYPlot().getRangeAxis().getRange();
      boolean rangeAuto = functionPanel.getChart().getXYPlot().getRangeAxis().isAutoRange();
      Function func = function;
      function = newFunction;
      notifyListeners(new FunctionChangeEvent(model, object, func, newFunction));
      clearSelectedNodes();
      setupComponent();
      setPendingChanges(true, true);
      functionPanel.getChart().getXYPlot().getDomainAxis().setRange(domainRange);
      functionPanel.getChart().getXYPlot().getDomainAxis().setAutoRange(domainAuto);
      functionPanel.getChart().getXYPlot().getRangeAxis().setRange(rangeRange);
      functionPanel.getChart().getXYPlot().getRangeAxis().setAutoRange(rangeAuto);
      functionJPanel.validate();
      this.repaint();

    }//GEN-LAST:event_typeComboBoxActionPerformed

    private void yValueFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_yValueFocusLost
    if (!evt.isTemporary())
       yValueEntered((javax.swing.JTextField)evt.getSource());
    }//GEN-LAST:event_yValueFocusLost

    private void yValueActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_yValueActionPerformed
        yValueEntered((javax.swing.JTextField)evt.getSource());
    }//GEN-LAST:event_yValueActionPerformed

    private void yValueEntered(javax.swing.JTextField field) {
       // TODO: check old value of each selected point to see if anything really changes
       if (field.getText().length() > 0) {
          double newValue = Double.parseDouble(field.getText());
          field.setText(coordinatesFormat.format(newValue));
          for (int i=0; i<selectedNodes.size(); i++) {
             int index = selectedNodes.get(i).intValue();
             function.setY(index, newValue);
             xySeries.updateByIndex(index, newValue);
          }
          setPendingChanges(true, true);
       }
    }

    private void xValueFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_xValueFocusLost
    if (!evt.isTemporary())
       xValueEntered((javax.swing.JTextField)evt.getSource());
    }//GEN-LAST:event_xValueFocusLost

    private void xValueActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_xValueActionPerformed
        xValueEntered((javax.swing.JTextField)evt.getSource());
    }//GEN-LAST:event_xValueActionPerformed

    private void xValueEntered(javax.swing.JTextField field) {
       // TODO: check old value of each selected point to see if anything really changes
       if (field.getText().length() > 0) {
          double newValue = Double.parseDouble(field.getText());
          field.setText(coordinatesFormat.format(newValue));
          for (int i=0; i<selectedNodes.size(); i++) {
             int index = selectedNodes.get(i).intValue();
             function.setX(index, newValue);
             xySeries.updateByIndex(index, newValue, function.getY(index));
          }
          setPendingChanges(true, true);
       }
    }
 
   private void setPendingChanges(boolean state, boolean update) {
      pendingChanges = state;

      if (update)
         updateBackupRestoreButtons();

      // Call a callback so the model knows about the change, e.g.
      // 1. mark the model dirty
      // 2. mark joint transforms dirty
      // The FunctionChangeListener is called before setPendingChanges; should
      // that function mark the model as dirty? Is the listener called for
      // every function change event? TODO
      // Mark the model as dirty as well.
      if (state == true && model != null) {
         //SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(model);
         //guiElem.setUnsavedChangesFlag(true);
      }

      // This is a bit of a hack, but you want to return focus to the
      // editing panel after buttons are pressed, numbers are entered, etc.
      // Basically, after anything changes in the editor window. This is
      // so that you can ctrl-click on nodes to select them without first
      // having to click on the editing panel to give it keyboard focus.
      //if (function != null && functionPanel != null)
         //functionPanel.requestFocusInWindow();
   }

   private void updateBackupRestoreButtons() {
      if (restoreFunctionButton.isEnabled() != pendingChanges)
         restoreFunctionButton.setEnabled(pendingChanges);
      if (backupFunctionButton.isEnabled() != pendingChanges)
         backupFunctionButton.setEnabled(pendingChanges);
   }

   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JPanel FunctionEditorPanel;
   private javax.swing.JScrollPane FunctionEditorScrollPane;
   private javax.swing.JButton backupFunctionButton;
   private javax.swing.JCheckBox crosshairsCheckBox;
   private javax.swing.JLabel functionDescriptionLabel;
   private javax.swing.JPanel functionJPanel;
   private javax.swing.JButton restoreFunctionButton;
   private javax.swing.JComboBox typeComboBox;
   private javax.swing.JLabel typeLabel;
   private javax.swing.JLabel xValueLabel;
   private javax.swing.JTextField xValueTextField;
   private javax.swing.JLabel yValueLabel;
   private javax.swing.JTextField yValueTextField;
   // End of variables declaration//GEN-END:variables
   
   /**
    * Gets default instance. Do not use directly: reserved for *.settings files only,
    * i.e. deserialization routines; otherwise you could get a non-deserialized instance.
    * To obtain the singleton instance, use {@link findInstance}.
    */
   public static synchronized FunctionEditorTopComponent getDefault() {
       if (instance == null) {
           instance = new FunctionEditorTopComponent();
       }
       return instance;
   }
   
   /**
    * Obtain the FunctionEditorTopComponent instance. Never call {@link #getDefault} directly!
    */
   public static synchronized FunctionEditorTopComponent findInstance() {
       TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
       if (win == null) {
           ErrorManager.getDefault().log(ErrorManager.WARNING, "Cannot find FunctionEditor component. It will not be located properly in the window system.");
           return getDefault();
       }
       if (win instanceof FunctionEditorTopComponent) {
           return (FunctionEditorTopComponent)win;
       }
       ErrorManager.getDefault().log(ErrorManager.WARNING, "There seem to be multiple components with the '" + PREFERRED_ID + "' ID. That is a potential source of errors and unexpected behavior.");
       return getDefault();
   }
   
   public int getPersistenceType() {
       return TopComponent.PERSISTENCE_ALWAYS;
   }
   
   public void componentOpened() {
       // TODO add custom code on component opening
   }
   
   public void componentClosed() {
       // TODO add custom code on component closing
   }
   
   /** replaces this in object stream */
   public Object writeReplace() {
       return new ResolvableHelper();
   }
   
   protected String preferredID() {
       return PREFERRED_ID;
   }
   
   final static class ResolvableHelper implements Serializable {
       private static final long serialVersionUID = 1L;
       public Object readResolve() {
           return FunctionEditorTopComponent.getDefault();
       }
   }
   public void update(Observable o, Object arg) {
   }

   public void setupComponent() {
      // Remove the prior FunctionPanel, if any
      functionJPanel.removeAll();

      if (function != null) {
         XYSeriesCollection seriesCollection = new XYSeriesCollection();
         xySeries = new FunctionXYSeries("function");
         for (int i=0; i<function.getNumberOfPoints(); i++) {
            xySeries.add(new XYDataItem(function.getX(i), function.getY(i)));
         }
         seriesCollection.addSeries(xySeries);
         chart = ChartFactory.createXYLineChart(
            "",
            functionXLabel,
            functionYLabel,
            seriesCollection,
            org.jfree.chart.plot.PlotOrientation.VERTICAL,
            true,
            true,
            false);
         xyPlot = chart.getXYPlot();
         xyDataset = xyPlot.getDataset();
         renderer = new FunctionRenderer(function);
         Shape circle = new Ellipse2D.Float(-3, -3, 6, 6);
         renderer.setBaseShapesVisible(true);
         renderer.setBaseShapesFilled(true);
         renderer.setSeriesShape(0, circle);
         renderer.setBaseSeriesVisibleInLegend(false);
         renderer.setDrawOutlines(true);
         renderer.setUseFillPaint(true);
         renderer.setSeriesStroke(0, new BasicStroke(1.5f));
         renderer.setSeriesOutlineStroke(0, new BasicStroke(1.0f));
         renderer.setFunctionPaint(0, Color.BLUE);
         renderer.setFunctionDefaultFillPaint(0, Color.WHITE);
         renderer.setFunctionHighlightFillPaint(0, Color.YELLOW);
         ValueAxis va = xyPlot.getRangeAxis();
         if (va instanceof NumberAxis) {
            NumberAxis na = (NumberAxis) va;
            na.setAutoRangeIncludesZero(false);
            na.setAutoRangeStickyZero(false);
            xyPlot.setRangeAxis(na);
         }
         xyPlot.setRenderer(renderer);
         functionPanel = new FunctionPanel(chart);
         functionJPanel.setLayout(new BorderLayout());
         functionJPanel.add(functionPanel);
         //functionPanel.requestFocusInWindow();
         backupFunctionButton.setEnabled(true);
         restoreFunctionButton.setEnabled(true);
         // TODO: set typeComboBox to proper setting!!!
         typeComboBox.setEnabled(true);
         xValueTextField.setEnabled(true);
         yValueTextField.setEnabled(true);
         crosshairsCheckBox.setEnabled(true);
         functionDescriptionLabel.setText(functionTitle);
      } else {
         backupFunctionButton.setEnabled(false);
         restoreFunctionButton.setEnabled(false);
         typeComboBox.setEnabled(false);
         xValueTextField.setEnabled(false);
         yValueTextField.setEnabled(false);
         crosshairsCheckBox.setEnabled(false);
         functionDescriptionLabel.setText("");
      }

      Dimension d = new Dimension(500, 430);
      FunctionEditorPanel.setPreferredSize(d);
   }

   public void open(Model model, OpenSimObject object, Function function, String functionTitle,
                    String functionXLabel, String functionYLabel) {
      this.model = model;
      this.object = object;
      this.function = function;
      this.functionTitle = functionTitle;
      this.functionXLabel = functionXLabel;
      this.functionYLabel = functionYLabel;
      setupComponent();
      setPendingChanges(false, true);
      backupFunction();
      super.open();
      this.requestActive();
   }

   public void updateSelectedNodes(int index) {
      for (int i=0; i<selectedNodes.size(); i++) {
         if (selectedNodes.get(i).intValue() == index) {
            selectedNodes.remove(i);
            renderer.unhighlightControlPoint(0, index);
            //xyPlot.addAnnotation(new XYTextAnnotation("", xyDataset.getXValue(0, index), xyDataset.getYValue(0, index))); //TODO
            this.repaint();
            return;
         }
      }

      selectedNodes.add(new Integer(index));
      double x = xyDataset.getXValue(0, index);
      double y = xyDataset.getYValue(0, index);
      renderer.highlightControlPoint(0, index);
      xValueTextField.setText(coordinatesFormat.format(x));
      yValueTextField.setText(coordinatesFormat.format(y));
      this.repaint();
   }

 /* Random notes for excitation editor:
  * put all excitations on same chart, with checkboxes for display/edit/hide individual ones
  * some help for adding symmetry (sync with other side, sync with other muscle)
  */

   private void updateXYTextFields() {
      if (selectedNodes.size() == 1) {
         double x = xyDataset.getXValue(0, selectedNodes.get(0));;
         double y = xyDataset.getYValue(0, selectedNodes.get(0));
         xValueTextField.setText(coordinatesFormat.format(x));
         xValueTextField.setEnabled(true);
         yValueTextField.setText(coordinatesFormat.format(y));
         //yValueTextField.setEnabled(true);
      } else {
         xValueTextField.setText("");
         xValueTextField.setEnabled(false);
         yValueTextField.setText("");
         //yValueTextField.setEnabled(false);
      }
   }

   private int findObjectInSelectedList(int node) {
      for (int i = 0; i < selectedNodes.size(); i++)
         if (selectedNodes.get(i).intValue() == node)
            return i;
      return -1;
   }

   public void toggleAddSelectedNode(int node) {
      int nodeIndex = findObjectInSelectedList(node);
      // If the node is already in the list, remove it
      if (nodeIndex >= 0) {
         selectedNodes.remove(nodeIndex);
         renderer.unhighlightControlPoint(0, node);
      } else {
         // If the node is not already in the list, add it
         Integer selectedNode = new Integer(node);
         selectedNodes.add(selectedNode);
         renderer.highlightControlPoint(0, node);
      }
      updateXYTextFields();
      // The highlighted/unhighlighted control points will be
      // drawn either when the function panel is redrawn, or
      // manually by the method calling this one (e.g., during
      // a box select).
   }

   public void clearSelectedNodes() {
      for (int i = 0; i < selectedNodes.size(); i++)
         renderer.unhighlightControlPoint(0, selectedNodes.get(i).intValue());
      selectedNodes.clear();
      updateXYTextFields();
      this.repaint();
   }

   public void replaceSelectedNode(int node) {
      // If the node is already in the list of selected ones, do nothing (a la Illustrator)
      // If the node is not already in the list, make this node the only selected one
      if(!isSelected(node))
         setSelectedNode(node);
   }

   public boolean isSelected(int node) {
      return (findObjectInSelectedList(node) >= 0);
   }

   public void setSelectedNode(int node) {
      clearSelectedNodes();

      if (node >= 0) {
         Integer selectedNode = new Integer(node);
         selectedNodes.add(selectedNode);
         renderer.highlightControlPoint(0, node);
      }
      updateXYTextFields();
      this.repaint();
   }

   private void cropDragVector(double dragVector[]) {
      // Don't allow any dragged node to go past either of its neighbors in the X dimension.
      double minGap = 99999999.9;
      if (dragVector[0] < 0.0) {
         for (int i=0; i<selectedNodes.size(); i++) {
            int index = selectedNodes.get(i).intValue();
            if (index == 0 || isSelected(index-1))
               continue;
            double gap = function.getX(index) - function.getX(index-1);
            if (gap < minGap)
               minGap = gap;
         }
         // minGap is the smallest [positive] distance between a dragged node and its
         // left neighbor (if unselected). dragVector[0] can't be a larger negative
         // number than this value.
         if (dragVector[0] < -minGap)
            dragVector[0] = -minGap;
      } else if (dragVector[0] > 0.0) {
         for (int i=0; i<selectedNodes.size(); i++) {
            int index = selectedNodes.get(i).intValue();
            if (index == function.getNumberOfPoints()-1 || isSelected(index+1))
               continue;
            double gap = function.getX(index+1) - function.getX(index);
            if (gap < minGap)
               minGap = gap;
         }
         // minGap is the smallest [positive] distance between a dragged node and its
         // right neighbor (if unselected). dragVector[0] can't be a larger positive
         // number than this value.
         if (dragVector[0] > minGap)
            dragVector[0] = minGap;
      }
   }
   public void dragSelectedNodes(int dragNode, double dragVector[]) {
      cropDragVector(dragVector);
      // Now move all the function points by dragVector.
      for (int i=0; i<selectedNodes.size(); i++) {
         int index = selectedNodes.get(i).intValue();
         double newX = function.getX(index) + dragVector[0];
         double newY = function.getY(index) + dragVector[1];
         function.setX(index, newX);
         function.setY(index, newY);
         xySeries.updateByIndex(index, newX, newY);
      }
      updateXYTextFields();
      setPendingChanges(true, true);
   }

   private void backupFunction() {
      savedFunction = Function.safeDownCast(function.copy());
   }

   private void restoreFunction() {
      if (savedFunction != null) {
         clearSelectedNodes();
         function = savedFunction;
         // make a new backup copy
         backupFunction();
      }
   }

   public void duplicateNode(int node) {
      if (function != null && node >= 0 && node < function.getNumberOfPoints()) {
         // Make a new point that is offset slightly in the X direction from
         // the point to be duplicated.
         double newX = function.getX(node) + 0.00001;
         double newY = function.getY(node);
         addNode(newX, newY);
      }
   }

   public void deleteNode(int node) {
      if (function != null && node >= 0 && node < function.getNumberOfPoints()) {
         function.deletePoint(node);
         xySeries.delete(node, node);
         clearSelectedNodes();
         setPendingChanges(true, true);
      }
   }

   public void addNode(double x, double y) {
      if (function != null) {
         clearSelectedNodes();
         function.addPoint(x, y);
         xySeries.add(x, y);
         // Set the color for the new control point.
         // You don't know the index of the new control point, but it doesn't matter since
         // all control points have been deselected anyway. So just set the paint of the
         // last point to the default series paint, since that index was not previously
         // mapped to a paint.
         renderer.unhighlightControlPoint(0, xySeries.getItemCount()-1);
         setPendingChanges(true, true);
      }
   }
}
