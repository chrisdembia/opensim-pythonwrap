/*
 * SliderWithBoxJPanel.java
 *
 * Created on May 15, 2007, 10:16 AM
 */

package org.opensim.coordinateviewer;

import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.util.Hashtable;
import javax.swing.AbstractAction;
import javax.swing.JCheckBox;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JSlider;
import javax.swing.KeyStroke;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.text.NumberFormatter;
import org.opensim.modeling.AbstractCoordinate;
import org.opensim.modeling.AbstractDof;
import org.opensim.view.pub.OpenSimDB;
import org.opensim.view.pub.ViewDB;

/**
 *
 * @author  Ayman
 * The real value of the slider is maintained in the "value" property of the jFormattedTextField
 * everything else is just a view (text, slider).
 */
public class CoordinateSliderWithBox extends javax.swing.JPanel implements ChangeListener,
         PropertyChangeListener{
   
    private double min, max, step;
    private double conversion=1.0;
    int numTicks=0;
    NumberFormatter formatter;
    private boolean rotational;
    private AbstractCoordinate coord;
    private static double ROUNDOFF=1E-5;  // work around for roundoff converting Strings to/from doubles
    private static String LABELS_FORMAT="###.##";          // Number of digits to show after floating point in bounds
    
   public CoordinateSliderWithBox(AbstractCoordinate coord) {
      this.coord = coord;
      setRotational(coord.getMotionType()==AbstractDof.DofType.Rotational);
      this.min=coord.getRangeMin()*conversion;
      this.max=coord.getRangeMax()*conversion;
      min=roundBoundIfNeeded(min);
      max=roundBoundIfNeeded(max);
      
      if (isRotational()){ // Make the step one degree
         step=1.0;
      }
      else
         this.step = (max-min)/100;
      numTicks = (int)((max - min)/step)+1;
      java.text.NumberFormat numberFormat =
              java.text.NumberFormat.getNumberInstance();
      formatter = new NumberFormatter(numberFormat);
      setTextfieldBounds(true);

       initComponents();
       
       jFormattedTextField.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
       jFormattedTextField.getActionMap().put("check", new handleReturnAction());
       jXSlider.setMinimum(0);
       jXSlider.setMaximum(numTicks-1);
       
       
       createBoundsLabels(jXSlider, min, max, 0, numTicks-1);
       jCoordinateNameLabel.setText(coord.getName());
       boolean clamped = coord.getClamped();
       jClampedCheckBox.setSelected(clamped);
       boolean locked = coord.getLocked();
       jLockedCheckBox.setSelected(locked);
       if (!clamped | locked){
           jMinimumLabel.setEnabled(false);
           jMaximumLabel.setEnabled(false);
       }
       jXSlider.setEnabled(!locked);
       jFormattedTextField.setEnabled(!locked);
       jXSlider.setToolTipText("["+Math.round(min)+", "+Math.round(max)+"]");
       jXSlider.addChangeListener(this);
       jFormattedTextField.addPropertyChangeListener("value", this);

       updateValue();
   }

   private void setTextfieldBounds(boolean trueFalse) {
      if (trueFalse){
         formatter.setMinimum(new Double(min));
         formatter.setMaximum(new Double(max));
      }
      else {
         formatter.setMinimum(new Double(-1e30));
         formatter.setMaximum(new Double(1e30));
         
      }
   }
      
   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        jXSlider = new javax.swing.JSlider();
        jFormattedTextField = new JFormattedTextField(formatter);
        jClampedCheckBox = new javax.swing.JCheckBox();
        jLockedCheckBox = new javax.swing.JCheckBox();
        jCoordinateNameLabel = new javax.swing.JLabel();
        jMinimumLabel = new javax.swing.JLabel();
        jMaximumLabel = new javax.swing.JLabel();

        setAlignmentY(0.0F);
        jXSlider.setMajorTickSpacing(20);
        jXSlider.setMinorTickSpacing(10);
        jXSlider.setToolTipText("testtooltip");
        jXSlider.setAlignmentX(0.0F);
        jXSlider.setMaximumSize(new java.awt.Dimension(32767, 22));
        jXSlider.setMinimumSize(new java.awt.Dimension(36, 22));
        jXSlider.setPreferredSize(new java.awt.Dimension(200, 22));

        jFormattedTextField.setText("0.123");
        jFormattedTextField.setFont(new java.awt.Font("Tahoma", 0, 11));
        jFormattedTextField.setMargin(new java.awt.Insets(1, 0, 2, 0));
        jFormattedTextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jFormattedTextFieldActionPerformed(evt);
            }
        });

        jClampedCheckBox.setToolTipText("Clamp value to limits");
        jClampedCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        jClampedCheckBox.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/unclamped.png")));
        jClampedCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
        jClampedCheckBox.setMaximumSize(new java.awt.Dimension(20, 20));
        jClampedCheckBox.setMinimumSize(new java.awt.Dimension(20, 20));
        jClampedCheckBox.setPreferredSize(new java.awt.Dimension(20, 20));
        jClampedCheckBox.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/unclamped_rollover.png")));
        jClampedCheckBox.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/clamped_rollover.png")));
        jClampedCheckBox.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/clamped.png")));
        jClampedCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jClampedCheckBoxActionPerformed(evt);
            }
        });

        jLockedCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        jLockedCheckBox.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/unlocked.png")));
        jLockedCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
        jLockedCheckBox.setMaximumSize(new java.awt.Dimension(20, 20));
        jLockedCheckBox.setMinimumSize(new java.awt.Dimension(20, 20));
        jLockedCheckBox.setPreferredSize(new java.awt.Dimension(20, 20));
        jLockedCheckBox.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/unlocked_rollover.png")));
        jLockedCheckBox.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/locked_rollover.png")));
        jLockedCheckBox.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/locked.png")));
        jLockedCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jLockedCheckBoxActionPerformed(evt);
            }
        });

        jCoordinateNameLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        jCoordinateNameLabel.setText("coordinate");
        jCoordinateNameLabel.setAlignmentX(1.0F);

        jMinimumLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        jMinimumLabel.setText("-1.00");
        jMinimumLabel.setFocusable(false);
        jMinimumLabel.setIconTextGap(0);

        jMaximumLabel.setText("1.00");
        jMaximumLabel.setFocusable(false);
        jMaximumLabel.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);
        jMaximumLabel.setIconTextGap(0);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(jCoordinateNameLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 101, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jFormattedTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 45, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jLockedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 20, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jClampedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 20, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jMinimumLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 46, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jXSlider, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 80, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jMaximumLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 46, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                .add(jCoordinateNameLabel)
                .add(jMaximumLabel)
                .add(jMinimumLabel)
                .add(jFormattedTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(jLockedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(jClampedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(jXSlider, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 25, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
        );
    }// </editor-fold>//GEN-END:initComponents

   private void jClampedCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jClampedCheckBoxActionPerformed
      boolean newValue = ((JCheckBox)(evt.getSource())).isSelected();
      coord.setClamped(newValue);
      setTextfieldBounds(newValue);
      if (jLockedCheckBox.isSelected()) {
          // do nothing
      }
      else {
          jMinimumLabel.setEnabled(newValue);
          jMaximumLabel.setEnabled(newValue);
      }
      if (coord.getClamped()){
         if (coord.getValue()>coord.getRangeMax()){
            setTheValue(coord.getRangeMax()*conversion, true, true, true, true);
         }
         else if (coord.getValue()<coord.getRangeMin()){
            setTheValue(coord.getRangeMin()*conversion, true, true, true, true);
         }
      }
// TODO add your handling code here:
   }//GEN-LAST:event_jClampedCheckBoxActionPerformed

   private void jLockedCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jLockedCheckBoxActionPerformed
// TODO add your handling code here:
      boolean newValue = ((JCheckBox)(evt.getSource())).isSelected();
      coord.setLocked(newValue);
      jXSlider.setEnabled(!newValue);
      jFormattedTextField.setEnabled(!newValue);
      if (jClampedCheckBox.isSelected()) {
          jMinimumLabel.setEnabled(!newValue);
          jMaximumLabel.setEnabled(!newValue);
      }
   }//GEN-LAST:event_jLockedCheckBoxActionPerformed

   private void jFormattedTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jFormattedTextFieldActionPerformed
// TODO add your handling code here:
   }//GEN-LAST:event_jFormattedTextFieldActionPerformed
   
   
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox jClampedCheckBox;
    private javax.swing.JLabel jCoordinateNameLabel;
    private javax.swing.JFormattedTextField jFormattedTextField;
    private javax.swing.JCheckBox jLockedCheckBox;
    private javax.swing.JLabel jMaximumLabel;
    private javax.swing.JLabel jMinimumLabel;
    private javax.swing.JSlider jXSlider;
    // End of variables declaration//GEN-END:variables
      /**
     * Set current value. May not correspond to a tickmark.
     * ONE SINGLE PLACE TO SET THE VALUE
     * During initialization, we don't want to update display of the whole model for every single slider.
     * but do it once after all the sliders were initialized.
     */
    void setTheValue(double theValue, boolean setText, boolean setSlider, boolean setCoordinate, boolean updateDisplay)
    {
       // Remove change listeners before calling setValue to avoid extraneous events
       if(setText) {
          jFormattedTextField.removePropertyChangeListener("value", this);
          jFormattedTextField.setValue(new Double(theValue)); 
          jFormattedTextField.addPropertyChangeListener("value", this);
       }
       if(setSlider) {
          jXSlider.removeChangeListener(this);
          jXSlider.setValue((int)((theValue-min)/step));
          jXSlider.addChangeListener(this);
       }
       if(setCoordinate) {
          coord.setValue(theValue/conversion);
          if (updateDisplay) {
             // Use renderAll rather than repaintAll for greater responsiveness in 3d viewer
             //ViewDB.getInstance().updateModelDisplay(OpenSimDB.getInstance().getCurrentModel());
             ViewDB.getInstance().updateModelDisplayNoRepaint(OpenSimDB.getInstance().getCurrentModel());
             ViewDB.getInstance().renderAll();
          }
       }
    }

     public double getTheValue()
    {
        return ((Double)jFormattedTextField.getValue()).doubleValue();
    }

   /**
    * Update the value of the slider and textbox from the coordinate's current value without triggering any extraneous events or affecting display
    * Called from CoordinateSliderWithBox in response to model coordinates changing.
    */
   public void updateValue()
   {
      double theValue=coord.getValue() * conversion;
      setTheValue(theValue, true, true, false, false);
   }

    /**
     * Slider change
     */
     public void stateChanged(ChangeEvent e) {
        JSlider source = (JSlider) e.getSource();
        if (source != jXSlider) return;
        double theValue = jXSlider.getValue()*step+min;
        setTheValue(theValue, true, false, true, (source.getValueIsAdjusting()));
     }
     /**
      * Text field change
      */
     public void propertyChange(PropertyChangeEvent evt) {
       if ("value".equals(evt.getPropertyName())) {
           Number value = (Number)evt.getNewValue();
           Number valueOld = (Number)evt.getOldValue();
          if (value != null && valueOld!=value) {
               setTheValue(value.doubleValue(), false, true, true, true);
           }
       }
     }

   private void createBoundsLabels(JSlider jXSlider, double min, double max, int minint, int maxint) {
      double rounded = Math.round(min);
      if (Math.abs(min-rounded)<ROUNDOFF) min=rounded;
      // Limit display to 2 significant digit
      DecimalFormat formatter = new DecimalFormat(LABELS_FORMAT);
      String myString = formatter.format(min);
      jMinimumLabel.setText(myString);
      //JLabel startLabel = new JLabel(myString);
      rounded = Math.round(max);
      if (Math.abs(max-rounded)<ROUNDOFF) max=rounded;
      myString = formatter.format(max);
      //JLabel endLabel = new JLabel(myString);
      jMaximumLabel.setText(myString);
      //Hashtable<Integer,JLabel> labels = new Hashtable<Integer,JLabel>(2);
      //labels.put(minint, startLabel);
      //labels.put(maxint, endLabel);
      //jXSlider.setLabelTable(labels);
   }
      
     class handleReturnAction extends AbstractAction {
        public void actionPerformed(ActionEvent e) {
           if (!jFormattedTextField.isEditValid()) { //The text is invalid.
              Toolkit.getDefaultToolkit().beep();
              String text = jFormattedTextField.getText();
              // Try to parse the text into a double as it could be out of range, in this case truncate
              try {
                  double valueFromTextField = Double.parseDouble(text);
                  if (coord.getClamped()){
                     if (valueFromTextField >max){
                        jFormattedTextField.setText(String.valueOf(max)) ;
                        jFormattedTextField.commitEdit();
                     }
                     else {
                        jFormattedTextField.setText(String.valueOf(min)) ;
                        jFormattedTextField.commitEdit();
                     }
                  }
                  else
                     throw new UnsupportedOperationException();
              }
              catch (NumberFormatException ex){
                 // Really invalid text for a double
              }
              catch (ParseException ex){
                 // Really invalid text for a double
              }
              
              jFormattedTextField.selectAll();
           } else try {                    //The text is valid,
              jFormattedTextField.commitEdit();     //so use it.
            } catch (java.text.ParseException exc) { 
               System.out.println("Parsing Exception");
            }
           
        }
        
     }

   public boolean isRotational() {
      return rotational;
   }

   public void setRotational(boolean rotational) {
      this.rotational = rotational;
      if (rotational)
         conversion=180.0/Math.PI;
   }

   /**
    * Due to round off in converting back and forth between ints and floats we need to make sure sliders
    * and text boxes end up with proper int bounds if warranted
    * 
    * This doesn't work now because of tight tolerances setting coordinate values
    */
   private double roundBoundIfNeeded(double bound) {
      double absBound = Math.abs(bound);
      double roundAbsBound= Math.round(absBound);
      if (Math.abs(absBound-roundAbsBound)<ROUNDOFF){
         return (bound>0)?roundAbsBound:-roundAbsBound;
      }
      else
         return bound;
   }
   
}
