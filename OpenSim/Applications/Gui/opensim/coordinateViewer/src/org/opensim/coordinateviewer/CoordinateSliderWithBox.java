/*
 * SliderWithBoxJPanel.java
 *
 * Created on May 15, 2007, 10:16 AM
 */

package org.opensim.coordinateviewer;

import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.util.Hashtable;
import javax.swing.AbstractAction;
import javax.swing.JCheckBox;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JSlider;
import javax.swing.KeyStroke;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.text.NumberFormatter;
import org.opensim.modeling.AbstractCoordinate;
import org.opensim.modeling.AbstractDof;
import org.opensim.view.pub.OpenSimDB;
import org.opensim.view.pub.ViewDB;

/**
 *
 * @author  Ayman
 * The real value of the slider is maintained in the "value" property of the jFormattedTextField
 * everything else is just a view (text, slider).
 */
public class CoordinateSliderWithBox extends javax.swing.JPanel implements ChangeListener,
         PropertyChangeListener{
   
    private double min, max, step;
    private double conversion=1.0;
    int numTicks=0;
    NumberFormatter formatter;
    private boolean rotational;
    private AbstractCoordinate coord;
    private static double ROUNDOFF=1E-5;  // work around for roundoff converting Strings to/from doubles
    private static String LABELS_FORMAT="###.##";          // Number of digits to show after floating point in bounds
    
   public CoordinateSliderWithBox(AbstractCoordinate coord) {
      this.coord = coord;
      setRotational(coord.getMotionType()==AbstractDof.DofType.Rotational);
      this.min=coord.getRangeMin()*conversion;
      this.max=coord.getRangeMax()*conversion;
      min=roundBoundIfNeeded(min);
      max=roundBoundIfNeeded(max);
      
      if (isRotational()){ // Make the step one degree
         step=1.0;
      }
      else
         this.step = (max-min)/100;
      numTicks = (int)((max - min)/step)+1;
      java.text.NumberFormat numberFormat =
              java.text.NumberFormat.getNumberInstance();
      formatter = new NumberFormatter(numberFormat);
      formatter.setMinimum(new Double(min));
      formatter.setMaximum(new Double(max));

       initComponents();
       
       jFormattedTextField.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
       jFormattedTextField.getActionMap().put("check", new handleReturnAction());
       jXSlider.setMinimum(0);
       jXSlider.setMaximum(numTicks-1);
       
       
       createBoundsLabels(jXSlider, min, max, 0, numTicks-1);
       jCoordinateNameLabel.setText(coord.getName());
       jClampedCheckBox.setSelected(coord.getClamped());
       boolean locked = coord.getLocked();
       jLockedCheckBox.setSelected(locked);
       jXSlider.setEnabled(!locked);
       jFormattedTextField.setEnabled(!locked);
       jXSlider.setToolTipText("["+Math.round(min)+", "+Math.round(max)+"]");
       jXSlider.addChangeListener(this);
       jFormattedTextField.addPropertyChangeListener("value", this);

       updateValue();
   }
      
   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      jXSlider = new javax.swing.JSlider();
      jFormattedTextField = new JFormattedTextField(formatter);
      jClampedCheckBox = new javax.swing.JCheckBox();
      jLockedCheckBox = new javax.swing.JCheckBox();
      jCoordinateNameLabel = new javax.swing.JLabel();
      jLabelMin = new javax.swing.JLabel();
      jLabelMax = new javax.swing.JLabel();

      setAlignmentY(0.0F);
      jXSlider.setMajorTickSpacing(20);
      jXSlider.setMinorTickSpacing(10);
      jXSlider.setToolTipText("testtooltip");
      jXSlider.setAlignmentX(0.0F);

      jFormattedTextField.setText("123456.");
      jFormattedTextField.setMargin(new java.awt.Insets(1, 0, 2, 0));
      jFormattedTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            jFormattedTextFieldActionPerformed(evt);
         }
      });

      jClampedCheckBox.setToolTipText("Clamp value to limits");
      jClampedCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jClampedCheckBox.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/unclamped.GIF")));
      jClampedCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jClampedCheckBox.setPreferredSize(new java.awt.Dimension(17, 17));
      jClampedCheckBox.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/clamped.GIF")));
      jClampedCheckBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            jClampedCheckBoxActionPerformed(evt);
         }
      });

      jLockedCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jLockedCheckBox.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/unlocked.GIF")));
      jLockedCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jLockedCheckBox.setMaximumSize(new java.awt.Dimension(25, 17));
      jLockedCheckBox.setMinimumSize(new java.awt.Dimension(25, 17));
      jLockedCheckBox.setPreferredSize(new java.awt.Dimension(25, 17));
      jLockedCheckBox.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/locked.GIF")));
      jLockedCheckBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            jLockedCheckBoxActionPerformed(evt);
         }
      });

      jCoordinateNameLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
      jCoordinateNameLabel.setText("jLabel1");
      jCoordinateNameLabel.setAlignmentX(1.0F);

      jLabelMin.setText("jLabel1");
      jLabelMin.setBorder(javax.swing.BorderFactory.createEtchedBorder());
      jLabelMin.setEnabled(false);
      jLabelMin.setFocusable(false);
      jLabelMin.setIconTextGap(0);

      jLabelMax.setText("123.45 ");
      jLabelMax.setBorder(javax.swing.BorderFactory.createEtchedBorder());
      jLabelMax.setEnabled(false);
      jLabelMax.setFocusable(false);
      jLabelMax.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);
      jLabelMax.setIconTextGap(0);

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(layout.createSequentialGroup()
            .add(jCoordinateNameLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 101, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jLockedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 13, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jClampedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 17, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jFormattedTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 45, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jLabelMin, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 46, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jXSlider, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 90, Short.MAX_VALUE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jLabelMax, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 46, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
            .add(jLockedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(jClampedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(jCoordinateNameLabel)
            .add(jFormattedTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(jLabelMax)
            .add(jLabelMin))
         .add(jXSlider, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 25, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
      );
   }// </editor-fold>//GEN-END:initComponents

   private void jClampedCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jClampedCheckBoxActionPerformed
      boolean newValue = ((JCheckBox)(evt.getSource())).isSelected();
      coord.setClamped(newValue);
// TODO add your handling code here:
   }//GEN-LAST:event_jClampedCheckBoxActionPerformed

   private void jLockedCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jLockedCheckBoxActionPerformed
// TODO add your handling code here:
      boolean newValue = ((JCheckBox)(evt.getSource())).isSelected();
      coord.setLocked(newValue);
      jXSlider.setEnabled(!newValue);
      jFormattedTextField.setEnabled(!newValue);
   }//GEN-LAST:event_jLockedCheckBoxActionPerformed

   private void jFormattedTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jFormattedTextFieldActionPerformed
// TODO add your handling code here:
   }//GEN-LAST:event_jFormattedTextFieldActionPerformed
   
   
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JCheckBox jClampedCheckBox;
   private javax.swing.JLabel jCoordinateNameLabel;
   private javax.swing.JFormattedTextField jFormattedTextField;
   private javax.swing.JLabel jLabelMax;
   private javax.swing.JLabel jLabelMin;
   private javax.swing.JCheckBox jLockedCheckBox;
   private javax.swing.JSlider jXSlider;
   // End of variables declaration//GEN-END:variables
      /**
     * Set current value. May not correspond to a tickmark.
     * ONE SINGLE PLACE TO SET THE VALUE
     * During initialization, we don't want to update display of the whole model for every single slider.
     * but do it once after all the sliders were initialized.
     */
    void setTheValue(double theValue, boolean setText, boolean setSlider, boolean setCoordinate, boolean updateDisplay)
    {
       // Remove change listeners before calling setValue to avoid extraneous events
       if(setText) {
          jFormattedTextField.removePropertyChangeListener("value", this);
          jFormattedTextField.setValue(new Double(theValue)); 
          jFormattedTextField.addPropertyChangeListener("value", this);
       }
       if(setSlider) {
          jXSlider.removeChangeListener(this);
          jXSlider.setValue((int)((theValue-min)/step));
          jXSlider.addChangeListener(this);
       }
       if(setCoordinate) {
          coord.setValue(theValue/conversion);
          if (updateDisplay) {
             // Use renderAll rather than repaintAll for greater responsiveness in 3d viewer
             //ViewDB.getInstance().updateModelDisplay(OpenSimDB.getInstance().getCurrentModel());
             ViewDB.getInstance().updateModelDisplayNoRepaint(OpenSimDB.getInstance().getCurrentModel());
             ViewDB.getInstance().renderAll();
          }
       }
    }

     public double getTheValue()
    {
        return ((Double)jFormattedTextField.getValue()).doubleValue();
    }

   /**
    * Update the value of the slider and textbox from the coordinate's current value without triggering any extraneous events or affecting display
    * Called from CoordinateSliderWithBox in response to model coordinates changing.
    */
   public void updateValue()
   {
      double theValue=coord.getValue() * conversion;
      setTheValue(theValue, true, true, false, false);
   }

    /**
     * Slider change
     */
     public void stateChanged(ChangeEvent e) {
        JSlider source = (JSlider) e.getSource();
        if (source != jXSlider) return;
        double theValue = jXSlider.getValue()*step+min;
        setTheValue(theValue, true, false, true, (source.getValueIsAdjusting()));
     }
     /**
      * Text field change
      */
     public void propertyChange(PropertyChangeEvent evt) {
       if ("value".equals(evt.getPropertyName())) {
           Number value = (Number)evt.getNewValue();
           Number valueOld = (Number)evt.getOldValue();
          if (value != null && valueOld!=value) {
               setTheValue(value.doubleValue(), false, true, true, true);
           }
       }
     }

   private void createBoundsLabels(JSlider jXSlider, double min, double max, int minint, int maxint) {
      double rounded = Math.round(min);
      if (Math.abs(min-rounded)<ROUNDOFF) min=rounded;
      // Limit display to 2 significant digit
      DecimalFormat formatter = new DecimalFormat(LABELS_FORMAT);
      String myString = formatter.format(min);
      jLabelMin.setText(myString);
      //JLabel startLabel = new JLabel(myString);
      rounded = Math.round(max);
      if (Math.abs(max-rounded)<ROUNDOFF) max=rounded;
      myString = formatter.format(max);
      //JLabel endLabel = new JLabel(myString);
      jLabelMax.setText(myString);
      //Hashtable<Integer,JLabel> labels = new Hashtable<Integer,JLabel>(2);
      //labels.put(minint, startLabel);
      //labels.put(maxint, endLabel);
      //jXSlider.setLabelTable(labels);
   }
      
     class handleReturnAction extends AbstractAction {
        public void actionPerformed(ActionEvent e) {
           if (!jFormattedTextField.isEditValid()) { //The text is invalid.
              Toolkit.getDefaultToolkit().beep();
              String text = jFormattedTextField.getText();
              // Try to parse the text into a double as it could be out of range, in this case truncate
              try {
                  double valueFromTextField = Double.parseDouble(text);
                  if (coord.getClamped()){
                     if (valueFromTextField >max){
                        jFormattedTextField.setText(String.valueOf(max)) ;
                        jFormattedTextField.commitEdit();
                     }
                     else {
                        jFormattedTextField.setText(String.valueOf(min)) ;
                        jFormattedTextField.commitEdit();
                     }
                  }
                  else
                     throw new UnsupportedOperationException();
              }
              catch (NumberFormatException ex){
                 // Really invalid text for a double
              }
              catch (ParseException ex){
                 // Really invalid text for a double
              }
              
              jFormattedTextField.selectAll();
           } else try {                    //The text is valid,
              jFormattedTextField.commitEdit();     //so use it.
            } catch (java.text.ParseException exc) { 
               System.out.println("Parsing Exception");
            }
           
        }
        
     }

   public boolean isRotational() {
      return rotational;
   }

   public void setRotational(boolean rotational) {
      this.rotational = rotational;
      if (rotational)
         conversion=180.0/Math.PI;
   }

   /**
    * Due to round off in converting back and forth between ints and floats we need to make sure sliders
    * and text boxes end up with proper int bounds if warranted
    * 
    * This doesn't work now because of tight tolerances setting coordinate values
    */
   private double roundBoundIfNeeded(double bound) {
      double absBound = Math.abs(bound);
      double roundAbsBound= Math.round(absBound);
      if (Math.abs(absBound-roundAbsBound)<ROUNDOFF){
         return (bound>0)?roundAbsBound:-roundAbsBound;
      }
      else
         return bound;
   }
   
}
