/*
 * SliderWithBoxJPanel.java
 *
 * Created on May 15, 2007, 10:16 AM
 */

package org.opensim.coordinateviewer;

import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.text.DecimalFormat;
import java.util.Hashtable;
import javax.swing.AbstractAction;
import javax.swing.JCheckBox;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JSlider;
import javax.swing.KeyStroke;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.text.NumberFormatter;
import org.opensim.modeling.AbstractCoordinate;
import org.opensim.modeling.AbstractDof;
import org.opensim.modeling.Model;
import org.opensim.view.pub.OpenSimDB;
import org.opensim.view.pub.ViewDB;

/**
 *
 * @author  Ayman
 * The real value of the slider is maintained in the "value" property of the jFormattedTextField
 * everything else is just a view (text, slider).
 */
public class CoordinateSliderWithBox extends javax.swing.JPanel implements ChangeListener,
         PropertyChangeListener{
   
    private double min, max, step;
    private double conversion=1.0;
    int numTicks=0;
    NumberFormatter formatter;
    private boolean rotational;
    private AbstractCoordinate coord;
    private static double ROUNDOFF=1E-5;  // work around for roundoff converting Strings to/from doubles
    private static String LABELS_FORMAT="###.##";          // Number of digits to show after floating point in bounds
    private double theValue;  // Just for debugging purposes, real value is in jFormattedTextField.Value
    
   public CoordinateSliderWithBox(AbstractCoordinate coord) {
      this.coord = coord;
      setRotational(coord.getMotionType()==AbstractDof.DofType.Rotational);
      this.min=coord.getRangeMin()*conversion;
      this.max=coord.getRangeMax()*conversion;
      if (isRotational()){ // Make the step one degree
         step=1.0;
      }
      else
         this.step = (max-min)/100;
      numTicks = (int)((max - min)/step)+1;
      java.text.NumberFormat numberFormat =
              java.text.NumberFormat.getNumberInstance();
      formatter = new NumberFormatter(numberFormat);
      formatter.setMinimum(new Double(min));
      formatter.setMaximum(new Double(max));

       initComponents();
       
       jFormattedTextField.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
       jFormattedTextField.getActionMap().put("check", new handleReturnAction());
       jXSlider.setMinimum(0);
       jXSlider.setMaximum(numTicks-1);
       
       jXSlider.addChangeListener(this);
       jFormattedTextField.addPropertyChangeListener("value", this);
       
       double initialValue=coord.getValue()*conversion;
       setTheValue(initialValue, false);  
       createBoundsLabels(jXSlider, min, max, 0, numTicks-1);
       jCoordinateNameLabel.setText(coord.getName());
       jClampedCheckBox.setSelected(coord.getClamped());
       boolean locked = coord.getLocked();
       jLockedCheckBox.setSelected(locked);
       jXSlider.setEnabled(!locked);
       jFormattedTextField.setEnabled(!locked);
   }
      
   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      jXSlider = new javax.swing.JSlider();
      jFormattedTextField = new JFormattedTextField(formatter);
      jClampedCheckBox = new javax.swing.JCheckBox();
      jLockedCheckBox = new javax.swing.JCheckBox();
      jCoordinateNameLabel = new javax.swing.JLabel();

      setAlignmentY(0.0F);
      jXSlider.setMajorTickSpacing(20);
      jXSlider.setMinorTickSpacing(10);
      jXSlider.setPaintLabels(true);

      jFormattedTextField.setText("123456.");
      jFormattedTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            jFormattedTextFieldActionPerformed(evt);
         }
      });

      jClampedCheckBox.setToolTipText("Clamp value to limits");
      jClampedCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jClampedCheckBox.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/unclamped.GIF")));
      jClampedCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jClampedCheckBox.setPreferredSize(new java.awt.Dimension(17, 17));
      jClampedCheckBox.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/clamped.GIF")));
      jClampedCheckBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            jClampedCheckBoxActionPerformed(evt);
         }
      });

      jLockedCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jLockedCheckBox.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/unlocked.GIF")));
      jLockedCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jLockedCheckBox.setMaximumSize(new java.awt.Dimension(25, 17));
      jLockedCheckBox.setMinimumSize(new java.awt.Dimension(25, 17));
      jLockedCheckBox.setPreferredSize(new java.awt.Dimension(25, 17));
      jLockedCheckBox.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/locked.GIF")));
      jLockedCheckBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            jLockedCheckBoxActionPerformed(evt);
         }
      });

      jCoordinateNameLabel.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
      jCoordinateNameLabel.setText("jLabel1");

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(layout.createSequentialGroup()
            .addContainerGap()
            .add(jCoordinateNameLabel)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jLockedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 13, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jClampedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 17, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jFormattedTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 55, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jXSlider, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 101, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addContainerGap())
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
            .add(jCoordinateNameLabel)
            .add(jLockedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(jClampedCheckBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(jFormattedTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
         .add(jXSlider, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
      );
   }// </editor-fold>//GEN-END:initComponents

   private void jClampedCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jClampedCheckBoxActionPerformed
      boolean newValue = ((JCheckBox)(evt.getSource())).isSelected();
      coord.setClamped(newValue);
// TODO add your handling code here:
   }//GEN-LAST:event_jClampedCheckBoxActionPerformed

   private void jLockedCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jLockedCheckBoxActionPerformed
// TODO add your handling code here:
      boolean newValue = ((JCheckBox)(evt.getSource())).isSelected();
      coord.setLocked(newValue);
      jXSlider.setEnabled(!newValue);
   }//GEN-LAST:event_jLockedCheckBoxActionPerformed

   private void jFormattedTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jFormattedTextFieldActionPerformed
// TODO add your handling code here:
   }//GEN-LAST:event_jFormattedTextFieldActionPerformed
   
   
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JCheckBox jClampedCheckBox;
   private javax.swing.JLabel jCoordinateNameLabel;
   private javax.swing.JFormattedTextField jFormattedTextField;
   private javax.swing.JCheckBox jLockedCheckBox;
   private javax.swing.JSlider jXSlider;
   // End of variables declaration//GEN-END:variables
      /**
     * Set current value. May not correspond to a tickmark.
     * ONE SINGLE PLACE TO SET THE VALUE
     * During initialization, we don't want to update display of the whole model for every single slider.
     * but do it once after all the sliders were initialized.
     */
    void setTheValue(double d, boolean updateDisplay)
    {
       theValue=d;
       jFormattedTextField.setValue(new Double(d)); 
       coord.setValue(d/conversion);
       if (updateDisplay)
         ViewDB.getInstance().updateModelDisplay(OpenSimDB.getInstance().getCurrentModel());
    }

     public double getTheValue()
    {
        return ((Double)jFormattedTextField.getValue()).doubleValue();
    }
    /**
     * Slider change
     */
     public void stateChanged(ChangeEvent e) {
        JSlider source = (JSlider) e.getSource();
        if (source != jXSlider)
           return;
        if (source.getValueIsAdjusting()){
           int tempValue = jXSlider.getValue();
           //System.out.println("Adjusting"+tempValue);
           // The following introduces some numerical noise that has no real effect
           // since only the text is being changed but is annoying
           String str=String.valueOf(tempValue*step+min);
           if (str.length()>7){  // Likely this is due to noise, will truncate the string and reparse
              str = str.substring(0, 7);
              double truncated = Double.parseDouble(str);
              str = String.valueOf(truncated);
           }
           //jFormattedTextField.setText(str);
           // The following updates the display more responsively but may fire unnecessary
           // events while the sldier is still moving and so could be problematic
           // We work around that by removing the ChangeListener temporarily.
           jFormattedTextField.removePropertyChangeListener("value", this);
           theValue=tempValue*step+min;
           setTheValue(theValue, true);
           jFormattedTextField.addPropertyChangeListener("value", this);
        }
        else { // set the actual value, unnecessary since another event was fired already
           int tempValue = jXSlider.getValue();
           //System.out.println("Value changed to"+tempValue);
           jFormattedTextField.removePropertyChangeListener("value", this);
           theValue=tempValue*step+min;
           setTheValue(theValue, false); // display must have been updated while adjusting
           jFormattedTextField.addPropertyChangeListener("value", this);
        }
     }
     /**
      * Text field change
      */
     public void propertyChange(PropertyChangeEvent evt) {
       if ("value".equals(evt.getPropertyName())) {
           Number value = (Number)evt.getNewValue();
           Number valueOld = (Number)evt.getOldValue();
          if (value != null && valueOld!=value) {
              // Remove slider listener temporarily so that we don't keep firing events unnecessarily'
               jXSlider.removeChangeListener(this);
               jXSlider.setValue((int)((value.doubleValue()-min)/step));
               jXSlider.addChangeListener(this);
               coord.setValue(value.doubleValue()/conversion);
               ViewDB.getInstance().updateModelDisplay(OpenSimDB.getInstance().getCurrentModel());
           }
       }
     }

   private void createBoundsLabels(JSlider jXSlider, double min, double max, int minint, int maxint) {
      double rounded = Math.round(min);
      if (Math.abs(min-rounded)<ROUNDOFF) min=rounded;
      // Limit display to 2 significant digit
      DecimalFormat formatter = new DecimalFormat(LABELS_FORMAT);
      String myString = formatter.format(min);
      JLabel startLabel = new JLabel(myString);
      rounded = Math.round(max);
      if (Math.abs(max-rounded)<ROUNDOFF) max=rounded;
      myString = formatter.format(max);
      JLabel endLabel = new JLabel(myString);
      Hashtable<Integer,JLabel> labels = new Hashtable<Integer,JLabel>(2);
      labels.put(minint, startLabel);
      labels.put(maxint, endLabel);
      jXSlider.setLabelTable(labels);
   }
      
     class handleReturnAction extends AbstractAction {
        public void actionPerformed(ActionEvent e) {
           if (!jFormattedTextField.isEditValid()) { //The text is invalid.
              Toolkit.getDefaultToolkit().beep();
              jFormattedTextField.selectAll();
           } else try {                    //The text is valid,
              jFormattedTextField.commitEdit();     //so use it.
            } catch (java.text.ParseException exc) { 
               System.out.println("Parsing Exception");
            }
           
        }
        
     }

   public boolean isRotational() {
      return rotational;
   }

   public void setRotational(boolean rotational) {
      this.rotational = rotational;
      conversion=180.0/Math.PI;
   }
   /**
    * update the value of the slider and textbox without affecting display
    */
   void updateValue() {
      theValue=coord.getValue()*conversion;
      setTheValue(theValue, false);  
   }
   
}
