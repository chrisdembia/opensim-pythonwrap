/*
 * SliderWithBoxJPanel.java
 *
 * Created on May 15, 2007, 10:16 AM
 */

package org.opensim.coordinateviewer;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.Hashtable;
import javax.swing.AbstractAction;
import javax.swing.JCheckBox;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JSlider;
import javax.swing.KeyStroke;
import javax.swing.border.TitledBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.text.NumberFormatter;
import org.opensim.modeling.AbstractCoordinate;
import org.opensim.modeling.AbstractDof;
import org.opensim.view.pub.OpenSimDB;
import org.opensim.view.pub.ViewDB;

/**
 *
 * @author  Ayman
 */
public class CoordinateSliderWithBox extends javax.swing.JPanel implements ChangeListener,
         PropertyChangeListener{
   
    private double accurateValue;   // Value set by user directly
    private double min, max, step;
    private double conversion=1.0;
    int numTicks=0;
    NumberFormatter formatter;
    private boolean rotational;
    private AbstractCoordinate coord;
    
   public CoordinateSliderWithBox(AbstractCoordinate coord) {
      this.coord = coord;
      setRotational(coord.getMotionType()==AbstractDof.DofType.Rotational);
      this.min=coord.getRangeMin()*conversion;
      this.max=coord.getRangeMax()*conversion;
      if (isRotational()){ // Make the step one degree
         step=1.0;
      }
      else
         this.step = (max-min)/100;
      numTicks = (int)((max - min)/step)+1;
      java.text.NumberFormat numberFormat =
              java.text.NumberFormat.getNumberInstance();
      formatter = new NumberFormatter(numberFormat);
      formatter.setMinimum(new Double(min));
      formatter.setMaximum(new Double(max));

       initComponents();
       
       jFormattedTextField.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
       jFormattedTextField.getActionMap().put("check", new handleReturnAction());
       jXSlider.setMinimum(0);
       jXSlider.setMaximum(numTicks-1);
       jXSlider.addChangeListener(this);
       jFormattedTextField.addPropertyChangeListener("value", this);
       setTheValue(coord.getValue()*conversion);
       createBoundsLabels(jXSlider, min, max, 0, numTicks-1);
       //jCoordinateNameLabel.setText(coord.getName());
       ((TitledBorder)getBorder()).setTitle(coord.getName());
       jClampedCheckBox.setSelected(coord.getClamped());
       jLockedCheckBox.setSelected(coord.getLocked());
       jXSlider.setEnabled(!coord.getLocked());

   }
   
  /** Creates new form SliderWithBoxJPanel */
   public CoordinateSliderWithBox(double min, double max, double step, double initial) {
      this.min=min;
      this.max=max;
      this.step = step;
      numTicks = (int)((max - min)/step)+1;
      java.text.NumberFormat numberFormat =
              java.text.NumberFormat.getNumberInstance();
      formatter = new NumberFormatter(numberFormat);
      formatter.setMinimum(new Double(min));
      formatter.setMaximum(new Double(max));

       initComponents();
       
       jFormattedTextField.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
       jFormattedTextField.getActionMap().put("check", new handleReturnAction());
       jXSlider.setMinimum(0);
       jXSlider.setMaximum(numTicks-1);
       jXSlider.addChangeListener(this);
       jFormattedTextField.addPropertyChangeListener("value", this);
       setTheValue(initial);
       createBoundsLabels(jXSlider, min, max, 0, numTicks-1);
       
     }
   
   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      jXSlider = new javax.swing.JSlider();
      jFormattedTextField = new JFormattedTextField(formatter);
      jClampedCheckBox = new javax.swing.JCheckBox();
      jLockedCheckBox = new javax.swing.JCheckBox();

      setBorder(javax.swing.BorderFactory.createTitledBorder("Coordinate name"));
      setAlignmentY(0.0F);
      jXSlider.setMajorTickSpacing(20);
      jXSlider.setMinorTickSpacing(10);

      jFormattedTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            jFormattedTextFieldActionPerformed(evt);
         }
      });

      jClampedCheckBox.setToolTipText("Clamp value to limits");
      jClampedCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jClampedCheckBox.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/unclamped.GIF")));
      jClampedCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jClampedCheckBox.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/clamped.GIF")));
      jClampedCheckBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            jClampedCheckBoxActionPerformed(evt);
         }
      });

      jLockedCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jLockedCheckBox.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/unlocked.GIF")));
      jLockedCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jLockedCheckBox.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/opensim/coordinateviewer/images/locked.GIF")));
      jLockedCheckBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            jLockedCheckBoxActionPerformed(evt);
         }
      });

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(layout.createSequentialGroup()
            .add(jLockedCheckBox)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jClampedCheckBox)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jFormattedTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 61, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jXSlider, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 85, Short.MAX_VALUE))
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
            .add(jClampedCheckBox)
            .add(jLockedCheckBox)
            .add(jFormattedTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
         .add(jXSlider, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
      );
   }// </editor-fold>//GEN-END:initComponents

   private void jClampedCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jClampedCheckBoxActionPerformed
      boolean newValue = ((JCheckBox)(evt.getSource())).isSelected();
      coord.setClamped(newValue);
// TODO add your handling code here:
   }//GEN-LAST:event_jClampedCheckBoxActionPerformed

   private void jLockedCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jLockedCheckBoxActionPerformed
// TODO add your handling code here:
      boolean newValue = ((JCheckBox)(evt.getSource())).isSelected();
      coord.setLocked(newValue);
      jXSlider.setEnabled(!newValue);
   }//GEN-LAST:event_jLockedCheckBoxActionPerformed

   private void jFormattedTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jFormattedTextFieldActionPerformed
// TODO add your handling code here:
   }//GEN-LAST:event_jFormattedTextFieldActionPerformed
   
   
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JCheckBox jClampedCheckBox;
   private javax.swing.JFormattedTextField jFormattedTextField;
   private javax.swing.JCheckBox jLockedCheckBox;
   private javax.swing.JSlider jXSlider;
   // End of variables declaration//GEN-END:variables
      /**
     * Set current value. May not correspond to a tickmark.
     */
    void setTheValue(double d)
    {
       jFormattedTextField.setValue(new Double(d));
       coord.setValue(d/conversion);
       ViewDB.getInstance().updateModelDisplay(OpenSimDB.getInstance().getCurrentModel());
    }

     public double getTheValue()
    {
        return ((Double)jFormattedTextField.getValue()).doubleValue();
    }
    /**
     * Slider change
     */
     public void stateChanged(ChangeEvent e) {
        JSlider source = (JSlider) e.getSource();
        if (source != jXSlider)
           return;
        if (source.getValueIsAdjusting()){
           int tempValue = jXSlider.getValue();
           // The following introduces some numerical noise that has no real effect
           // since only the text is being changed but is annoying
           String str=String.valueOf(tempValue*step+min);
           if (str.length()>7){  // Likely this is due to noise, will truncate the string and reparse
              str = str.substring(0, 7);
              double truncated = Double.parseDouble(str);
              str = String.valueOf(truncated);
           }
           //jFormattedTextField.setText(str);
           // The following updates the display more responsively but may fire unnecessary
           // events while the sldier is still moving and so could be problematic
           jFormattedTextField.setValue(new Double(tempValue*step+min));
        }
        else { // set the actual value
           int tempValue = jXSlider.getValue();
           setTheValue(tempValue*step+min);
        }
     }
     /**
      * Text field change
      */
     public void propertyChange(PropertyChangeEvent evt) {
       if ("value".equals(evt.getPropertyName())) {
           Number value = (Number)evt.getNewValue();
           if (value != null) {
               jXSlider.setValue((int)((value.doubleValue()-min)/step));
               setTheValue(value.doubleValue());
           }
       }
     }

   private void createBoundsLabels(JSlider jXSlider, double min, double max, int minint, int maxint) {
      String temp = String.valueOf(min);
      if (temp.length()>5) temp = temp.substring(0, 5);
      JLabel startLabel = new JLabel(temp);
      temp = String.valueOf(max);
      if (temp.length()>5) temp = temp.substring(0, 5);
      JLabel endLabel = new JLabel(temp);
      Hashtable labels = new Hashtable(2);
      labels.put(minint, startLabel);
      labels.put(maxint, endLabel);
      jXSlider.setLabelTable(labels);
   }
      
     class handleReturnAction extends AbstractAction {
        public void actionPerformed(ActionEvent e) {
           if (!jFormattedTextField.isEditValid()) { //The text is invalid.
              Toolkit.getDefaultToolkit().beep();
              jFormattedTextField.selectAll();
           } else try {                    //The text is valid,
              jFormattedTextField.commitEdit();     //so use it.
            } catch (java.text.ParseException exc) { 
               System.out.println("Parse Exception");
            }
           
        }
        
     }

   public boolean isRotational() {
      return rotational;
   }

   public void setRotational(boolean rotational) {
      this.rotational = rotational;
      conversion=180.0/Math.PI;
   }
   
}
