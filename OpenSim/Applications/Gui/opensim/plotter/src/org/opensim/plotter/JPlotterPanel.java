/*
 * JPlotterPanel.java
 *
 * Created on April 9, 2007, 1:39 PM
 */

package org.opensim.plotter;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Observable;
import java.util.Vector;
import javax.swing.AbstractAction;
import javax.swing.JCheckBox;
import javax.swing.JFormattedTextField;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import javax.swing.KeyStroke;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import org.openide.DialogDescriptor;
import org.openide.DialogDisplayer;
import org.opensim.modeling.AbstractCoordinate;
import org.opensim.modeling.AbstractDof;
import org.opensim.modeling.Analysis;
import org.opensim.modeling.AnalysisSet;
import org.opensim.modeling.AnalyzeTool;
import org.opensim.modeling.ArrayStorage;
import org.opensim.modeling.ArrayStr;
import org.opensim.modeling.CoordinateSet;
import org.opensim.modeling.Model;
import org.opensim.modeling.StateVector;
import org.opensim.modeling.Storage;
import org.opensim.motionviewer.MotionEvent;
import org.opensim.motionviewer.MotionTimeChangeEvent;
import org.opensim.utils.FileUtils;
import org.opensim.motionviewer.MotionsDB;
import org.opensim.view.ModelEvent;
import org.opensim.view.SingleModelGuiElements;
import org.opensim.view.pub.OpenSimDB;
import org.opensim.view.pub.ViewDB;
/**
 *
 * @author  Ayman
 */
public class JPlotterPanel extends javax.swing.JPanel
        implements java.awt.event.ActionListener, javax.swing.event.TreeSelectionListener, java.awt.event.FocusListener, java.util.Observer, java.beans.PropertyChangeListener, java.awt.event.InputMethodListener, java.awt.event.MouseListener {
   
   // PlotterModel kkeps track of two things
   // 1. For motions and free files, a PlotterSourceInterface is created and maintained so that
   //      files don't need to be re read/parsed'
   // 2. It serves as the model backing the tree of plots/figures.
   private PlotterModel plotterModel = new PlotterModel();
   public enum PlotDataSource {FileSource, MotionSource, AnalysisSource};
   JPlotterQuantitySelector xSelector = null;
   String currentCurveTitle="";
   private boolean autoGeneratedCurveTitle=true;
   Vector<TreePath> selectedPathsVector = new Vector<TreePath>(4);   // Cache used to accumulate user selection of the tree
   PlotCurve currentCurve=null;     //used for update
   PlotterSourceInterface  sourceX;
   Vector<PlotterSourceInterface> sourceY = new Vector<PlotterSourceInterface>(4);
   private String      domainName;
   private String[]    rangeNames;
   private boolean     builtinMuscleCurve=false;   // Whether muscle selection is required for specified Y qty
   Model currentModel = OpenSimDB.getInstance().getCurrentModel();
   private Storage statesStorage;
   boolean sumCurve=false;
   private boolean clamp=false;
   double  yMin, yMax;
   private boolean modelChanged=true;
   /**
    * Creates new form JPlotterPanel
    */
   public JPlotterPanel() {
      initComponents();
      jDomainStartTextField.setValue(0.0);
      jDomainEndTextField.setValue(1.0);
      jDomainStartTextField.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
      jDomainStartTextField.getActionMap().put("check", new handleReturnAction(jDomainStartTextField));
      jDomainEndTextField.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
      jDomainEndTextField.getActionMap().put("check", new handleReturnAction(jDomainEndTextField));
      jFormattedTextFieldYmin.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
      jFormattedTextFieldYmin.getActionMap().put("check", new handleReturnAction(jFormattedTextFieldYmin));
      jFormattedTextFieldYmax.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
      jFormattedTextFieldYmax.getActionMap().put("check", new handleReturnAction(jFormattedTextFieldYmax));

      jTopChartingPanel.setLayout(new BorderLayout());
      xSelector = new JPlotterQuantitySelector(jXQtyTextField, this, true);
      //ySelector = new JPlotterQuantitySelector(jYQtyTextField, this, false);
      jPlotsTree.addTreeSelectionListener(this);
      
      jPlotterDeletePlotButton.setEnabled(false);
      jPlotterUpdatePlotButton.setEnabled(false);
      updatePlotterWithSelection();
      // Add in blank figure by default
      jTopChartingPanel.add(plotterModel.getCurrentPlot().getChartPanel());
      processCurrentModel();
      useMuscles(false);
   }
   
   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      jPlotterMenuBar = new javax.swing.JMenuBar();
      jPlotterFileMenu = new javax.swing.JMenu();
      jLoadFileToPlotterMenuItem = new javax.swing.JMenuItem();
      jSourcePopupMenu = new javax.swing.JPopupMenu();
      jXPopupMenu = new javax.swing.JPopupMenu();
      jMusclePopupMenu = new javax.swing.JPopupMenu();
      jAdvancedPanel = new javax.swing.JPanel();
      jClampCheckBox = new javax.swing.JCheckBox();
      jLabel1 = new javax.swing.JLabel();
      jLabel3 = new javax.swing.JLabel();
      jRectifyCheckBox = new javax.swing.JCheckBox();
      jLabel9 = new javax.swing.JLabel();
      jDomainStartTextField = new javax.swing.JFormattedTextField();
      jLabel10 = new javax.swing.JLabel();
      jDomainEndTextField = new javax.swing.JFormattedTextField();
      jFormattedTextFieldYmin = new javax.swing.JFormattedTextField();
      jFormattedTextFieldYmax = new javax.swing.JFormattedTextField();
      jSplitPane1 = new javax.swing.JSplitPane();
      jTopChartingPanel = new javax.swing.JPanel();
      jPlotControlPanel = new javax.swing.JPanel();
      jPlotNavigationPanel = new javax.swing.JPanel();
      jScrollPane1 = new javax.swing.JScrollPane();
      jPlotsTree = new javax.swing.JTree();
      jPanel1 = new javax.swing.JPanel();
      jPlotterAddPlotButton = new javax.swing.JButton();
      jPlotterUpdatePlotButton = new javax.swing.JButton();
      jPlotterDeletePlotButton = new javax.swing.JButton();
      jPlotTitlePanel = new javax.swing.JPanel();
      jPlotLabelJLabel = new javax.swing.JLabel();
      jPlotNameTextField = new javax.swing.JTextField();
      jPlotSpecPanel = new javax.swing.JPanel();
      jLabel2 = new javax.swing.JLabel();
      jPanel10 = new javax.swing.JPanel();
      yQuantityButton = new javax.swing.JButton();
      jYQtyTextField = new javax.swing.JTextField();
      jXQtyTextField = new javax.swing.JTextField();
      xQuantityButton = new javax.swing.JButton();
      jMuscleSelectButton = new javax.swing.JButton();
      jSelectedMusclesTextField = new javax.swing.JTextField();
      jSummaryAdvancedTextField = new javax.swing.JTextField();
      jAdvancedOptionsButton = new javax.swing.JButton();
      jCurveLegendTextField = new javax.swing.JTextField();

      jPlotterFileMenu.setText("File");
      jPlotterFileMenu.setToolTipText("load into or save data from plotter.");
      jLoadFileToPlotterMenuItem.setText("Load File...");
      jLoadFileToPlotterMenuItem.setToolTipText("File with data to plot");
      jLoadFileToPlotterMenuItem.addActionListener(this);

      jPlotterFileMenu.add(jLoadFileToPlotterMenuItem);

      jPlotterMenuBar.add(jPlotterFileMenu);

      jClampCheckBox.setText("Clamp");
      jClampCheckBox.setToolTipText("Clamp Y value to limits between from, to");
      jClampCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jClampCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jClampCheckBox.addActionListener(this);

      jLabel1.setText("ymin");

      jLabel3.setText("ymax");

      jRectifyCheckBox.setText("Rectify");
      jRectifyCheckBox.setToolTipText("Plot absolute Y value");
      jRectifyCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jRectifyCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jRectifyCheckBox.addActionListener(this);

      jLabel9.setText("xmin");

      jDomainStartTextField.setToolTipText("domain start");
      jDomainStartTextField.addActionListener(this);
      jDomainStartTextField.addPropertyChangeListener(this);

      jLabel10.setText("xmax");

      jDomainEndTextField.setToolTipText("domain end");
      jDomainEndTextField.addPropertyChangeListener(this);

      jFormattedTextFieldYmin.setEditable(false);
      jFormattedTextFieldYmin.setToolTipText("clamp from value");
      jFormattedTextFieldYmin.addActionListener(this);

      jFormattedTextFieldYmax.setEditable(false);
      jFormattedTextFieldYmax.setToolTipText("clamp to value");
      jFormattedTextFieldYmax.setEnabled(false);

      org.jdesktop.layout.GroupLayout jAdvancedPanelLayout = new org.jdesktop.layout.GroupLayout(jAdvancedPanel);
      jAdvancedPanel.setLayout(jAdvancedPanelLayout);
      jAdvancedPanelLayout.setHorizontalGroup(
         jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jAdvancedPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jRectifyCheckBox)
               .add(jAdvancedPanelLayout.createSequentialGroup()
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jClampCheckBox)
                     .add(jAdvancedPanelLayout.createSequentialGroup()
                        .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                           .add(org.jdesktop.layout.GroupLayout.LEADING, jAdvancedPanelLayout.createSequentialGroup()
                              .add(jLabel9)
                              .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                              .add(jDomainStartTextField))
                           .add(org.jdesktop.layout.GroupLayout.LEADING, jAdvancedPanelLayout.createSequentialGroup()
                              .add(jLabel1)
                              .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                              .add(jFormattedTextFieldYmin, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 82, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                  .add(10, 10, 10)
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jLabel10)
                     .add(jLabel3))
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jDomainEndTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 70, Short.MAX_VALUE)
                     .add(jFormattedTextFieldYmax, 0, 0, Short.MAX_VALUE))
                  .addContainerGap())))
      );
      jAdvancedPanelLayout.setVerticalGroup(
         jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jAdvancedPanelLayout.createSequentialGroup()
            .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jAdvancedPanelLayout.createSequentialGroup()
                  .addContainerGap()
                  .add(jRectifyCheckBox)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jClampCheckBox)
                  .add(8, 8, 8)
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(jFormattedTextFieldYmin, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                     .add(jLabel3)
                     .add(jLabel1)))
               .add(jAdvancedPanelLayout.createSequentialGroup()
                  .add(55, 55, 55)
                  .add(jFormattedTextFieldYmax, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jLabel9)
               .add(jDomainStartTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jDomainEndTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jLabel10))
            .addContainerGap())
      );

      jSplitPane1.setDividerLocation(350);
      jSplitPane1.setDividerSize(7);
      jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
      jSplitPane1.setResizeWeight(1.0);
      jSplitPane1.setAutoscrolls(true);
      jSplitPane1.setDoubleBuffered(true);
      jSplitPane1.setOneTouchExpandable(true);
      org.jdesktop.layout.GroupLayout jTopChartingPanelLayout = new org.jdesktop.layout.GroupLayout(jTopChartingPanel);
      jTopChartingPanel.setLayout(jTopChartingPanelLayout);
      jTopChartingPanelLayout.setHorizontalGroup(
         jTopChartingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 715, Short.MAX_VALUE)
      );
      jTopChartingPanelLayout.setVerticalGroup(
         jTopChartingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 349, Short.MAX_VALUE)
      );
      jSplitPane1.setLeftComponent(jTopChartingPanel);

      jPlotControlPanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
      jPlotNavigationPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Plots list"));
      jScrollPane1.setAutoscrolls(true);
      jPlotsTree.setModel(plotterModel.getPlotTreeModel());
      jPlotsTree.addMouseListener(this);

      jScrollPane1.setViewportView(jPlotsTree);

      jPlotterAddPlotButton.setText("Add");
      jPlotterAddPlotButton.addActionListener(this);

      jPlotterUpdatePlotButton.setText("Update");
      jPlotterUpdatePlotButton.addActionListener(this);

      jPlotterDeletePlotButton.setText("Delete");
      jPlotterDeletePlotButton.addActionListener(this);

      org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
      jPanel1.setLayout(jPanel1Layout);
      jPanel1Layout.setHorizontalGroup(
         jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel1Layout.createSequentialGroup()
            .add(jPlotterAddPlotButton)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotterUpdatePlotButton)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotterDeletePlotButton)
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );
      jPanel1Layout.setVerticalGroup(
         jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jPlotterAddPlotButton)
               .add(jPlotterUpdatePlotButton)
               .add(jPlotterDeletePlotButton))
            .add(6, 6, 6))
      );

      org.jdesktop.layout.GroupLayout jPlotNavigationPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotNavigationPanel);
      jPlotNavigationPanel.setLayout(jPlotNavigationPanelLayout);
      jPlotNavigationPanelLayout.setHorizontalGroup(
         jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotNavigationPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 193, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addContainerGap())
      );
      jPlotNavigationPanelLayout.setVerticalGroup(
         jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPlotNavigationPanelLayout.createSequentialGroup()
            .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 166, Short.MAX_VALUE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
      );

      jPlotTitlePanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Headers"));
      jPlotLabelJLabel.setText("Plot Title");

      jPlotNameTextField.setText("Plot title goes here");
      jPlotNameTextField.setToolTipText("Plot Title");

      org.jdesktop.layout.GroupLayout jPlotTitlePanelLayout = new org.jdesktop.layout.GroupLayout(jPlotTitlePanel);
      jPlotTitlePanel.setLayout(jPlotTitlePanelLayout);
      jPlotTitlePanelLayout.setHorizontalGroup(
         jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotTitlePanelLayout.createSequentialGroup()
            .add(jPlotLabelJLabel)
            .add(22, 22, 22)
            .add(jPlotNameTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 352, Short.MAX_VALUE)
            .addContainerGap())
      );
      jPlotTitlePanelLayout.setVerticalGroup(
         jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotTitlePanelLayout.createSequentialGroup()
            .add(jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jPlotLabelJLabel)
               .add(jPlotNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addContainerGap())
      );

      jPlotSpecPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Curve add/update"));
      jPlotSpecPanel.setToolTipText("Legend:");
      jLabel2.setText("Curve Legend");

      yQuantityButton.setComponentPopupMenu(jSourcePopupMenu);
      yQuantityButton.setText("Y-Quantity...");
      yQuantityButton.addMouseListener(this);

      jYQtyTextField.setEditable(false);
      jYQtyTextField.addActionListener(this);
      jYQtyTextField.addFocusListener(this);

      jXQtyTextField.setEditable(false);
      jXQtyTextField.addActionListener(this);
      jXQtyTextField.addPropertyChangeListener(this);
      jXQtyTextField.addFocusListener(this);
      jXQtyTextField.addInputMethodListener(this);

      xQuantityButton.setText("X-Quantity...");
      xQuantityButton.addMouseListener(this);

      jMuscleSelectButton.setText("Muscles...");
      jMuscleSelectButton.addMouseListener(this);

      jSelectedMusclesTextField.setEditable(false);

      jSummaryAdvancedTextField.setEditable(false);
      jSummaryAdvancedTextField.setToolTipText("summary of advanced options");

      jAdvancedOptionsButton.setText("Advanced...");
      jAdvancedOptionsButton.addActionListener(this);

      org.jdesktop.layout.GroupLayout jPanel10Layout = new org.jdesktop.layout.GroupLayout(jPanel10);
      jPanel10.setLayout(jPanel10Layout);
      jPanel10Layout.setHorizontalGroup(
         jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel10Layout.createSequentialGroup()
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
               .add(org.jdesktop.layout.GroupLayout.TRAILING, jAdvancedOptionsButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 107, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jPanel10Layout.createSequentialGroup()
                  .add(yQuantityButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 107, Short.MAX_VALUE)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED))
               .add(jMuscleSelectButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 107, Short.MAX_VALUE)
               .add(org.jdesktop.layout.GroupLayout.TRAILING, xQuantityButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 107, Short.MAX_VALUE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
               .add(jSummaryAdvancedTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 302, Short.MAX_VALUE)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jSelectedMusclesTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 302, Short.MAX_VALUE)
               .add(jYQtyTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 302, Short.MAX_VALUE)
               .add(jXQtyTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 302, Short.MAX_VALUE))
            .addContainerGap())
      );
      jPanel10Layout.setVerticalGroup(
         jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel10Layout.createSequentialGroup()
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(yQuantityButton)
               .add(jYQtyTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jSelectedMusclesTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jMuscleSelectButton))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jXQtyTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(xQuantityButton))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jAdvancedOptionsButton)
               .add(jSummaryAdvancedTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );

      jCurveLegendTextField.setText("Curve legend goes here");
      jCurveLegendTextField.addActionListener(this);

      org.jdesktop.layout.GroupLayout jPlotSpecPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotSpecPanel);
      jPlotSpecPanel.setLayout(jPlotSpecPanelLayout);
      jPlotSpecPanelLayout.setHorizontalGroup(
         jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotSpecPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jLabel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 69, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(22, 22, 22)
            .add(jCurveLegendTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 314, Short.MAX_VALUE)
            .addContainerGap())
         .add(jPanel10, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
      );
      jPlotSpecPanelLayout.setVerticalGroup(
         jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotSpecPanelLayout.createSequentialGroup()
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jLabel2)
               .add(jCurveLegendTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel10, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
      );

      org.jdesktop.layout.GroupLayout jPlotControlPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotControlPanel);
      jPlotControlPanel.setLayout(jPlotControlPanelLayout);
      jPlotControlPanelLayout.setHorizontalGroup(
         jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotControlPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jPlotSpecPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(jPlotTitlePanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .add(11, 11, 11)
            .add(jPlotNavigationPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addContainerGap())
      );
      jPlotControlPanelLayout.setVerticalGroup(
         jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotControlPanelLayout.createSequentialGroup()
            .add(jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPlotNavigationPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPlotControlPanelLayout.createSequentialGroup()
                  .add(jPlotTitlePanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jPlotSpecPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
            .addContainerGap(24, Short.MAX_VALUE))
      );
      jSplitPane1.setRightComponent(jPlotControlPanel);

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 717, Short.MAX_VALUE)
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 628, Short.MAX_VALUE)
      );
   }

   // Code for dispatching events from components to event handlers.

   public void actionPerformed(java.awt.event.ActionEvent evt) {
      if (evt.getSource() == jLoadFileToPlotterMenuItem) {
         JPlotterPanel.this.jLoadFileToPlotterMenuItemActionPerformed(evt);
      }
      else if (evt.getSource() == jClampCheckBox) {
         JPlotterPanel.this.jClampCheckBoxActionPerformed(evt);
      }
      else if (evt.getSource() == jRectifyCheckBox) {
         JPlotterPanel.this.jRectifyCheckBoxActionPerformed(evt);
      }
      else if (evt.getSource() == jDomainStartTextField) {
         JPlotterPanel.this.jDomainStartTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jFormattedTextFieldYmin) {
         JPlotterPanel.this.jFormattedTextFieldYminActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterAddPlotButton) {
         JPlotterPanel.this.jPlotterAddCurveButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterUpdatePlotButton) {
         JPlotterPanel.this.jPlotterUpdatePlotButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterDeletePlotButton) {
         JPlotterPanel.this.jPlotterDeletePlotButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jYQtyTextField) {
         JPlotterPanel.this.jYQtyTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jAdvancedOptionsButton) {
         JPlotterPanel.this.jAdvancedOptionsButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jCurveLegendTextField) {
         JPlotterPanel.this.jCurveLegendTextFieldActionPerformed(evt);
      }
   }

   public void focusGained(java.awt.event.FocusEvent evt) {
   }

   public void focusLost(java.awt.event.FocusEvent evt) {
      if (evt.getSource() == jYQtyTextField) {
         JPlotterPanel.this.jYQtyTextFieldFocusLost(evt);
      }
      else if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldFocusLost(evt);
      }
   }

   public void caretPositionChanged(java.awt.event.InputMethodEvent evt) {
      if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldCaretPositionChanged(evt);
      }
   }

   public void inputMethodTextChanged(java.awt.event.InputMethodEvent evt) {
   }

   public void mouseClicked(java.awt.event.MouseEvent evt) {
   }

   public void mouseEntered(java.awt.event.MouseEvent evt) {
   }

   public void mouseExited(java.awt.event.MouseEvent evt) {
   }

   public void mousePressed(java.awt.event.MouseEvent evt) {
      if (evt.getSource() == yQuantityButton) {
         JPlotterPanel.this.yQuantityButtonMousePressed(evt);
      }
      else if (evt.getSource() == xQuantityButton) {
         JPlotterPanel.this.xQuantityButtonMousePressed(evt);
      }
      else if (evt.getSource() == jMuscleSelectButton) {
         JPlotterPanel.this.jMuscleSelectButtonMousePressed(evt);
      }
      else if (evt.getSource() == jPlotsTree) {
         JPlotterPanel.this.jPlotsTreeMousePressed(evt);
      }
   }

   public void mouseReleased(java.awt.event.MouseEvent evt) {
      if (evt.getSource() == yQuantityButton) {
         JPlotterPanel.this.yQuantityButtonMouseReleased(evt);
      }
      else if (evt.getSource() == xQuantityButton) {
         JPlotterPanel.this.xQuantityButtonMouseReleased(evt);
      }
      else if (evt.getSource() == jMuscleSelectButton) {
         JPlotterPanel.this.jMuscleSelectButtonMouseReleased(evt);
      }
      else if (evt.getSource() == jPlotsTree) {
         JPlotterPanel.this.jPlotsTreeMouseReleased(evt);
      }
   }

   public void propertyChange(java.beans.PropertyChangeEvent evt) {
      if (evt.getSource() == jDomainStartTextField) {
         JPlotterPanel.this.jDomainStartTextFieldPropertyChange(evt);
      }
      else if (evt.getSource() == jDomainEndTextField) {
         JPlotterPanel.this.jDomainEndTextFieldPropertyChange(evt);
      }
      else if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldPropertyChange(evt);
      }
   }// </editor-fold>//GEN-END:initComponents

   private void jPlotsTreeMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPlotsTreeMouseReleased
// TODO add your handling code here:
      invokeTreePopupIfNeeded(evt.getX(), evt.getY());
   }//GEN-LAST:event_jPlotsTreeMouseReleased

   private void jPlotsTreeMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPlotsTreeMousePressed
      invokeTreePopupIfNeeded(evt.getX(), evt.getY());
// TODO add your handling code here:
   }//GEN-LAST:event_jPlotsTreeMousePressed

   private void jFormattedTextFieldYminActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jFormattedTextFieldYminActionPerformed
// TODO add your handling code here:
   }//GEN-LAST:event_jFormattedTextFieldYminActionPerformed

   private void jDomainStartTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jDomainStartTextFieldActionPerformed
// TODO add your handling code here:
   }//GEN-LAST:event_jDomainStartTextFieldActionPerformed

   private void jRectifyCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRectifyCheckBoxActionPerformed
// TODO add your handling code here:
   }//GEN-LAST:event_jRectifyCheckBoxActionPerformed
   
    private void jAdvancedOptionsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jAdvancedOptionsButtonActionPerformed
// TODO add your handling code here:
       DialogDescriptor dd = new DialogDescriptor(jAdvancedPanel, "AdvancedOptions");
       dd.setModal(true);
       DialogDisplayer.getDefault().createDialog(dd).setVisible(true);
       setClamp(jClampCheckBox.isSelected());
       String summary = "Rectify ="+jRectifyCheckBox.isSelected()+
                        ", x:["+
                        jDomainStartTextField.getValue()+","+
                        jDomainEndTextField.getValue()+"]";
       if (isClamp())
               summary=summary+" y:["+
                       jFormattedTextFieldYmin.getValue()+", "+
                       jFormattedTextFieldYmax.getValue()+"]";
       
       jSummaryAdvancedTextField.setText(summary);
    }//GEN-LAST:event_jAdvancedOptionsButtonActionPerformed
    
    private void jClampCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jClampCheckBoxActionPerformed
// TODO add your handling code here:
       JCheckBox clamped = (JCheckBox)evt.getSource();
       jFormattedTextFieldYmin.setEnabled(clamped.isSelected());
       jFormattedTextFieldYmin.setEditable(clamped.isSelected());
       jFormattedTextFieldYmax.setEditable(clamped.isSelected());
       jFormattedTextFieldYmax.setEnabled(clamped.isSelected());
    }//GEN-LAST:event_jClampCheckBoxActionPerformed
    
    private void jMuscleSelectButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jMuscleSelectButtonMouseReleased
// TODO add your handling code here:
       jMuscleSelectButtonMousePressed(evt);
    }//GEN-LAST:event_jMuscleSelectButtonMouseReleased
    
    private void jMuscleSelectButtonMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jMuscleSelectButtonMousePressed
// TODO add your handling code here:
       // Show muscle selection, multiple
       //XX2
       if (currentModel==null || builtinMuscleCurve==false)
          return;
       SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
       String[] muscleNames = guiElem.getActuatorNames();
       QuantityNameFilterJPanel filterPanel = new QuantityNameFilterJPanel(muscleNames);
       DialogDescriptor dlg = new DialogDescriptor(filterPanel,"Select Muscles");
       dlg.setModal(true);
       DialogDisplayer.getDefault().createDialog(dlg).setVisible(true);
       jSelectedMusclesTextField.setText(filterPanel.getSelectedAsString());
       sumCurve=filterPanel.isSumOnly();
       if (sumCurve)
         rangeNames = filterPanel.getSelectedAsString().trim().split("\\+",-1);
       else
         rangeNames = filterPanel.getSelectedAsString().trim().split(",",-1);
       for(int i=0;i<rangeNames.length;i++)
          rangeNames[i]=rangeNames[i].trim();
       updateContextGuiElements();
       
    }//GEN-LAST:event_jMuscleSelectButtonMousePressed
    
    private void xQuantityButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_xQuantityButtonMouseReleased
// TODO add your handling code here:
       xQuantityButtonMousePressed(evt);
    }//GEN-LAST:event_xQuantityButtonMouseReleased
    
    private void xQuantityButtonMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_xQuantityButtonMousePressed
// TODO add your handling code here:
       //XX3
       if (isBuiltinMuscleCurve()){
          // May plot against motion curve or against a GC
          jXPopupMenu.removeAll();
          SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
          String[] coordNames = guiElem.getCoordinateNames();
          for(int i=0; i<coordNames.length; i++){
             final String coordinateName=coordNames[i];
             JMenuItem coordinateMenuItem = new JMenuItem(coordinateName);
             coordinateMenuItem.addActionListener(new ActionListener(){
                public void actionPerformed(ActionEvent e) {
                   setDomainName(coordinateName);
                   jXQtyTextField.setText(coordinateName);
                   CoordinateSet cs = currentModel.getDynamicsEngine().getCoordinateSet();
                   AbstractCoordinate coord = cs.get(coordinateName);
                   double conversionToGuiUnits=(coord.getMotionType()==AbstractDof.DofType.Rotational)?Math.toDegrees(1.0):1.0;
                   long l=Math.round(conversionToGuiUnits*coord.getRangeMin());
                   jDomainStartTextField.setValue((double)l);
                   l=Math.round(conversionToGuiUnits*coord.getRangeMax());
                   jDomainEndTextField.setValue((double)l);
                   updateContextGuiElements();
                   updatePlotterWithSelection();
                }
             });
             jXPopupMenu.add(coordinateMenuItem);
          }
          jXPopupMenu.addSeparator();
          // for motions make a cascade menu
          ArrayList<PlotterSourceMotion> motionSources=plotterModel.getLoadedMotionSources();
          for(int i=0; i<motionSources.size(); i++){
             final PlotterSourceMotion nextMotion = motionSources.get(i);
             JMenuItem motionMenuItem = new JMenuItem(nextMotion.getDisplayName());
             motionMenuItem.addActionListener(new ActionListener(){
                public void actionPerformed(ActionEvent e) {
                   setDomainName(nextMotion.getDisplayName()+":time");
                   jXQtyTextField.setText(nextMotion.getDisplayName()+":time");
                   jDomainStartTextField.setValue((double)nextMotion.getDefaultMin("time"));
                   jDomainEndTextField.setValue((double)nextMotion.getDefaultMax("time"));
                   sourceX=nextMotion;
                   updatePlotterWithSelection();
                   updateContextGuiElements();
                }
             });
             jXPopupMenu.add(motionMenuItem);
          }
          jXPopupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
       } else{    // Select X from a motion or a file
          xSelector.showSingleSelectionPanel(plotterModel,  sourceX);
          jDomainStartTextField.setValue((double)sourceX.getDefaultMin("time"));
          jDomainEndTextField.setValue((double)sourceX.getDefaultMax("time"));
          String dn = xSelector.getColumnToUse();
          setDomainName(dn);
          updateContextGuiElements();
          updatePlotterWithSelection();
       }
       parseDomainOrRangeText(jXQtyTextField, true);
       
    }//GEN-LAST:event_xQuantityButtonMousePressed
    
    private void yQuantityButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_yQuantityButtonMouseReleased
// TODO add your handling code here:
       yQuantityButtonMousePressed(evt);
    }//GEN-LAST:event_yQuantityButtonMouseReleased
    
    private void yQuantityButtonMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_yQuantityButtonMousePressed
// TODO add your handling code here:
       jSourcePopupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
    }//GEN-LAST:event_yQuantityButtonMousePressed
        
   private void jXQtyTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jXQtyTextFieldPropertyChange
// TODO add your handling code here:
   }//GEN-LAST:event_jXQtyTextFieldPropertyChange
   
   private void jXQtyTextFieldCaretPositionChanged(java.awt.event.InputMethodEvent evt) {//GEN-FIRST:event_jXQtyTextFieldCaretPositionChanged
// TODO add your handling code here:
   }//GEN-LAST:event_jXQtyTextFieldCaretPositionChanged
   
    private void jDomainEndTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jDomainEndTextFieldPropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jDomainEndTextFieldPropertyChange
    
    private void jDomainStartTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jDomainStartTextFieldPropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jDomainStartTextFieldPropertyChange
    // AnalysisPick
    private PlotterSourceAnalysis[] initAnalyses() {
       plotterModel.addModel(currentModel);
       xQuantityButton.setEnabled(true);
       ArrayList<PlotterSourceAnalysis> srcs=plotterModel.getAnalysisSources();
       // Add available quantities to jAvailableAnalysesComboBox
       PlotterSourceAnalysis[] availableAnalyses= new PlotterSourceAnalysis[srcs.size()];
       for(int i=0; i<srcs.size();i++)
          availableAnalyses[i] = srcs.get(i);
       return availableAnalyses;
    }
    
   private void jXQtyTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jXQtyTextFieldFocusLost
      updatePlotterWithSelection();
      
   }//GEN-LAST:event_jXQtyTextFieldFocusLost
   
   private void jXQtyTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jXQtyTextFieldActionPerformed
      updatePlotterWithSelection();
      
   }//GEN-LAST:event_jXQtyTextFieldActionPerformed
   
   private void jYQtyTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jYQtyTextFieldFocusLost
      updatePlotterWithSelection();
      
   }//GEN-LAST:event_jYQtyTextFieldFocusLost
   
   private void jYQtyTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jYQtyTextFieldActionPerformed
      updatePlotterWithSelection();
      
   }//GEN-LAST:event_jYQtyTextFieldActionPerformed
   
   private void jPlotterDeletePlotButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterDeletePlotButtonActionPerformed
      
      // Make a cache so that object deletion does not mess up the selections array
      // we're working on.
      Object[] cache = new Object[selectedPathsVector.size()];
      selectedPathsVector.copyInto(cache);
      for(int i=0;i<cache.length; i++){
         TreePath nextPath = (TreePath)cache[i]; // Since the array shrinks!
         Object[] pathObjects = nextPath.getPath();
         int depth =pathObjects.length-1;
         DefaultMutableTreeNode node = (DefaultMutableTreeNode)pathObjects[depth];
         if (node instanceof PlotNode){
            Plot figToDelete = ((Plot)node.getUserObject());
            System.out.println("Delete figure named "+figToDelete.getTitle());
            plotterModel.deletePlot(figToDelete);
         } else if (node instanceof PlotCurveNode){
            PlotCurve cvToDelete = ((PlotCurve)node.getUserObject());
            plotterModel.deleteCurve(cvToDelete);
            System.out.println("Delete Curve named "+cvToDelete.getLegend());
         } else
            JOptionPane.showMessageDialog(this, "Don't know what to delete!");
         
      }
   }//GEN-LAST:event_jPlotterDeletePlotButtonActionPerformed
   
   private void jPlotterUpdatePlotButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterUpdatePlotButtonActionPerformed
      
      // Single Curve is selected, populate the dialog from the Curve and keep a pointer to it for update
      // get Settings and update the curve. The trick is to do it without delete, insert so that colors are kept
      String title =jPlotNameTextField.getText();
      try {
         if (rangeNames.length!=1){ // delete current curve and perform add
            jPlotterDeletePlotButtonActionPerformed(evt);
            jPlotterAddCurveButtonActionPerformed(evt);
            return;
         }
         String stringx=getDomainName();
         String stringy=rangeNames[0];
         if (stringx.contains(":")){   // Strip qualifiers if any
            String[] names=stringx.split(":",-1);
            stringx=names[names.length-1];
         }
         if (stringy.contains(":")){   // Strip qualifiers if any
            String[] names=stringy.split(":",-1);
            stringy=names[names.length-1];
         }

         plotterModel.updateCurve(currentCurve, title, getSettings(),
                 sourceX, stringx, sourceY.get(0), stringy);
         // Find node and make it selected
         PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(currentCurve);
         TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
         TreePath path = new TreePath(nodes);
         jPlotsTree.setSelectionPath(path);
      } catch (PlotterException ex) {
         ex.printStackTrace();
      }
      
   }//GEN-LAST:event_jPlotterUpdatePlotButtonActionPerformed
      
   private void jCurveLegendTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCurveLegendTextFieldActionPerformed
      
      autoGeneratedCurveTitle=false;   // user modified the text field don't intervene!'
   }//GEN-LAST:event_jCurveLegendTextFieldActionPerformed
   /**
    * Function to be invoked when the Add button is pressed
    */
   //XX5
   private void jPlotterAddCurveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterAddCurveButtonActionPerformed
      // The following should repeat for every single Y qty selected
      String title = jPlotNameTextField.getText();
      PlotCurve plotCurve=null;
      try {
         if (isBuiltinMuscleCurve()){
            // run AnalysisTool once since model can't change in between'
            runAnalysisTool((PlotterSourceAnalysis) sourceY.get(0), sourceX, rangeNames);
         }
         // get Storages from sources
         int numCurves = sumCurve?1:rangeNames.length;
         for(int curveIndex=0; curveIndex<numCurves; curveIndex++){
            PlotCurveSettings settings  = getSettings();
            if (rangeNames.length>1){
               if (autoGeneratedCurveTitle)
                  settings.setName(rangeNames[curveIndex]+ " vs. "+getDomainName());
               else
                  settings.setName(settings.getName()+" "+String.valueOf(curveIndex));
            }
            plotCurve = plotterModel.addCurve(title, settings,
                    sourceX, getDomainName(), sourceY.get(0), rangeNames[curveIndex]);
         }
         makeCurveCurrent(plotCurve);
         
      } catch (PlotterException ex) {
         // Popup a dialog explaining what went wrong
         JOptionPane.showMessageDialog(this, ex.getMessage());
      }
      this.doLayout();
      repaint();
   }//GEN-LAST:event_jPlotterAddCurveButtonActionPerformed
   
   private void makeCurveCurrent(final PlotCurve plotCurve) {
      // Find node and make it selected
      PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(plotCurve);
      TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
      TreePath path = new TreePath(nodes);
      jPlotsTree.setSelectionPath(path);
      rangeNames = new String[]{plotCurve.getRangeName()};
   }
   
   private void jLoadFileToPlotterMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jLoadFileToPlotterMenuItemActionPerformed
      
      // Browse for Storage or Motion file (for now) and preprocess the file if needed for plotting
      String dataFilename = FileUtils.getInstance().browseForFilename(".sto, .mot", "Files containing data to plot", true);
      if (dataFilename != null){
         try {
            PlotterSourceFile src = new PlotterSourceFile(dataFilename);
            getPlotterModel().addSource(src);
         } catch (IOException ex) {
            ex.printStackTrace();
         }
      }
   }//GEN-LAST:event_jLoadFileToPlotterMenuItemActionPerformed
   
   
   public PlotterModel getPlotterModel() {
      return plotterModel;
   }
   
   private PlotCurveSettings getSettings() {
      return new PlotCurveSettings(this);
   }
   
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JButton jAdvancedOptionsButton;
   private javax.swing.JPanel jAdvancedPanel;
   private javax.swing.JCheckBox jClampCheckBox;
   private javax.swing.JTextField jCurveLegendTextField;
   private javax.swing.JFormattedTextField jDomainEndTextField;
   private javax.swing.JFormattedTextField jDomainStartTextField;
   private javax.swing.JFormattedTextField jFormattedTextFieldYmax;
   private javax.swing.JFormattedTextField jFormattedTextFieldYmin;
   private javax.swing.JLabel jLabel1;
   private javax.swing.JLabel jLabel10;
   private javax.swing.JLabel jLabel2;
   private javax.swing.JLabel jLabel3;
   private javax.swing.JLabel jLabel9;
   private javax.swing.JMenuItem jLoadFileToPlotterMenuItem;
   private javax.swing.JPopupMenu jMusclePopupMenu;
   private javax.swing.JButton jMuscleSelectButton;
   private javax.swing.JPanel jPanel1;
   private javax.swing.JPanel jPanel10;
   private javax.swing.JPanel jPlotControlPanel;
   private javax.swing.JLabel jPlotLabelJLabel;
   private javax.swing.JTextField jPlotNameTextField;
   private javax.swing.JPanel jPlotNavigationPanel;
   private javax.swing.JPanel jPlotSpecPanel;
   private javax.swing.JPanel jPlotTitlePanel;
   private javax.swing.JTree jPlotsTree;
   private javax.swing.JButton jPlotterAddPlotButton;
   private javax.swing.JButton jPlotterDeletePlotButton;
   private javax.swing.JMenu jPlotterFileMenu;
   private javax.swing.JMenuBar jPlotterMenuBar;
   private javax.swing.JButton jPlotterUpdatePlotButton;
   private javax.swing.JCheckBox jRectifyCheckBox;
   private javax.swing.JScrollPane jScrollPane1;
   private javax.swing.JTextField jSelectedMusclesTextField;
   private javax.swing.JPopupMenu jSourcePopupMenu;
   private javax.swing.JSplitPane jSplitPane1;
   private javax.swing.JTextField jSummaryAdvancedTextField;
   private javax.swing.JPanel jTopChartingPanel;
   private javax.swing.JPopupMenu jXPopupMenu;
   private javax.swing.JTextField jXQtyTextField;
   private javax.swing.JTextField jYQtyTextField;
   private javax.swing.JButton xQuantityButton;
   private javax.swing.JButton yQuantityButton;
   // End of variables declaration//GEN-END:variables
   
   public String getPlotName() {
      return jPlotNameTextField.getText();
   }
    /*
    public PlotDataSource getSource() {
        return source;
    }
     
    public void setSource(PlotDataSource source) {
        this.source = source;
    }
     */
   private void updateContextGuiElements() {
      currentCurveTitle=getRangeNamesAsString()+" vs. "+getDomainName();
      jCurveLegendTextField.setText(currentCurveTitle);
   }
   
   public boolean isAutoGeneratedCurveTitle() {
      return autoGeneratedCurveTitle;
   }
   
   public void setAutoGeneratedCurveTitle(boolean autoGeneratedCurveTitle) {
      this.autoGeneratedCurveTitle = autoGeneratedCurveTitle;
   }
   
   public String getCurveName() {
      return jCurveLegendTextField.getText();
   }
   /**
    * This method is to be invoked after X or Y selection either when the selection
    *  dialog is brought down or after user typing in data in the X,Y textfields
    * (and probably a few other situations)
    * to update
    *    - default curve name if not modified by user
    *    - X-bounds
    * Very important piece here is parseDomainOrRangeText see comments there.
    */
   public void updatePlotterWithSelection() {
      jPlotterAddPlotButton.setEnabled(validateXY());
      
   }
   /**
    * TreeSelectionListener implementation
    */
   public void valueChanged(TreeSelectionEvent e) {
      getCurrentTreeSelection(e);
      
      jPlotterDeletePlotButton.setEnabled(false);
      jPlotterUpdatePlotButton.setEnabled(false);
      if (selectedPathsVector.size()==0)
         return;
      
      // Make sure we have a curve before enabling update
      if (selectedPathsVector.size()==1){
         TreeNode lastNode=(TreeNode)selectedPathsVector.get(0).getLastPathComponent();
         if (lastNode instanceof PlotCurveNode){
            // Populate dialog
            PlotCurve cv = (PlotCurve)((PlotCurveNode)lastNode).getUserObject();
            updatePanelFromCurve(cv);
            jPlotterUpdatePlotButton.setEnabled(true);
            jPlotterDeletePlotButton.setEnabled(true);
         }
      } else {   // Enable delete if only curves are selected as we can't delete full plots now'
         boolean allCurves=true;
         for(int i=0; i<selectedPathsVector.size() && allCurves; i++){
            TreeNode lastNode=(TreeNode)selectedPathsVector.get(i).getLastPathComponent();
            allCurves =(lastNode instanceof PlotCurveNode);
         }
         jPlotterDeletePlotButton.setEnabled(allCurves);
      }
   }
   
   private void getCurrentTreeSelection(TreeSelectionEvent e) {
      TreePath[] selectedPaths = e.getPaths();
      for(int i=0;i<selectedPaths.length;i++){
         if (e.isAddedPath(i)){
            selectedPathsVector.add(selectedPaths[i]);
         } else {   //Removed
            selectedPathsVector.remove(selectedPaths[i]);
         }
      }
   }
   
   void setMinX(double minX) {
      jDomainStartTextField.setValue(minX);
   }
   
   double getMinX() {
      return ((Double)jDomainStartTextField.getValue()).doubleValue();
   }
   
   void setMaxX(double maxX) {
      jDomainEndTextField.setValue(maxX);
   }
   
   double getMaxX() {
      return ((Double)jDomainEndTextField.getValue()).doubleValue();
   }
   
   boolean getRectify() {
      return jRectifyCheckBox.isSelected();
   }
   /**
    * updatePanelFromCurve is invoked when selection on the tree changes.
    * need to make sure that the following are set
    * PlotterSourceInterface  sourceX, sourceY;
    * String      domainName;
    * String[]    rangeNames;
    */
   private void updatePanelFromCurve(PlotCurve cv) {
      // Populate Curve name, filters
      currentCurve=cv;
      jPlotNameTextField.setText(plotterModel.getPlotForCurve(cv).getTitle());
      sourceX=cv.getDomainSource();
      sourceY.clear();
      sourceY.add(cv.getRangeSource());
      setDomainName(cv.getDomainName());
      rangeNames[0] = cv.getRangeName();
      if (cv.getSettings().isMusclePlot())
         jSelectedMusclesTextField.setText(cv.getRangeName());
      else
         jSelectedMusclesTextField.setText("");
      // set title based on figure title
      jCurveLegendTextField.setText(cv.getLegend());
      setMinX(cv.getSettings().getXMin());
      setMaxX(cv.getSettings().getXMax());
      // Form domain label
      ArrayStr arx = cv.getDomainStorage().getColumnLabels();
      String sourceString=cv.getDomainSource().getDisplayName();
      String colName =arx.getitem(cv.getDomainStorageIndex()+1);
      jXQtyTextField.setText(domainName);
      // Form range label
      ArrayStr ary = cv.getRangeStorage().getColumnLabels();
      sourceString=cv.getRangeSource().getDisplayName();
      colName =ary.getitem(cv.getRangeStorageIndex()+1);
      if (cv.getSettings().isMusclePlot()){
         jYQtyTextField.setText(sourceY.get(0).getDisplayName());
      } else {
         jYQtyTextField.setText(sourceString+":"+colName);
      }
      // Now the filters
      jRectifyCheckBox.setSelected(false);
      Vector<PlotDataFilter> filters = cv.getSettings().getFilters();
      for(int i=0; i<filters.size(); i++){
         if (filters.get(i) instanceof PlotRectifyFilter)
            jRectifyCheckBox.setSelected(true);
         
      }
   }
   
   public void showTimeCurves(String title, String plot, Storage residualsStore, String[] names) {
   }
   
   /**
    * Popups have a single purpose, to populate the Text fields with valid values, but users can
    * type those in manually. The following parse functions try to recover the source storage, columns
    * from the Text fields for quantities. On successful parsing (names and sources local variables are set).
    * The syntax for File sources is File:<xxxx>:<yyyyy>
    **/
   private boolean parseDomainOrRangeText(JTextField jQtyTextField, boolean isDomain) {
      
      String text = jQtyTextField.getText();
      // Check for Empty
      if (text.length()==0)
         return false;
      
      // Check for qualifiers
      // We need to be forgiving in case the user types in the quantity manually
      String trimmed = text.trim();
      // Split around ":
       /*String[] subStrings = trimmed.split(":", 2);
       if (subStrings.length!=2)
           return false;
       String qualifier = subStrings[0];*/
      String columnNameList = trimmed;
      // If file doesn't exist or doesn't have column complain, otherwise
      // set Storage and Column
      String[] columns=columnNameList.trim().split(",",-1);
      if (isDomain){
         if (columns.length!=1){
            JOptionPane.showMessageDialog(this, "Can't have more than one column for domain");
            return false;
         } else{
            setDomainName(columns[0].trim());
            return true; // Should check coordinate exists
         }
      } else {   // range
         for(int i=0; i<columns.length; i++){
            columns[i]=columns[i].trim();
         }
         rangeNames = new String[columns.length];
         System.arraycopy(columns, 0, rangeNames, 0, columns.length);
         // set sourceY here after all error detection is done.
         return true;
      }
      
   }
   /**
    * Get a string representing the list of column names
    */
   private String getRangeNamesAsString() {
      String rep="select Y";
      if (isBuiltinMuscleCurve())
         rep="select muscle";
      if (rangeNames!=null){
         if (isBuiltinMuscleCurve()){
            rep=jYQtyTextField.getText()+":";
         } else
            rep=sourceY.get(0).getDisplayName()+":";
         for(int i=0; i<rangeNames.length; i++){
            rep = rep + rangeNames[i];
            if (i<rangeNames.length-1)
               rep = rep + ",";
         }
      }
      return rep;
   }
   
   public PlotCurve showAnalysisCurveAgainstTime(Model aModel, Storage s,
           String title,
           String curveLegend, String columnName,
           String xLabel, String yLabel) throws PlotterException{
        /*
        sourceX = new PlotterSourceAnalysis(aModel, s, columnName);
        sourceY = sourceX;
        setDomainName("time");
        rangeNames = new String[]{columnName};
        jPlotNameTextField.setText(curveLegend);
        PlotCurveSettings settings  = getSettings();
        PlotCurve plotCurve=null;
        //settings.setXMin(s.getFirstTime());
        //settings.setXMax(s.getLastTime());
        plotCurve = plotterModel.addCurve(title, settings,
                sourceX, getDomainName(),                 sourceY, rangeNames[0]);
        makeCurveCurrent(plotCurve);
         **/
      return null;//;
   }
   /**
    * This will be triggered when motion time changes.
    * Then we need to update X-crosshairs to match time
    */
   public void update(Observable o, Object arg) {
      if (o instanceof MotionsDB) {
         if (arg instanceof MotionTimeChangeEvent){
            MotionTimeChangeEvent motionTimeEvent = (MotionTimeChangeEvent)arg;
            double time=motionTimeEvent.getTime();
            // Should cast arg to proper event and set X-crosshairs
            if (getDomainName().compareTo("time")==0){
               plotterModel.getCurrentPlot().setDomainCrosshair(time);
            }
         }
         else if (arg instanceof MotionEvent){
            MotionEvent mev = (MotionEvent) arg;
            if (mev.getOperation()==mev.getOperation().Open && mev.getModel()==currentModel){
               plotterModel.addMotion(mev.getMotion());
               populateYPopup();
            }
         }
      }
      else if (o instanceof OpenSimDB){
         ModelEvent evt = (ModelEvent)arg;
         if (evt.getModel()==currentModel && evt.getOperation()==ModelEvent.Operation.Close){
               currentModel=null;
               populateYPopup();            
         }
         else if (evt.getOperation()==ModelEvent.Operation.SetCurrent){
               currentModel=evt.getModel();
               populateYPopup();           
         }
      }
   }
   /**
    * Run an analysis to compute curves for muscle analyses operating on current model
    * domainName is assumed to be set. If starts with Motion: then we assume we're plotting
    * against a motion curve otherwise it's vs. Generalized coordinate of the current model
    *
    */
   void runAnalysisTool(PlotterSourceAnalysis source, PlotterSourceInterface motion, String[] ranges) {
      AnalyzeTool tool = plotterModel.getAnalyzeTool(currentModel);
      tool.solveForEquilibrium(true);
      PlotterSourceAnalysis analysisSource = (PlotterSourceAnalysis)source;
      plotterModel.configureAnalyses(tool, analysisSource, domainName, ranges);
      // Save the state before running the analysis so that we can restore the model afterwards
      int numStates = currentModel.getNumStates();
      ArrayStr stateNames = new ArrayStr();
      currentModel.getStateNames(stateNames);
      double[] saveStates = new double[numStates];
      currentModel.getStates(saveStates);
      for(int i=0; i<saveStates.length; i++){
         System.out.println("State"+stateNames.getitem(i)+" value="+saveStates[i]);
         if (stateNames.getitem(i).endsWith(".fiber_length"))
            saveStates[i]=0.01;
         else if (stateNames.getitem(i).endsWith(".activation"))
            saveStates[i]=1.0;        
      }
         // Default start from current values of saveStates
       if (motion != null && motion instanceof PlotterSourceMotion){
         tool.setStartTime( motion.getStorage().getFirstTime());
         tool.setFinalTime( motion.getStorage().getLastTime());
         tool.setStatesStorage(motion.getStorage());
      } else {
         double NUM_STEPS=100.0;
         int xIndex = statesStorage.getStateIndex(getDomainName());
         AbstractCoordinate coord = currentModel.getDynamicsEngine().getCoordinateSet().get(getDomainName());
         
         double domStart=(Double)jDomainStartTextField.getValue();
         double domEnd=(Double)jDomainEndTextField.getValue();
         if (coord.getMotionType() == AbstractDof.DofType.Rotational){
            domStart=Math.toRadians(domStart);
            domEnd=Math.toRadians(domEnd);
         }
         // Make 100 steps along the way, varying the quantity on sourceX by 1/100 of the distance between domStart & domEnd
         statesStorage.purge();
         for(int i=0; i<NUM_STEPS; i++){
            double time = (double)i;
            double increment = 1./NUM_STEPS*(domEnd-domStart);
            double val=domStart+increment*i;
            //double degVal = Math.toDegrees(val);
            //System.out.println("Step="+i+", val="+degVal);
            saveStates[xIndex]=val;
            StateVector newVector = new StateVector();
            newVector.setStates(time, numStates, saveStates);
            statesStorage.append(newVector);
         }
         tool.setStatesStorage(statesStorage);
         tool.setStartTime(0.);
         tool.setFinalTime(NUM_STEPS);
         sourceX=new PlotterSourceAnalysis(currentModel, statesStorage, "");
      }
      currentModel.setStates(saveStates);
      statesStorage.print("toolInput.sto");
      tool.setPrintResultFiles(false);
      analysisSource.getStorage().purge();
      tool.run();
      analysisSource.getStorage().print("toolOutput.sto");
      currentModel.getDynamicsEngine().convertRadiansToDegrees(analysisSource.getStorage());
      currentModel.getDynamicsEngine().convertRadiansToDegrees(statesStorage);
   }
   
   private Storage createStateStorageWithHeader(final Model mdl) {
      // set tool attributes
      Storage statesStorage = new Storage();
      // Column labels for StateStorage
      ArrayStr stateNames = new ArrayStr();
      mdl.getStateNames(stateNames);
      stateNames.insert(0, "time");
      statesStorage.setColumnLabels(stateNames);
      return statesStorage;
   }
   
   private void resetXY() {
      jXQtyTextField.setText("");
      jYQtyTextField.setText("");
      jDomainStartTextField.setText("");
      jDomainEndTextField.setText("");
   }
   
   private void processCurrentModel() {
      if (currentModel!=null){
         initAnalyses();
         statesStorage=createStateStorageWithHeader(currentModel);
      }
      populateYPopup();
   }
   /**
    * Populate the top level pop up for Y-qty to use.
    */
   private void populateYPopup() {
      jSourcePopupMenu.removeAll();
      // Add analyses
      // Add Motions
      // Add files
      if (currentModel!=null){
         // Built in
         ////////////////////////////////////////////////////////////////////////
         // Analyses
         ////////////////////////////////////////////////////////////////////////
         AnalysisSet analyses = currentModel.getAnalysisSet();
         assert(analyses!=null);
         boolean addedSomething=false;
         /// Builtin
         for (int i=0; i< plotterModel.getBuiltinQuantities().length; i++){
            final String qName = plotterModel.getBuiltinQuantities()[i];
            if (qName.startsWith("moment")){   // Need a cascade menu to select a GC
               final String internalName=(qName.equalsIgnoreCase("moment"))?"Moment_":"MomentArm_";
               JMenu gcMenu = new JMenu(qName);
               SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
               String[] coordNames = guiElem.getCoordinateNames();
               for(int j=0; j<coordNames.length; j++){
                  final String coordinateName=coordNames[j];
                  JMenuItem coordinateMenuItem = new JMenuItem(coordinateName);
                  coordinateMenuItem.addActionListener(new ActionListener(){
                     public void actionPerformed(ActionEvent e) {
                        //XX4
                        useMuscles(true);
                        jYQtyTextField.setText(qName+":"+coordinateName);
                        updateContextGuiElements();
                        sourceY.clear();  //Pass in coordinateName to getStorage to select proper one.
                        sourceY.add(new PlotterSourceAnalysis(currentModel, plotterModel.getStorage(internalName+coordinateName, currentModel), qName));
                     }
                  });
                  gcMenu.add(coordinateMenuItem);
               }
               jSourcePopupMenu.add(gcMenu);
               continue;
            }
            JMenuItem quantityMenuItem = new JMenuItem(qName);
            jSourcePopupMenu.add(quantityMenuItem);
            quantityMenuItem.addActionListener(
                    new ActionListener(){
               public void actionPerformed(ActionEvent e) {
                  // Show multipleSelect dialog with all muscles
                  // Populate YQty text field with selection
                  //XX1
                  jYQtyTextField.setText(qName);
                  useMuscles(true);
                  updateContextGuiElements();
                  sourceY.clear();
                  sourceY.add(new PlotterSourceAnalysis(currentModel, plotterModel.getStorage(qName, currentModel), qName));
               }
            });
         }
         // Other Analyses
         for(int i=0;i<analyses.getSize();i++){
            final Analysis nextAnalysis = analyses.get(i);
            if (nextAnalysis.getName().equalsIgnoreCase("MuscleAnalysis"))
               continue;
            JMenu nextAnalysisSubmenu = new JMenu(nextAnalysis.getName());
            // Get storages and create a menu item for each
            ArrayStorage storages = nextAnalysis.getStorageList();
            for(int storageIndex=0; storageIndex<storages.getSize(); storageIndex++){
               final Storage resultStorage = storages.get(storageIndex);
               JMenuItem quantityMenuItem = new JMenuItem(resultStorage.getName());
               nextAnalysisSubmenu.add(quantityMenuItem);
               quantityMenuItem.addActionListener(
                       new ActionListener(){
                  public void actionPerformed(ActionEvent e) {
                     // Show multipleSelect dialog with all muscles
                     // Populate YQty text field with selection
                     //XX1
                     jYQtyTextField.setText(nextAnalysis.getName()+":"+resultStorage.getName());
                     useMuscles(true);
                     updateContextGuiElements();
                     sourceY.clear();
                     sourceY.add(new PlotterSourceAnalysis(currentModel, resultStorage, nextAnalysis.getName()+":"+resultStorage.getName()));
                  }
               });
            }
            jSourcePopupMenu.add(nextAnalysisSubmenu);
            addedSomething=true;
         }  // Current model's analyses'
         jSourcePopupMenu.addSeparator();
         // Now motions
         ////////////////////////////////////////////////////////////////////////
         // Motions
         ////////////////////////////////////////////////////////////////////////
         addedSomething=false;
         ArrayList<Storage> motions = MotionsDB.getInstance().getModelMotions(currentModel);
         if (motions!=null){
            for(int i=0; i<motions.size(); i++){
               Storage nextMotionStorage = motions.get(i);
               final PlotterSourceInterface nextMotion=getPlotterModel().addMotion(nextMotionStorage);
               JMenuItem motionMenuItem = new JMenuItem(nextMotion.getDisplayName()+"...");
               motionMenuItem.addActionListener(new MotionSelectionListener(nextMotion));
                  jSourcePopupMenu.add(motionMenuItem);
                  addedSomething=true;
            }
         }
         if (addedSomething)
            jSourcePopupMenu.addSeparator();
      }
      ////////////////////////////////////////////////////////////////////////
      // Free Files
      ////////////////////////////////////////////////////////////////////////
      // Now add free files
      ArrayList<PlotterSourceFile> fileSources=plotterModel.getLoadedFileSources();
      if (fileSources!=null && fileSources.size()>0){
         for(int i=0; i<fileSources.size(); i++){
            final PlotterSourceFile nextSource = fileSources.get(i);
            JMenuItem fileMenuItem = new JMenuItem(nextSource.getDisplayName()+"...");
            fileMenuItem.addActionListener(new FileSelectionListener(nextSource));
               jSourcePopupMenu.add(fileMenuItem);
         }
      }
      JMenuItem newfileMenuItem = new JMenuItem("New file...");
      newfileMenuItem.addActionListener(new ActionListener(){
         public void actionPerformed(ActionEvent e) {
            // browse for file
            String dataFilename = FileUtils.getInstance().browseForFilename(".sto, .mot", "Files containing data to plot", true);
            if (dataFilename != null){
               PlotterSourceFile src= getPlotterModel().addFile(dataFilename);
               xQuantityButton.setEnabled(getPlotterModel().countSources()>0);
               populateYPopup();
               // Proceed as if it's selected'
               new FileSelectionListener(src).actionPerformed(null);
            }
         }});
         jSourcePopupMenu.add(newfileMenuItem);
   }
   
   private void useMuscles(boolean onOff) {
      boolean oldState=isBuiltinMuscleCurve();
      setBuiltinMuscleCurve(onOff);
      jMuscleSelectButton.setEnabled(onOff);
      if (onOff==false)
         jSelectedMusclesTextField.setText("");
   }
   
   public String getDomainName() {
      if (domainName==null){
         return "select X";
      }
      return domainName;
   }
   
   public void setDomainName(String domainName) {
      this.domainName = domainName;
   }
   
   public boolean isBuiltinMuscleCurve() {
      return builtinMuscleCurve;
   }
   
   public void setBuiltinMuscleCurve(boolean muscleSpecific) {
      this.builtinMuscleCurve = muscleSpecific;
   }
   private boolean validateXY() {
      boolean validXY=false;
      if (sourceY!=null && sourceY.size()>0){   // Same file source in both X, Y
         if (sourceY.get(0) instanceof PlotterSourceFile){
            if ((sourceX!=null) && 
                (sourceX instanceof PlotterSourceFile) && 
                 sourceX.getStorage()==sourceY.get(0).getStorage())
               validXY=sourceX.isValidName(jXQtyTextField.getText());  // Check X is selected
            return validXY;
         }
      }
      else
         return false;
      
      if (sourceY!=null && sourceY.size()>0){   // Same motion source in both X, Y
         if (sourceY.get(0) instanceof PlotterSourceMotion){
            if ((sourceX!=null) && 
                (sourceX instanceof PlotterSourceMotion) && 
                 sourceX.getStorage()==sourceY.get(0).getStorage())
               validXY=sourceX.isValidName(jXQtyTextField.getText());
            return validXY;
         }
      }
      if (builtinMuscleCurve){
         return true;
         // Y is one of the built in quantities or a user's analysis'
         //if (sourceY!=null && sourceY.size()>0){   // Same file source in both X, Y
            //if (sourceY.get(0) instanceof PlotterSourceAnalysis){
               // X could be either a motion, motion column or a gc
               // quantity should always be non-empty either a muscle or a group of muscles
               //int x=0;
            //}
         //}
      }
      return false;
   }

   public boolean isClamp() {
      return clamp;
   }

   public void setClamp(boolean clamp) {
      this.clamp = clamp;
   }

   double getMinY() {
      return ((Double)jFormattedTextFieldYmin.getValue()).doubleValue();
   }

   double getMaxY() {
      return ((Double)jFormattedTextFieldYmax.getValue()).doubleValue();
   }
   class handleReturnAction extends AbstractAction {
        JFormattedTextField jFormattedTextField;
        public handleReturnAction(JFormattedTextField textfield)
        {
           jFormattedTextField = textfield;
        }
        public void actionPerformed(ActionEvent e) {
           if (!jFormattedTextField.isEditValid()) { //The text is invalid.
              String text = jFormattedTextField.getText();
              // Try to parse the text into a double as it could be out of range, in this case truncate
              try {
                  double valueFromTextField = Double.parseDouble(text);
                  jFormattedTextField.setText(String.valueOf(valueFromTextField)) ;
                  jFormattedTextField.commitEdit();
              }
              catch (NumberFormatException ex){
                 // Really invalid text for a double
              }
              catch (ParseException ex){
                 // Really invalid text for a double
              }
         }
        }
     }

   public boolean isModelChanged() {
      return modelChanged;
   }

   public void setModelChanged(boolean modelChanged) {
      this.modelChanged = modelChanged;
   }

   private void invokeTreePopupIfNeeded(int evtX, int evtY) {
      TreePath clickedElement = jPlotsTree.getPathForLocation(evtX, evtY);
            
      //  Display the name of the selected tree element in the selection field
      String clickedElementName;
      if (clickedElement != null){
         clickedElementName = clickedElement.getLastPathComponent().toString();
         System.out.println("Selected a node.");
      }
      
   }

   /** 
    * Handle file selection pick in Quantity Y popup
    */
   private class FileSelectionListener implements ActionListener {

      private PlotterSourceFile nextSource;

      public FileSelectionListener(PlotterSourceFile nextSource) {
         super();
         this.nextSource = nextSource;
      }

      public void actionPerformed(ActionEvent e) {
         sourceY.setSize(1);
         sourceY.set(0, nextSource);
         sourceX = nextSource;
         PlotterQuantityNameFilterJPanel filterpanel = new PlotterQuantityNameFilterJPanel(sourceX);
         DialogDescriptor dlg = new DialogDescriptor(filterpanel, "Select file column");
         dlg.setModal(true);
         DialogDisplayer.getDefault().createDialog(dlg).setVisible(true);
         if (((Integer) dlg.getValue()).compareTo((Integer) DialogDescriptor.OK_OPTION) == 0) {
            jYQtyTextField.setText(sourceX.getDisplayName() + ":" + filterpanel.getSelectedAsString());
            jXQtyTextField.setText("");
            rangeNames = new String[filterpanel.getNumSelected()];
            System.arraycopy(filterpanel.getSelected(), 0, rangeNames, 0, filterpanel.getNumSelected());
            useMuscles(false);
            updateContextGuiElements();
            updatePlotterWithSelection();
         }
      }
   }

   /** 
    * Handle motion pick in Quantity Y popup
    */
   private class MotionSelectionListener implements ActionListener {

      private PlotterSourceInterface nextMotion;

      public MotionSelectionListener(PlotterSourceInterface nextMotion) {
         super();
         this.nextMotion = nextMotion;
      }

      public void actionPerformed(ActionEvent e) {
         sourceY.clear();
         sourceY.add(nextMotion);
         sourceX = sourceY.get(0);
         PlotterQuantityNameFilterJPanel filterpanel = new PlotterQuantityNameFilterJPanel(sourceY.get(0));
         DialogDescriptor dlg = new DialogDescriptor(filterpanel, "Select Motion Column");
         dlg.setModal(true);
         DialogDisplayer.getDefault().createDialog(dlg).setVisible(true);
         if (((Integer) dlg.getValue()).compareTo((Integer) DialogDescriptor.OK_OPTION) == 0) {
            jYQtyTextField.setText(sourceY.get(0).getDisplayName() + ":" + filterpanel.getSelectedAsString());
            jXQtyTextField.setText("");
            rangeNames = new String[filterpanel.getNumSelected()];
            System.arraycopy(filterpanel.getSelected(), 0, rangeNames, 0, filterpanel.getNumSelected());
            useMuscles(false);
            updateContextGuiElements();
            updatePlotterWithSelection();
         }
      }
   }


}
