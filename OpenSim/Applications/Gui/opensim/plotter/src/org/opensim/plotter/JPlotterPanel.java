/*
 * JPlotterPanel.java
 *
 * Created on April 9, 2007, 1:39 PM
 */

package org.opensim.plotter;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Observable;
import java.util.Vector;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import org.openide.DialogDescriptor;
import org.openide.DialogDisplayer;
import org.opensim.modeling.AbstractCoordinate;
import org.opensim.modeling.AbstractDof;
import org.opensim.modeling.Analysis;
import org.opensim.modeling.AnalysisSet;
import org.opensim.modeling.AnalyzeTool;
import org.opensim.modeling.ArrayStr;
import org.opensim.modeling.Model;
import org.opensim.modeling.MomentArmAnalysis;
import org.opensim.modeling.MuscleAnalysis;
import org.opensim.modeling.StateVector;
import org.opensim.modeling.Storage;
import org.opensim.motionviewer.MotionTimeChangeEvent;
import org.opensim.utils.FileUtils;
import org.opensim.motionviewer.MotionsDB;
import org.opensim.view.pub.OpenSimDB;
/**
 *
 * @author  Ayman
 */
public class JPlotterPanel extends javax.swing.JPanel
         implements java.awt.event.ActionListener, javax.swing.event.TreeSelectionListener, java.awt.event.FocusListener, java.util.Observer, java.beans.PropertyChangeListener, java.awt.event.InputMethodListener {
   
   private PlotterModel plotterModel = new PlotterModel();
   public enum PlotDataSource {FileSource, MotionSource, AnalysisSource};
   JPlotterQuantitySelector xSelector = null;
   JPlotterQuantitySelector ySelector = null;
   private PlotDataSource source=PlotDataSource.FileSource;
   String currentCurveTitle="";
   private boolean autoGeneratedCurveTitle=true;
   private boolean autoMinX=true;
   private boolean autoMaxX=true;
   private boolean autoGeneratedPlotTitle=true;
   boolean  validXY=false;
   Vector<TreePath> selectedPathsVector = new Vector<TreePath>(4);   // Cache used to accumulate user selection of the tree
   PlotCurve currentCurve=null;     //used for update
   PlotterSourceInterface  sourceX, sourceY;
   String      domainName;
   String[]    rangeNames;
   
   private String quantityFilterRegex=".*";
   Model currentModel = OpenSimDB.getInstance().getCurrentModel();
   DialogDescriptor dd;
   private Storage statesStorage;
   /**
    * Creates new form JPlotterPanel
    */
   public JPlotterPanel() {
      initComponents();
      jDomainStartTextField.setValue(0.0);
      jDomainEndTextField.setValue(1.0);
      jTopChartingPanel.setLayout(new BorderLayout());
      xSelector = new JPlotterQuantitySelector(jXQtyTextField, this, true);
      ySelector = new JPlotterQuantitySelector(jYQtyTextField, this, false);
      jPlotsTree.addTreeSelectionListener(this);

      jPlotterDeletePlotButton.setEnabled(false);
      jPlotterUpdatePlotButton.setEnabled(false);
      updatePlotterWithSelection();
      // Add in blank figure by default
      jTopChartingPanel.add(plotterModel.getCurrentPlot().getChartPanel());
      processCurrentModel();
   }
   
   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      jFileSourceRadioButton = new javax.swing.JRadioButton();
      sourceButtonGroup = new javax.swing.ButtonGroup();
      jAvailableAnalysesComboBox = new javax.swing.JComboBox();
      jAnalysisSourceRadioButton = new javax.swing.JRadioButton();
      jPlotterMenuBar = new javax.swing.JMenuBar();
      jPlotterFileMenu = new javax.swing.JMenu();
      jLoadFileToPlotterMenuItem = new javax.swing.JMenuItem();
      jSourcePopupMenu = new javax.swing.JPopupMenu();
      jPopupMenu1 = new javax.swing.JPopupMenu();
      jSplitPane1 = new javax.swing.JSplitPane();
      jTopChartingPanel = new javax.swing.JPanel();
      jPlotControlPanel = new javax.swing.JPanel();
      jPlotNavigationPanel = new javax.swing.JPanel();
      jScrollPane1 = new javax.swing.JScrollPane();
      jPlotsTree = new javax.swing.JTree();
      jPanel1 = new javax.swing.JPanel();
      jPlotterAddPlotButton = new javax.swing.JButton();
      jPlotterUpdatePlotButton = new javax.swing.JButton();
      jPlotterDeletePlotButton = new javax.swing.JButton();
      jPlotSpecPanel = new javax.swing.JPanel();
      jLabel2 = new javax.swing.JLabel();
      jCurveNameTextField = new javax.swing.JTextField();
      jPanel9 = new javax.swing.JPanel();
      xQuantityButton = new javax.swing.JButton();
      jXQtyTextField = new javax.swing.JTextField();
      jLabel9 = new javax.swing.JLabel();
      jLabel10 = new javax.swing.JLabel();
      jDomainStartTextField = new javax.swing.JFormattedTextField();
      jDomainEndTextField = new javax.swing.JFormattedTextField();
      jPanel10 = new javax.swing.JPanel();
      jLabel4 = new javax.swing.JLabel();
      jOffsetTextField = new javax.swing.JTextField();
      jRectifyCheckBox = new javax.swing.JCheckBox();
      jLabel3 = new javax.swing.JLabel();
      jScaleTextField = new javax.swing.JTextField();
      yQuantityButton = new javax.swing.JButton();
      jYQtyTextField = new javax.swing.JTextField();
      jSourceSelectionButton = new javax.swing.JButton();
      jSourceDescriptionLabel = new javax.swing.JLabel();
      jPlotTitlePanel = new javax.swing.JPanel();
      jPlotLabelJLabel = new javax.swing.JLabel();
      jPlotNameTextField = new javax.swing.JTextField();

      sourceButtonGroup.add(jFileSourceRadioButton);
      jFileSourceRadioButton.setSelected(true);
      jFileSourceRadioButton.setText("File");
      jFileSourceRadioButton.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jFileSourceRadioButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jFileSourceRadioButton.addActionListener(this);

      jAvailableAnalysesComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
      jAvailableAnalysesComboBox.addActionListener(this);

      sourceButtonGroup.add(jAnalysisSourceRadioButton);
      jAnalysisSourceRadioButton.setText("Existing Sources");
      jAnalysisSourceRadioButton.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jAnalysisSourceRadioButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jAnalysisSourceRadioButton.addActionListener(this);

      jPlotterFileMenu.setText("File");
      jPlotterFileMenu.setToolTipText("load into or save data from plotter.");
      jLoadFileToPlotterMenuItem.setText("Load File...");
      jLoadFileToPlotterMenuItem.setToolTipText("File with data to plot");
      jLoadFileToPlotterMenuItem.addActionListener(this);

      jPlotterFileMenu.add(jLoadFileToPlotterMenuItem);

      jPlotterMenuBar.add(jPlotterFileMenu);

      jSplitPane1.setDividerLocation(280);
      jSplitPane1.setDividerSize(7);
      jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
      jSplitPane1.setResizeWeight(1.0);
      jSplitPane1.setAutoscrolls(true);
      jSplitPane1.setDoubleBuffered(true);
      jSplitPane1.setOneTouchExpandable(true);
      org.jdesktop.layout.GroupLayout jTopChartingPanelLayout = new org.jdesktop.layout.GroupLayout(jTopChartingPanel);
      jTopChartingPanel.setLayout(jTopChartingPanelLayout);
      jTopChartingPanelLayout.setHorizontalGroup(
         jTopChartingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 594, Short.MAX_VALUE)
      );
      jTopChartingPanelLayout.setVerticalGroup(
         jTopChartingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 279, Short.MAX_VALUE)
      );
      jSplitPane1.setLeftComponent(jTopChartingPanel);

      jPlotControlPanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
      jPlotNavigationPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Plots list"));
      jScrollPane1.setAutoscrolls(true);
      jPlotsTree.setModel(plotterModel.getPlotTreeModel());
      jScrollPane1.setViewportView(jPlotsTree);

      jPlotterAddPlotButton.setText("Add");
      jPlotterAddPlotButton.addActionListener(this);

      jPlotterUpdatePlotButton.setText("Update");
      jPlotterUpdatePlotButton.addActionListener(this);

      jPlotterDeletePlotButton.setText("Delete");
      jPlotterDeletePlotButton.addActionListener(this);

      org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
      jPanel1.setLayout(jPanel1Layout);
      jPanel1Layout.setHorizontalGroup(
         jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel1Layout.createSequentialGroup()
            .add(jPlotterAddPlotButton)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotterUpdatePlotButton)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotterDeletePlotButton)
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );
      jPanel1Layout.setVerticalGroup(
         jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jPlotterAddPlotButton)
               .add(jPlotterUpdatePlotButton)
               .add(jPlotterDeletePlotButton))
            .add(6, 6, 6))
      );

      org.jdesktop.layout.GroupLayout jPlotNavigationPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotNavigationPanel);
      jPlotNavigationPanel.setLayout(jPlotNavigationPanelLayout);
      jPlotNavigationPanelLayout.setHorizontalGroup(
         jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotNavigationPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 193, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addContainerGap())
      );
      jPlotNavigationPanelLayout.setVerticalGroup(
         jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPlotNavigationPanelLayout.createSequentialGroup()
            .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 194, Short.MAX_VALUE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
      );

      jPlotSpecPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Curve add/update"));
      jPlotSpecPanel.setToolTipText("Legend:");
      jLabel2.setText("Curve Legend");

      jCurveNameTextField.setText("Curve legend goes here");
      jCurveNameTextField.addActionListener(this);

      xQuantityButton.setText("X-Quantity...");
      xQuantityButton.addActionListener(this);

      jXQtyTextField.addActionListener(this);
      jXQtyTextField.addPropertyChangeListener(this);
      jXQtyTextField.addFocusListener(this);
      jXQtyTextField.addInputMethodListener(this);

      jLabel9.setText("Start");

      jLabel10.setText("End");

      jDomainStartTextField.addPropertyChangeListener(this);

      jDomainEndTextField.addPropertyChangeListener(this);

      org.jdesktop.layout.GroupLayout jPanel9Layout = new org.jdesktop.layout.GroupLayout(jPanel9);
      jPanel9.setLayout(jPanel9Layout);
      jPanel9Layout.setHorizontalGroup(
         jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel9Layout.createSequentialGroup()
            .add(jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
               .add(jPanel9Layout.createSequentialGroup()
                  .add(jLabel9)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED))
               .add(jPanel9Layout.createSequentialGroup()
                  .add(xQuantityButton)
                  .add(18, 18, 18)))
            .add(jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jPanel9Layout.createSequentialGroup()
                  .add(jDomainStartTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 75, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jLabel10)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jDomainEndTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 98, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .addContainerGap())
               .add(jXQtyTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 259, Short.MAX_VALUE)))
      );
      jPanel9Layout.setVerticalGroup(
         jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel9Layout.createSequentialGroup()
            .add(jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(xQuantityButton)
               .add(jXQtyTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jLabel9)
               .add(jDomainStartTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jLabel10)
               .add(jDomainEndTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
      );

      jLabel4.setText("Offset");

      jRectifyCheckBox.setText("Rectify");
      jRectifyCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jRectifyCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));

      jLabel3.setText("Scale");

      yQuantityButton.setText("Y-Quantity...");
      yQuantityButton.addActionListener(this);

      jYQtyTextField.addActionListener(this);
      jYQtyTextField.addFocusListener(this);

      org.jdesktop.layout.GroupLayout jPanel10Layout = new org.jdesktop.layout.GroupLayout(jPanel10);
      jPanel10.setLayout(jPanel10Layout);
      jPanel10Layout.setHorizontalGroup(
         jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel10Layout.createSequentialGroup()
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jPanel10Layout.createSequentialGroup()
                  .addContainerGap()
                  .add(jLabel3)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jScaleTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 77, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .add(13, 13, 13)
                  .add(jLabel4)
                  .add(4, 4, 4)
                  .add(jOffsetTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 69, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jRectifyCheckBox))
               .add(jPanel10Layout.createSequentialGroup()
                  .add(yQuantityButton)
                  .add(19, 19, 19)
                  .add(jYQtyTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 248, Short.MAX_VALUE)))
            .addContainerGap())
      );
      jPanel10Layout.setVerticalGroup(
         jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel10Layout.createSequentialGroup()
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(yQuantityButton)
               .add(jYQtyTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jLabel3)
               .add(jScaleTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jLabel4)
               .add(jOffsetTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jRectifyCheckBox))
            .add(29, 29, 29))
      );

      jSourceSelectionButton.setComponentPopupMenu(jSourcePopupMenu);
      jSourceSelectionButton.setText("Source >");

      org.jdesktop.layout.GroupLayout jPlotSpecPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotSpecPanel);
      jPlotSpecPanel.setLayout(jPlotSpecPanelLayout);
      jPlotSpecPanelLayout.setHorizontalGroup(
         jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotSpecPanelLayout.createSequentialGroup()
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jPlotSpecPanelLayout.createSequentialGroup()
                  .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jPlotSpecPanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .add(jLabel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 69, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                     .add(jSourceSelectionButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 95, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jSourceDescriptionLabel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 273, Short.MAX_VALUE)
                     .add(jCurveNameTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 273, Short.MAX_VALUE)))
               .add(jPanel10, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel9, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addContainerGap())
      );
      jPlotSpecPanelLayout.setVerticalGroup(
         jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotSpecPanelLayout.createSequentialGroup()
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jLabel2)
               .add(jCurveNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(7, 7, 7)
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jSourceDescriptionLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 19, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jSourceSelectionButton))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel10, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 52, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel9, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );

      jPlotTitlePanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Headers"));
      jPlotLabelJLabel.setText("Plot Title");

      jPlotNameTextField.setText("Plot title goes here");
      jPlotNameTextField.setToolTipText("Plot Title");
      jPlotNameTextField.addActionListener(this);

      org.jdesktop.layout.GroupLayout jPlotTitlePanelLayout = new org.jdesktop.layout.GroupLayout(jPlotTitlePanel);
      jPlotTitlePanel.setLayout(jPlotTitlePanelLayout);
      jPlotTitlePanelLayout.setHorizontalGroup(
         jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotTitlePanelLayout.createSequentialGroup()
            .add(jPlotLabelJLabel)
            .add(22, 22, 22)
            .add(jPlotNameTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 311, Short.MAX_VALUE)
            .addContainerGap())
      );
      jPlotTitlePanelLayout.setVerticalGroup(
         jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotTitlePanelLayout.createSequentialGroup()
            .add(jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jPlotLabelJLabel)
               .add(jPlotNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addContainerGap())
      );

      org.jdesktop.layout.GroupLayout jPlotControlPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotControlPanel);
      jPlotControlPanel.setLayout(jPlotControlPanelLayout);
      jPlotControlPanelLayout.setHorizontalGroup(
         jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotControlPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jPlotTitlePanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(jPlotSpecPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotNavigationPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 225, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(3, 3, 3))
      );
      jPlotControlPanelLayout.setVerticalGroup(
         jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotControlPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPlotNavigationPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPlotControlPanelLayout.createSequentialGroup()
                  .add(jPlotTitlePanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jPlotSpecPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
            .add(11, 11, 11))
      );
      jSplitPane1.setRightComponent(jPlotControlPanel);

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 596, Short.MAX_VALUE)
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 574, Short.MAX_VALUE)
      );
   }

   // Code for dispatching events from components to event handlers.

   public void actionPerformed(java.awt.event.ActionEvent evt) {
      if (evt.getSource() == jFileSourceRadioButton) {
         JPlotterPanel.this.jFileSourceRadioButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jAvailableAnalysesComboBox) {
         JPlotterPanel.this.jAvailableAnalysesComboBoxActionPerformed(evt);
      }
      else if (evt.getSource() == jAnalysisSourceRadioButton) {
         JPlotterPanel.this.jAnalysisSourceRadioButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jLoadFileToPlotterMenuItem) {
         JPlotterPanel.this.jLoadFileToPlotterMenuItemActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterAddPlotButton) {
         JPlotterPanel.this.jPlotterAddCurveButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterUpdatePlotButton) {
         JPlotterPanel.this.jPlotterUpdatePlotButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterDeletePlotButton) {
         JPlotterPanel.this.jPlotterDeletePlotButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jCurveNameTextField) {
         JPlotterPanel.this.jCurveNameTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == xQuantityButton) {
         JPlotterPanel.this.xQuantityButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == yQuantityButton) {
         JPlotterPanel.this.yQuantityButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jYQtyTextField) {
         JPlotterPanel.this.jYQtyTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotNameTextField) {
         JPlotterPanel.this.jPlotNameTextFieldActionPerformed(evt);
      }
   }

   public void focusGained(java.awt.event.FocusEvent evt) {
   }

   public void focusLost(java.awt.event.FocusEvent evt) {
      if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldFocusLost(evt);
      }
      else if (evt.getSource() == jYQtyTextField) {
         JPlotterPanel.this.jYQtyTextFieldFocusLost(evt);
      }
   }

   public void caretPositionChanged(java.awt.event.InputMethodEvent evt) {
      if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldCaretPositionChanged(evt);
      }
   }

   public void inputMethodTextChanged(java.awt.event.InputMethodEvent evt) {
   }

   public void propertyChange(java.beans.PropertyChangeEvent evt) {
      if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldPropertyChange(evt);
      }
      else if (evt.getSource() == jDomainStartTextField) {
         JPlotterPanel.this.jDomainStartTextFieldPropertyChange(evt);
      }
      else if (evt.getSource() == jDomainEndTextField) {
         JPlotterPanel.this.jDomainEndTextFieldPropertyChange(evt);
      }
   }// </editor-fold>//GEN-END:initComponents

   private void yQuantityButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_yQuantityButtonActionPerformed
      ySelector.updateList(plotterModel,  sourceY);
      //ySelector.show(evt.getComponent(), evt.getX(), evt.getY());
      //sourceY=sourceX;
      PlotterQuantityNameFilterJPanel filterpanel = new PlotterQuantityNameFilterJPanel(sourceY);
      DialogDescriptor dlg = new DialogDescriptor(filterpanel,"Select Quantity");
      dlg.setModal(true);
      DialogDisplayer.getDefault().createDialog(dlg).setVisible(true);
      if (((Integer)dlg.getValue()).compareTo((Integer)DialogDescriptor.OK_OPTION)==0){
         jYQtyTextField.setText(filterpanel.getSelectedAsString());
         parseDomainOrRangeText(jYQtyTextField, false);
         updatePlotterWithSelection();
      }
// TODO add your handling code here:
   }//GEN-LAST:event_yQuantityButtonActionPerformed

   private void xQuantityButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_xQuantityButtonActionPerformed
// TODO add your handling code here:
      // Make a dialog with available Xs from sourceX. Single selection only
         xSelector.showSingleSelectionPanel(plotterModel,  sourceX);
         /*PlotterQuantityNameFilterJPanel filterpanel = new PlotterQuantityNameFilterJPanel(sourceX);
         DialogDescriptor dlg = new DialogDescriptor(filterpanel,"Select Quantity");
         dlg.setModal(true);
         DialogDisplayer.getDefault().createDialog(dlg).setVisible(true);
         if (((Integer)dlg.getValue()).compareTo((Integer)DialogDescriptor.OK_OPTION)==0){
            jYQtyTextField.setText(sourceY.getDisplayName()+":"+filterpanel.getSelectedAsString());
            parseDomainOrRangeText(jYQtyTextField, false);
            updatePlotterWithSelection();
         }*/
      parseDomainOrRangeText(jXQtyTextField, true);
   }//GEN-LAST:event_xQuantityButtonActionPerformed

   private void jXQtyTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jXQtyTextFieldPropertyChange
// TODO add your handling code here:
   }//GEN-LAST:event_jXQtyTextFieldPropertyChange

   private void jXQtyTextFieldCaretPositionChanged(java.awt.event.InputMethodEvent evt) {//GEN-FIRST:event_jXQtyTextFieldCaretPositionChanged
// TODO add your handling code here:
   }//GEN-LAST:event_jXQtyTextFieldCaretPositionChanged

    private void jAvailableAnalysesComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jAvailableAnalysesComboBoxActionPerformed
// TODO add your handling code here:
        sourceX = (PlotterSourceInterface) ((JComboBox)evt.getSource()).getSelectedItem();
        // If moment arm, setMuscles in the tool so that only selected muscle is used.
        sourceY=sourceX;
        
    }//GEN-LAST:event_jAvailableAnalysesComboBoxActionPerformed

    private void jDomainEndTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jDomainEndTextFieldPropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jDomainEndTextFieldPropertyChange

    private void jDomainStartTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jDomainStartTextFieldPropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jDomainStartTextFieldPropertyChange
    // AnalysisPick
    private void jAnalysisSourceRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jAnalysisSourceRadioButtonActionPerformed
// TODO add your handling code here:
       // Disable file browse
         //jBrowse4FileButton.setEnabled(false);
         // Clearup the X,Y,start,end
         resetXY();
         source=PlotDataSource.AnalysisSource;
         PlotterSourceAnalysis[] availableAnalyses = initAnalyses();
         if (availableAnalyses==null)
            return;
         // Assume first one is selected
         sourceX = availableAnalyses[0];
         sourceY = sourceX;
         //System.gc();
    }//GEN-LAST:event_jAnalysisSourceRadioButtonActionPerformed

   private PlotterSourceAnalysis[] initAnalyses() {
      plotterModel.addModel(currentModel);
      xQuantityButton.setEnabled(true);
      ArrayList<PlotterSourceAnalysis> srcs=plotterModel.getAnalysisSources();
      // Add available quantities to jAvailableAnalysesComboBox
      PlotterSourceAnalysis[] availableAnalyses= new PlotterSourceAnalysis[srcs.size()];
      for(int i=0; i<srcs.size();i++)
          availableAnalyses[i] = srcs.get(i);
      jAvailableAnalysesComboBox.setModel(new DefaultComboBoxModel(availableAnalyses));
      return availableAnalyses;
   }

    private void jFileSourceRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jFileSourceRadioButtonActionPerformed
// TODO add your handling code here:
         //jBrowse4FileButton.setEnabled(true);
         source=PlotDataSource.FileSource;
    }//GEN-LAST:event_jFileSourceRadioButtonActionPerformed

   private void jXQtyTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jXQtyTextFieldFocusLost
      updatePlotterWithSelection();

   }//GEN-LAST:event_jXQtyTextFieldFocusLost

   private void jXQtyTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jXQtyTextFieldActionPerformed
      updatePlotterWithSelection();

   }//GEN-LAST:event_jXQtyTextFieldActionPerformed

   private void jYQtyTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jYQtyTextFieldFocusLost
      updatePlotterWithSelection();

   }//GEN-LAST:event_jYQtyTextFieldFocusLost

   private void jYQtyTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jYQtyTextFieldActionPerformed
      updatePlotterWithSelection();

   }//GEN-LAST:event_jYQtyTextFieldActionPerformed

   private void jPlotterDeletePlotButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterDeletePlotButtonActionPerformed

      // Make a cache so that object deletion does not mess up the selections array
      // we're working on.
      Object[] cache = new Object[selectedPathsVector.size()];
      selectedPathsVector.copyInto(cache);
      for(int i=0;i<cache.length; i++){
         TreePath nextPath = (TreePath)cache[i]; // Since the array shrinks!
         Object[] pathObjects = nextPath.getPath();
         int depth =pathObjects.length-1;
         DefaultMutableTreeNode node = (DefaultMutableTreeNode)pathObjects[depth];
         if (node instanceof PlotNode){
            Plot figToDelete = ((Plot)node.getUserObject());
            System.out.println("Delete figure named "+figToDelete.getTitle());
            plotterModel.deletePlot(figToDelete);
         } else if (node instanceof PlotCurveNode){
            PlotCurve cvToDelete = ((PlotCurve)node.getUserObject());
            plotterModel.deleteCurve(cvToDelete);
            System.out.println("Delete Curve named "+cvToDelete.getLegend());
         } else
            JOptionPane.showMessageDialog(this, "Don't know what to delete!");
         
      }
   }//GEN-LAST:event_jPlotterDeletePlotButtonActionPerformed

   private void jPlotterUpdatePlotButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterUpdatePlotButtonActionPerformed

      // Single Curve is selected, populate the dialog from the Curve and keep a pointer to it for update
      // get Settings and update the curve. The trick is to do it without delete, insert so that colors are kept
      String title =jPlotNameTextField.getText();
      try {
         if (rangeNames.length!=1){ // delete current curve and perform add
             jPlotterDeletePlotButtonActionPerformed(evt);
             jPlotterAddCurveButtonActionPerformed(evt);
             return;
         }
         plotterModel.updateCurve(currentCurve, title, getSettings(), 
                 sourceX, domainName, 
                 sourceY, rangeNames[0]);
         // Find node and make it selected        
         PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(currentCurve);
         TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
         TreePath path = new TreePath(nodes); 
         jPlotsTree.setSelectionPath(path);
      } catch (PlotterException ex) {
         ex.printStackTrace();
      }
      
   }//GEN-LAST:event_jPlotterUpdatePlotButtonActionPerformed

   private void jPlotNameTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotNameTextFieldActionPerformed

      autoGeneratedPlotTitle=false;
   }//GEN-LAST:event_jPlotNameTextFieldActionPerformed

   private void jCurveNameTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCurveNameTextFieldActionPerformed

      autoGeneratedCurveTitle=false;   // user modified the text field don't intervene!'
   }//GEN-LAST:event_jCurveNameTextFieldActionPerformed
   /**
    * Function to be invoked when the Add button is pressed
    */
   private void jPlotterAddCurveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterAddCurveButtonActionPerformed
      // Ask PlotterModel to run first.
      if (sourceY instanceof PlotterSourceAnalysis){
         // Create a storage with Proper values for states to be passed in to the AnalysisTool         
         runAnalysisTool();
      }
      String title = jPlotNameTextField.getText();
      PlotCurve plotCurve=null;
      try {
         // get Storages from sources
         for(int curveIndex=0; curveIndex<rangeNames.length; curveIndex++){
            PlotCurveSettings settings  = getSettings();
            if (rangeNames.length>1){
               if (autoGeneratedCurveTitle)
                  settings.setName(rangeNames[curveIndex]+ " vs. "+domainName);
               else
                  settings.setName(settings.getName()+" "+String.valueOf(curveIndex));
            }
            plotCurve = plotterModel.addCurve(title, settings, 
                                    sourceX, domainName, 
                                    sourceY, rangeNames[curveIndex]);
         }
            makeCurveCurrent(plotCurve);
         
      } catch (PlotterException ex) {
         // Popup a dialog explaining what went wrong
         JOptionPane.showMessageDialog(this, ex.getMessage());
      }
      this.doLayout();
      repaint();
   }//GEN-LAST:event_jPlotterAddCurveButtonActionPerformed

    private void makeCurveCurrent(final PlotCurve plotCurve) {
        // Find node and make it selected        
        PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(plotCurve);
        TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
        TreePath path = new TreePath(nodes); 
        jPlotsTree.setSelectionPath(path);
        rangeNames = new String[]{plotCurve.getRangeName()};
    }
   
   private void jLoadFileToPlotterMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jLoadFileToPlotterMenuItemActionPerformed

      // Browse for Storage or Motion file (for now) and preprocess the file if needed for plotting
      String dataFilename = FileUtils.getInstance().browseForFilename(".sto, .mot", "Files containing data to plot", true);
      if (dataFilename != null){
         PlotterSourceFile src = new PlotterSourceFile(dataFilename);
         getPlotterModel().addSource(src);
      }
   }//GEN-LAST:event_jLoadFileToPlotterMenuItemActionPerformed
   

   public PlotterModel getPlotterModel() {
      return plotterModel;
   }

   private PlotCurveSettings getSettings() {
      return new PlotCurveSettings(this);
   }
   
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JRadioButton jAnalysisSourceRadioButton;
   private javax.swing.JComboBox jAvailableAnalysesComboBox;
   private javax.swing.JTextField jCurveNameTextField;
   private javax.swing.JFormattedTextField jDomainEndTextField;
   private javax.swing.JFormattedTextField jDomainStartTextField;
   private javax.swing.JRadioButton jFileSourceRadioButton;
   private javax.swing.JLabel jLabel10;
   private javax.swing.JLabel jLabel2;
   private javax.swing.JLabel jLabel3;
   private javax.swing.JLabel jLabel4;
   private javax.swing.JLabel jLabel9;
   private javax.swing.JMenuItem jLoadFileToPlotterMenuItem;
   private javax.swing.JTextField jOffsetTextField;
   private javax.swing.JPanel jPanel1;
   private javax.swing.JPanel jPanel10;
   private javax.swing.JPanel jPanel9;
   private javax.swing.JPanel jPlotControlPanel;
   private javax.swing.JLabel jPlotLabelJLabel;
   private javax.swing.JTextField jPlotNameTextField;
   private javax.swing.JPanel jPlotNavigationPanel;
   private javax.swing.JPanel jPlotSpecPanel;
   private javax.swing.JPanel jPlotTitlePanel;
   private javax.swing.JTree jPlotsTree;
   private javax.swing.JButton jPlotterAddPlotButton;
   private javax.swing.JButton jPlotterDeletePlotButton;
   private javax.swing.JMenu jPlotterFileMenu;
   private javax.swing.JMenuBar jPlotterMenuBar;
   private javax.swing.JButton jPlotterUpdatePlotButton;
   private javax.swing.JPopupMenu jPopupMenu1;
   private javax.swing.JCheckBox jRectifyCheckBox;
   private javax.swing.JTextField jScaleTextField;
   private javax.swing.JScrollPane jScrollPane1;
   private javax.swing.JLabel jSourceDescriptionLabel;
   private javax.swing.JPopupMenu jSourcePopupMenu;
   private javax.swing.JButton jSourceSelectionButton;
   private javax.swing.JSplitPane jSplitPane1;
   private javax.swing.JPanel jTopChartingPanel;
   private javax.swing.JTextField jXQtyTextField;
   private javax.swing.JTextField jYQtyTextField;
   private javax.swing.ButtonGroup sourceButtonGroup;
   private javax.swing.JButton xQuantityButton;
   private javax.swing.JButton yQuantityButton;
   // End of variables declaration//GEN-END:variables
   
   public String getPlotName()
   {
      return jPlotNameTextField.getText();
   }

   public PlotDataSource getSource() {
      return source;
   }

   public void setSource(PlotDataSource source) {
      this.source = source;
   }

   private void updatePlotTitle() {
      
   }

   private void updateCurveTitle() {
      if (isAutoGeneratedCurveTitle()){
         currentCurveTitle=getRangeNamesAsString()+" vs. "+domainName;
         jCurveNameTextField.setText(currentCurveTitle);
      }
   }

   public boolean isAutoGeneratedCurveTitle() {
      return autoGeneratedCurveTitle;
   }

   public void setAutoGeneratedCurveTitle(boolean autoGeneratedCurveTitle) {
      this.autoGeneratedCurveTitle = autoGeneratedCurveTitle;
   }

   public boolean isAutoGeneratedPlotTitle() {
      return autoGeneratedPlotTitle;
   }

   public void setAutoGeneratedPlotTitle(boolean autoGeneratedPlotTitle) {
      this.autoGeneratedPlotTitle = autoGeneratedPlotTitle;
   }

   public String getCurveName() {
      return jCurveNameTextField.getText();
   }
   /**
    * This method is to be invoked after X or Y selection either when the selection 
    *  dialog is brought down or after user typing in data in the X,Y textfields 
    * (and probably a few other situations)
    * to update 
    *    - default curve name if not modified by user
    *    - X-bounds
    * Very important piece here is parseDomainOrRangeText see comments there.
    */
   public void updatePlotterWithSelection()
   {
      // For now anything in x,y text fields is taken as valid, instead we should do more 
      // validation that quantities indicated do exist.
      /*
      boolean validX = parseDomainOrRangeText(jXQtyTextField, true);
      if (validX){
          Storage s = sourceX.getStorage();
          if (autoMinX && autoMaxX){
              // Get bounds for domain in proper units
              setMinX(sourceX.getDefaultMin(domainName));
              setMaxX(sourceX.getDefaultMax(domainName));
          }
      }
      yQuantityButton.setEnabled(validX);
      boolean validY = parseDomainOrRangeText(jYQtyTextField, false);
      validXY = validX && validY;
      if (!validXY){
         // Disable Add
         jPlotterAddPlotButton.setEnabled(false);
         return;
      }
       **/
      jPlotterAddPlotButton.setEnabled(true);
      //updatePlotTitle();
      //updateCurveTitle();
      
   }
   /**
    * TreeSelectionListener implementation
    */
   public void valueChanged(TreeSelectionEvent e) {
      getCurrentTreeSelection(e);
      
      jPlotterDeletePlotButton.setEnabled(false);
      jPlotterUpdatePlotButton.setEnabled(false);
      if (selectedPathsVector.size()==0)
         return;

      // Make sure we have a curve before enabling update
      if (selectedPathsVector.size()==1){
         TreeNode lastNode=(TreeNode)selectedPathsVector.get(0).getLastPathComponent();
         if (lastNode instanceof PlotCurveNode){
            // Populate dialog
            PlotCurve cv = (PlotCurve)((PlotCurveNode)lastNode).getUserObject();
            updatePanelFromCurve(cv);
            jPlotterUpdatePlotButton.setEnabled(true);
            jPlotterDeletePlotButton.setEnabled(true);
         }
      }
      else {   // Enable delete if only curves are selected as we can't delete full plots now'
         boolean allCurves=true;
         for(int i=0; i<selectedPathsVector.size() && allCurves; i++){
            TreeNode lastNode=(TreeNode)selectedPathsVector.get(i).getLastPathComponent();
            allCurves =(lastNode instanceof PlotCurveNode);
         }
         jPlotterDeletePlotButton.setEnabled(allCurves);
      }
   }

   private void getCurrentTreeSelection(TreeSelectionEvent e) {
      TreePath[] selectedPaths = e.getPaths();
      for(int i=0;i<selectedPaths.length;i++){
         if (e.isAddedPath(i)){
            selectedPathsVector.add(selectedPaths[i]);
         }
         else {   //Removed
            selectedPathsVector.remove(selectedPaths[i]);         
         }
      }
      //System.out.println("Current selection size ="+selectedPathsVector.size());
   }
   
   void setMinX(double minX)
   {
      jDomainStartTextField.setValue(minX);
   }
   
   double getMinX()
   {
      return ((Double)jDomainStartTextField.getValue()).doubleValue();
   }
   
   void setMaxX(double maxX)
   {
      jDomainEndTextField.setValue(maxX);
   }
   
   double getMaxX()
   {
      return ((Double)jDomainEndTextField.getValue()).doubleValue();
   }

   double getScaleFactor() {
      String text=jScaleTextField.getText();
      if (text.compareTo("")==0) return 1.0;
      return Double.parseDouble(text);
   }

   double getOffset() {
      String text=jOffsetTextField.getText();
      if (text.compareTo("")==0) return 0.0;
      return Double.parseDouble(text);
   }

   boolean getRectify() {
      return jRectifyCheckBox.isSelected();
   }
   /**
    * updatePanelFromCurve is invoked when selection on the tree changes.
    * need to make sure that the following are set
    * PlotterSourceInterface  sourceX, sourceY;
    * String      domainName;
    * String[]    rangeNames;
    */
   private void updatePanelFromCurve(PlotCurve cv) {
      // Populate Curve name, filters
      currentCurve=cv;
      jPlotNameTextField.setText(plotterModel.getPlotForCurve(cv).getTitle());
      sourceX=cv.getDomainSource();
      sourceY=cv.getRangeSource();
      domainName = cv.getDomainName();
      rangeNames[0] = cv.getRangeName();
      // set title based on figure title
      jCurveNameTextField.setText(cv.getLegend());
      setMinX(cv.getSettings().getXMin());
      setMaxX(cv.getSettings().getXMax());
      // Form domain label
      ArrayStr arx = cv.getDomainStorage().getColumnLabels();
      String sourceString=cv.getDomainSource().getDisplayName();
      String colName =arx.getitem(cv.getDomainStorageIndex()+1);
      jXQtyTextField.setText(sourceString+":"+colName);
      // Form range label
      ArrayStr ary = cv.getRangeStorage().getColumnLabels();
      sourceString=cv.getRangeSource().getDisplayName();
      colName =ary.getitem(cv.getRangeStorageIndex()+1);
      jYQtyTextField.setText(sourceString+":"+colName);
      // Now the filters
      jRectifyCheckBox.setSelected(false);
      jOffsetTextField.setText("");
      jScaleTextField.setText("");
      Vector<PlotDataFilter> filters = cv.getSettings().getFilters();
      for(int i=0; i<filters.size(); i++){
         if (filters.get(i) instanceof PlotOffsetFilter)
            jOffsetTextField.setText(String.valueOf(((PlotOffsetFilter)filters.get(i)).value));
         if (filters.get(i) instanceof PlotScaleFilter)
            jScaleTextField.setText(String.valueOf(((PlotScaleFilter)filters.get(i)).value));
         if (filters.get(i) instanceof PlotRectifyFilter)
            jRectifyCheckBox.setSelected(true);
         
      }
   }
   
   public void showTimeCurves(String title, String plot, Storage residualsStore, String[] names) {
      PlotCurve plotCurve=null;
/*      try {
         // Create a source from the Storage
         
         for(int i=0; i<names.length; i++) {
         plotCurve = plotterModel.addCurve(title, getSettings(), 
                 residualsStore, "time", 
                 residualsStore, names[i]);
         // Find node and make it selected        
         PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(plotCurve);
         TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
         TreePath path = new TreePath(nodes); 
         jPlotsTree.setSelectionPath(path);
         }
         
      } catch (PlotterException ex) {
         // Popup a dialog explaining what went wrong
         JOptionPane.showMessageDialog(this, ex.getMessage());
      }*/
     }

   /**
    * Popups have a single purpose, to populate the Text fields with valid values, but users can 
    * type those in manually. The following parse functions try to recover the source storage, columns
    * from the Text fields for quantities. On successful parsing (names and sources local variables are set).
    * The syntax for File sources is File:<xxxx>:<yyyyy>
    **/
   private boolean parseDomainOrRangeText(JTextField jQtyTextField, boolean isDomain) {
       
       String text = jQtyTextField.getText();
       // Check for Empty
       if (text.length()==0)
           return false;
       
       // Check for qualifiers
       // We need to be forgiving in case the user types in the quantity manually
       String trimmed = text.trim();
       // Split around ":
       /*String[] subStrings = trimmed.split(":", 2);
       if (subStrings.length!=2)
           return false;
       String qualifier = subStrings[0];*/
       String columnNameList = trimmed;
       // If file doesn't exist or doesn't have column complain, otherwise
       // set Storage and Column
       String[] columns=columnNameList.trim().split(",",-1);
       if (isDomain){
           if (columns.length!=1){
               JOptionPane.showMessageDialog(this, "Can't have more than one column for domain");
               return false;
           } else{ 
                   domainName = columns[0].trim();
                   return true; // Should check coordinate exists
           }
       } else {   // range
           for(int i=0; i<columns.length; i++){
               columns[i]=columns[i].trim();
               /*if (source==PlotDataSource.FileSource){
                   PlotterSourceFile source = plotterModel.getSource(qualifier, columns[i]);
                   if (source==null){
                       JOptionPane.showMessageDialog(this, "Column "+columns[i]+" does not exist in file "+qualifier);
                       return false;
                   }
               }*/
           }
           rangeNames = new String[columns.length];
           System.arraycopy(columns, 0, rangeNames, 0, columns.length);
           // set sourceY here after all error detection is done.
           return true;
       }
       
   }
   /**
    * Get a string representing the list of column names 
    */
   private String getRangeNamesAsString()
   {
      String rep="";
      for(int i=0; i<rangeNames.length; i++){
         rep = rep + rangeNames[i];
         if (i<rangeNames.length-1)
            rep = rep + ",";
      }
      return rep;
   }

    public PlotCurve showAnalysisCurveAgainstTime(Model aModel, Storage s, 
                                        String title,
                                        String curveLegend, String columnName, 
                                        String xLabel, String yLabel) throws PlotterException{
        sourceX = new PlotterSourceAnalysis(aModel, s, columnName);
        sourceY = sourceX;
        domainName = "time";
        rangeNames = new String[]{columnName};
        jPlotNameTextField.setText(curveLegend);
        PlotCurveSettings settings  = getSettings();
        PlotCurve plotCurve=null;
        //settings.setXMin(s.getFirstTime());
        //settings.setXMax(s.getLastTime());
        plotCurve = plotterModel.addCurve(title, settings, 
                                    sourceX, domainName, 
                                    sourceY, rangeNames[0]);
        makeCurveCurrent(plotCurve);
        return plotCurve;
    }

    String getQuantityFilterRegex() {
        return quantityFilterRegex;
    }

     public void setQuantityFilterRegex(String quantityFilterRegex) {
        this.quantityFilterRegex = quantityFilterRegex;
    }
    /**
     * This will be triggered when motion time changes. 
     * Then we need to update X-crosshairs to match time
     */
    public void update(Observable o, Object arg) {
        if (o instanceof MotionsDB && arg instanceof MotionTimeChangeEvent){
            int x=0;
            MotionTimeChangeEvent motionTimeEvent = (MotionTimeChangeEvent)arg;
            double time=motionTimeEvent.getTime();
            // Should cast arg to proper event and set X-crosshairs
            if (domainName.compareTo("time")==0){
                plotterModel.getCurrentPlot().setDomainCrosshair(time);
            }
        }
    }
    
   void runAnalysisTool() {
      PlotterSourceAnalysis analysisSource = (PlotterSourceAnalysis)sourceY;
      Model mdl = analysisSource.getModel();
      AnalyzeTool tool = plotterModel.getAnalyzeTool(mdl);
      enableDesiredAnalyses(tool, analysisSource);
      double NUM_STEPS=100.0;
      int numStates = mdl.getNumStates();
      double[] states = new double[numStates];
      // Default start from current values of states
      mdl.getStates(states);     
      int xIndex = statesStorage.getStateIndex(domainName);
      AbstractCoordinate coord = mdl.getDynamicsEngine().getCoordinateSet().get(domainName);
      
      double domStart=(Double)jDomainStartTextField.getValue();
      double domEnd=(Double)jDomainEndTextField.getValue();
      if (coord.getMotionType() == AbstractDof.DofType.Rotational){
         domStart=Math.toRadians(domStart);
         domEnd=Math.toRadians(domEnd);
      }
      // Make 100 steps along the way, varying the quantity on sourceX by 1/100 of the distance between domStart & domEnd
      statesStorage.reset();
      for(int i=0; i<NUM_STEPS; i++){
         double time = (double)i;
         double increment = 1./NUM_STEPS*(domEnd-domStart);
         states[xIndex]=domStart+increment*i;
         StateVector newVector = new StateVector();
         newVector.setStates(time, numStates, states);
         statesStorage.append(newVector);
      }
      tool.setStatesStorage(statesStorage);
      tool.setStartTime(0.0);
      tool.setFinalTime(NUM_STEPS);
      statesStorage.print("toolInput.sto");
      tool.run();
      analysisSource.getStorage().print("toolOutput.sto");
      mdl.getDynamicsEngine().convertRadiansToDegrees(analysisSource.getStorage());
      mdl.getDynamicsEngine().convertRadiansToDegrees(statesStorage);
   }

   private Storage createStateStorageWithHeader(final Model mdl) {
      // set tool attributes
      Storage statesStorage = new Storage();
      // Column labels for StateStorage
      ArrayStr stateNames = new ArrayStr();
      mdl.getStateNames(stateNames);
      stateNames.insert(0, "time");
      statesStorage.setColumnLabels(stateNames);
      return statesStorage;
   }

   private void enableDesiredAnalyses(AnalyzeTool tool, PlotterSourceAnalysis analysisSource) {
      String analysisToUse = analysisSource.getDisplayName();
      if (analysisToUse.startsWith("MuscleAnalysis")){
         tool.getModel().getAnalysisSet().get("MuscleAnalysis").setOn(true);
      }
      else if (analysisToUse.startsWith("MomentArm")){
         tool.getModel().getAnalysisSet().get("MomentArmAnalysis").setOn(true);
         
         MomentArmAnalysis maa = MomentArmAnalysis.safeDownCast(tool.getModel().getAnalysisSet().get("MomentArmAnalysis"));
         // Parse muscle names
      }
   }

   private void resetXY() {
      jXQtyTextField.setText("");
      jYQtyTextField.setText("");
      jDomainStartTextField.setText("");
      jDomainEndTextField.setText("");
   }

   private void processCurrentModel() {
      if (currentModel!=null){
         initAnalyses();
      statesStorage=createStateStorageWithHeader(currentModel);
      }
      populateSourcesPopup();
   }
   /**
    * Populate the top level pop up of sources to use. 
    */
   private void populateSourcesPopup() {
      jSourcePopupMenu.removeAll();
      // Add analyses
      // Add Motions
      // Add files
      if (currentModel!=null){
         // Built in
         AnalysisSet analyses = currentModel.getAnalysisSet();
         assert(analyses!=null);
         boolean addedSomething=false;
         for(int i=0;i<analyses.getSize();i++){
            final Analysis nextAnalysis = analyses.get(i);
            JMenuItem analysisPick = new JMenuItem(nextAnalysis.getName()+"...");
            analysisPick.addActionListener(new ActionListener(){
               public void actionPerformed(ActionEvent e) {
                  customize(nextAnalysis);
               }});
            jSourcePopupMenu.add(analysisPick);
            addedSomething=true;
         }
         if (addedSomething)
            jSourcePopupMenu.addSeparator();
         // Now motions
         addedSomething=false;
         ArrayList<Storage> motions = MotionsDB.getInstance().getModelMotions(currentModel);
         if (motions!=null){
            for(int i=0; i<motions.size(); i++){
                  Storage nextMotion = motions.get(i);
                  getPlotterModel().addMotion(nextMotion);
            }
         }
         ArrayList<PlotterSourceMotion> motionSources=plotterModel.getLoadedMotionSources();
         if (motions!=null && motions.size()>0){
            for(int i=0; i<motions.size(); i++){
               final PlotterSourceMotion nextMotion = motionSources.get(i);
               JMenuItem motionMenuItem = new JMenuItem(nextMotion.getDisplayName());
               motionMenuItem.addActionListener(new ActionListener(){
                  public void actionPerformed(ActionEvent e) {
                     jSourceDescriptionLabel.setText(nextMotion.getDisplayName());
                     sourceY = nextMotion;
                     sourceX = sourceY;
                  }});
               jSourcePopupMenu.add(motionMenuItem);
               addedSomething=true;
            }
         }
         if (addedSomething)
            jSourcePopupMenu.addSeparator();
      }
      // Now add free files
      ArrayList<PlotterSourceFile> fileSources=plotterModel.getLoadedFileSources();
      if (fileSources!=null && fileSources.size()>0){
            for(int i=0; i<fileSources.size(); i++){
               final PlotterSourceFile nextSource = fileSources.get(i);
               JMenuItem fileMenuItem = new JMenuItem(nextSource.getDisplayName());
               fileMenuItem.addActionListener(new ActionListener(){
                  public void actionPerformed(ActionEvent e) {
                     jSourceDescriptionLabel.setText("File:"+nextSource.getDisplayName());
                     sourceY = nextSource;
                     sourceX = sourceY;
                  }});
               jSourcePopupMenu.add(fileMenuItem);
            }
      }
      JMenuItem newfileMenuItem = new JMenuItem("New file...");
      newfileMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent e) {
            // browse for file
            String dataFilename = FileUtils.getInstance().browseForFilename(".sto, .mot", "Files containing data to plot", true);
            if (dataFilename != null){
               PlotterSourceFile src= getPlotterModel().addFile(dataFilename);
               xQuantityButton.setEnabled(getPlotterModel().countSources()>0);
               populateSourcesPopup();
               jSourceDescriptionLabel.setText("File:"+src.getDisplayName());
               sourceY = src;
               sourceX = sourceY;
            }
            }});
     jSourcePopupMenu.add(newfileMenuItem);
   }
   private void customize(Analysis nextAnalysis) {
      // bring up property editor on the object
      if (MuscleAnalysis.safeDownCast(nextAnalysis)!=null){
         MuscleAnalysis ma = MuscleAnalysis.safeDownCast(nextAnalysis);
         CustomizeMuscleAnalysisJPanel muscleAnalysisCustomizer = new CustomizeMuscleAnalysisJPanel(ma, plotterModel);
         DialogDescriptor dd = new DialogDescriptor(muscleAnalysisCustomizer , "Customize Analysis");
         dd.setModal(true);
         DialogDisplayer.getDefault().createDialog(dd).setVisible(true);
         sourceY = muscleAnalysisCustomizer.getSelectedSource();
         jSourceDescriptionLabel.setText(sourceY.getDisplayName());
         sourceX = new PlotterSourceAnalysis(currentModel, statesStorage, currentModel.getName());
      }
      else if (MomentArmAnalysis.safeDownCast(nextAnalysis)!=null){
         MuscleAnalysis ma = MuscleAnalysis.safeDownCast(nextAnalysis);
         CustomizeMomentArmAnalysisJPanel muscleAnalysisCustomizer = new CustomizeMomentArmAnalysisJPanel(nextAnalysis, plotterModel);
         DialogDescriptor dd = new DialogDescriptor(muscleAnalysisCustomizer , "Customize Analysis");
         dd.setModal(true);
         DialogDisplayer.getDefault().createDialog(dd).setVisible(true);
         sourceY = muscleAnalysisCustomizer.getSelectedSource();
         jSourceDescriptionLabel.setText(sourceY.getDisplayName());
         sourceX = new PlotterSourceAnalysis(currentModel, statesStorage, currentModel.getName());        
      }
   }
}
