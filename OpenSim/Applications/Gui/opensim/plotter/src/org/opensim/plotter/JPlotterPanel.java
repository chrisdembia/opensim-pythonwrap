/*
 * JPlotterPanel.java
 *
 * Created on April 9, 2007, 1:39 PM
 */

package org.opensim.plotter;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Observable;
import java.util.Vector;
import javax.swing.JCheckBox;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import org.openide.DialogDescriptor;
import org.openide.DialogDisplayer;
import org.opensim.modeling.AbstractCoordinate;
import org.opensim.modeling.AbstractDof;
import org.opensim.modeling.Analysis;
import org.opensim.modeling.AnalysisSet;
import org.opensim.modeling.AnalyzeTool;
import org.opensim.modeling.ArrayStorage;
import org.opensim.modeling.ArrayStr;
import org.opensim.modeling.CoordinateSet;
import org.opensim.modeling.Model;
import org.opensim.modeling.MomentArmAnalysis;
import org.opensim.modeling.StateVector;
import org.opensim.modeling.Storage;
import org.opensim.motionviewer.MotionTimeChangeEvent;
import org.opensim.utils.FileUtils;
import org.opensim.motionviewer.MotionsDB;
import org.opensim.view.SingleModelGuiElements;
import org.opensim.view.pub.OpenSimDB;
import org.opensim.view.pub.ViewDB;
/**
 *
 * @author  Ayman
 */
public class JPlotterPanel extends javax.swing.JPanel
        implements java.awt.event.ActionListener, javax.swing.event.TreeSelectionListener, java.awt.event.FocusListener, java.util.Observer, java.beans.PropertyChangeListener, java.awt.event.InputMethodListener, java.awt.event.MouseListener {
    
    // PlotterModel kkeps track of two things
    // 1. For motions and free files, a PlotterSourceInterface is created and maintained so that 
    //      files don't need to be re read/parsed'
    // 2. It serves as the model backing the tree of plots/figures.
    private PlotterModel plotterModel = new PlotterModel();
    public enum PlotDataSource {FileSource, MotionSource, AnalysisSource};
    JPlotterQuantitySelector xSelector = null;
    //JPlotterQuantitySelector ySelector = null;
    //private PlotDataSource source=PlotDataSource.FileSource;
    String currentCurveTitle="";
    private boolean autoGeneratedCurveTitle=true;
    private boolean autoGeneratedPlotTitle=true;
    Vector<TreePath> selectedPathsVector = new Vector<TreePath>(4);   // Cache used to accumulate user selection of the tree
    PlotCurve currentCurve=null;     //used for update
    PlotterSourceInterface  sourceX;
    Vector<PlotterSourceInterface> sourceY = new Vector<PlotterSourceInterface>(4);
    private String      domainName;
    String[]    rangeNames;
    private boolean     muscleSpecificAnalysis=false;   // Whether muscle selection is required for specified Y qty
    private String quantityFilterRegex=".*";
    Model currentModel = OpenSimDB.getInstance().getCurrentModel();
    private Storage statesStorage;
    boolean sumCurve=false;
    
    /**
     * Creates new form JPlotterPanel
     */
    public JPlotterPanel() {
        initComponents();
        jDomainStartTextField.setValue(0.0);
        jDomainEndTextField.setValue(1.0);
        jTopChartingPanel.setLayout(new BorderLayout());
        xSelector = new JPlotterQuantitySelector(jXQtyTextField, this, true);
        //ySelector = new JPlotterQuantitySelector(jYQtyTextField, this, false);
        jPlotsTree.addTreeSelectionListener(this);
        
        jPlotterDeletePlotButton.setEnabled(false);
        jPlotterUpdatePlotButton.setEnabled(false);
        updatePlotterWithSelection();
        // Add in blank figure by default
        jTopChartingPanel.add(plotterModel.getCurrentPlot().getChartPanel());
        processCurrentModel();
        useMuscles(false);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      jPlotterMenuBar = new javax.swing.JMenuBar();
      jPlotterFileMenu = new javax.swing.JMenu();
      jLoadFileToPlotterMenuItem = new javax.swing.JMenuItem();
      jSourcePopupMenu = new javax.swing.JPopupMenu();
      jXPopupMenu = new javax.swing.JPopupMenu();
      jMusclePopupMenu = new javax.swing.JPopupMenu();
      jAdvancedPanel = new javax.swing.JPanel();
      jClampCheckBox = new javax.swing.JCheckBox();
      jLabel1 = new javax.swing.JLabel();
      jClampFromTextField = new javax.swing.JTextField();
      jLabel3 = new javax.swing.JLabel();
      jClampToTextField = new javax.swing.JTextField();
      jRectifyCheckBox = new javax.swing.JCheckBox();
      jLabel9 = new javax.swing.JLabel();
      jDomainStartTextField = new javax.swing.JFormattedTextField();
      jLabel10 = new javax.swing.JLabel();
      jDomainEndTextField = new javax.swing.JFormattedTextField();
      jSplitPane1 = new javax.swing.JSplitPane();
      jTopChartingPanel = new javax.swing.JPanel();
      jPlotControlPanel = new javax.swing.JPanel();
      jPlotNavigationPanel = new javax.swing.JPanel();
      jScrollPane1 = new javax.swing.JScrollPane();
      jPlotsTree = new javax.swing.JTree();
      jPanel1 = new javax.swing.JPanel();
      jPlotterAddPlotButton = new javax.swing.JButton();
      jPlotterUpdatePlotButton = new javax.swing.JButton();
      jPlotterDeletePlotButton = new javax.swing.JButton();
      jPlotTitlePanel = new javax.swing.JPanel();
      jPlotLabelJLabel = new javax.swing.JLabel();
      jPlotNameTextField = new javax.swing.JTextField();
      jPlotSpecPanel = new javax.swing.JPanel();
      jLabel2 = new javax.swing.JLabel();
      jPanel10 = new javax.swing.JPanel();
      yQuantityButton = new javax.swing.JButton();
      jYQtyTextField = new javax.swing.JTextField();
      jXQtyTextField = new javax.swing.JTextField();
      xQuantityButton = new javax.swing.JButton();
      jMuscleSelectButton = new javax.swing.JButton();
      jSelectedMusclesTextField = new javax.swing.JTextField();
      jCurveLegendTextField = new javax.swing.JTextField();
      jAdvancedOptionsButton = new javax.swing.JButton();

      jPlotterFileMenu.setText("File");
      jPlotterFileMenu.setToolTipText("load into or save data from plotter.");
      jLoadFileToPlotterMenuItem.setText("Load File...");
      jLoadFileToPlotterMenuItem.setToolTipText("File with data to plot");
      jLoadFileToPlotterMenuItem.addActionListener(this);

      jPlotterFileMenu.add(jLoadFileToPlotterMenuItem);

      jPlotterMenuBar.add(jPlotterFileMenu);

      jClampCheckBox.setText("Clamp");
      jClampCheckBox.setToolTipText("Clamp Y value to limits between from, to");
      jClampCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jClampCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jClampCheckBox.addActionListener(this);

      jLabel1.setText("ymin");

      jClampFromTextField.setToolTipText("minimum y value to plot");
      jClampFromTextField.setEnabled(false);

      jLabel3.setText("ymax");

      jClampToTextField.setToolTipText("minimum y value to plot");
      jClampToTextField.setEnabled(false);
      jClampToTextField.addActionListener(this);

      jRectifyCheckBox.setText("Rectify");
      jRectifyCheckBox.setToolTipText("Plot absolute Y value");
      jRectifyCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jRectifyCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));

      jLabel9.setText("xmin");

      jDomainStartTextField.setToolTipText("domain start");
      jDomainStartTextField.addPropertyChangeListener(this);

      jLabel10.setText("xmax");

      jDomainEndTextField.setToolTipText("domain end");
      jDomainEndTextField.addPropertyChangeListener(this);

      org.jdesktop.layout.GroupLayout jAdvancedPanelLayout = new org.jdesktop.layout.GroupLayout(jAdvancedPanel);
      jAdvancedPanel.setLayout(jAdvancedPanelLayout);
      jAdvancedPanelLayout.setHorizontalGroup(
         jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jAdvancedPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jRectifyCheckBox)
               .add(jAdvancedPanelLayout.createSequentialGroup()
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jClampCheckBox)
                     .add(jAdvancedPanelLayout.createSequentialGroup()
                        .add(jLabel9)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(jDomainStartTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 69, Short.MAX_VALUE))
                     .add(jAdvancedPanelLayout.createSequentialGroup()
                        .add(jLabel1)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(jClampFromTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 69, Short.MAX_VALUE)))
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jLabel3, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 40, Short.MAX_VALUE)
                     .add(jLabel10))
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                     .add(jDomainEndTextField)
                     .add(jClampToTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 65, Short.MAX_VALUE))
                  .addContainerGap())))
      );
      jAdvancedPanelLayout.setVerticalGroup(
         jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jAdvancedPanelLayout.createSequentialGroup()
            .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jAdvancedPanelLayout.createSequentialGroup()
                  .add(55, 55, 55)
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(jLabel3)
                     .add(jClampToTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
               .add(jAdvancedPanelLayout.createSequentialGroup()
                  .addContainerGap()
                  .add(jRectifyCheckBox)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jClampCheckBox)
                  .add(8, 8, 8)
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(jLabel1)
                     .add(jClampFromTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 24, Short.MAX_VALUE)
            .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jLabel9)
               .add(jLabel10)
               .add(jDomainEndTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jDomainStartTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addContainerGap())
      );

      jSplitPane1.setDividerLocation(350);
      jSplitPane1.setDividerSize(7);
      jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
      jSplitPane1.setResizeWeight(1.0);
      jSplitPane1.setAutoscrolls(true);
      jSplitPane1.setDoubleBuffered(true);
      jSplitPane1.setOneTouchExpandable(true);
      org.jdesktop.layout.GroupLayout jTopChartingPanelLayout = new org.jdesktop.layout.GroupLayout(jTopChartingPanel);
      jTopChartingPanel.setLayout(jTopChartingPanelLayout);
      jTopChartingPanelLayout.setHorizontalGroup(
         jTopChartingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 700, Short.MAX_VALUE)
      );
      jTopChartingPanelLayout.setVerticalGroup(
         jTopChartingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 349, Short.MAX_VALUE)
      );
      jSplitPane1.setLeftComponent(jTopChartingPanel);

      jPlotControlPanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
      jPlotNavigationPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Plots list"));
      jScrollPane1.setAutoscrolls(true);
      jPlotsTree.setModel(plotterModel.getPlotTreeModel());
      jScrollPane1.setViewportView(jPlotsTree);

      jPlotterAddPlotButton.setText("Add");
      jPlotterAddPlotButton.addActionListener(this);

      jPlotterUpdatePlotButton.setText("Update");
      jPlotterUpdatePlotButton.addActionListener(this);

      jPlotterDeletePlotButton.setText("Delete");
      jPlotterDeletePlotButton.addActionListener(this);

      org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
      jPanel1.setLayout(jPanel1Layout);
      jPanel1Layout.setHorizontalGroup(
         jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel1Layout.createSequentialGroup()
            .add(jPlotterAddPlotButton)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotterUpdatePlotButton)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotterDeletePlotButton)
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );
      jPanel1Layout.setVerticalGroup(
         jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jPlotterAddPlotButton)
               .add(jPlotterUpdatePlotButton)
               .add(jPlotterDeletePlotButton))
            .add(6, 6, 6))
      );

      org.jdesktop.layout.GroupLayout jPlotNavigationPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotNavigationPanel);
      jPlotNavigationPanel.setLayout(jPlotNavigationPanelLayout);
      jPlotNavigationPanelLayout.setHorizontalGroup(
         jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotNavigationPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 193, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addContainerGap())
      );
      jPlotNavigationPanelLayout.setVerticalGroup(
         jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPlotNavigationPanelLayout.createSequentialGroup()
            .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 166, Short.MAX_VALUE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
      );

      jPlotTitlePanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Headers"));
      jPlotLabelJLabel.setText("Plot Title");

      jPlotNameTextField.setText("Plot title goes here");
      jPlotNameTextField.setToolTipText("Plot Title");
      jPlotNameTextField.addActionListener(this);

      org.jdesktop.layout.GroupLayout jPlotTitlePanelLayout = new org.jdesktop.layout.GroupLayout(jPlotTitlePanel);
      jPlotTitlePanel.setLayout(jPlotTitlePanelLayout);
      jPlotTitlePanelLayout.setHorizontalGroup(
         jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotTitlePanelLayout.createSequentialGroup()
            .add(jPlotLabelJLabel)
            .add(22, 22, 22)
            .add(jPlotNameTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 337, Short.MAX_VALUE)
            .addContainerGap())
      );
      jPlotTitlePanelLayout.setVerticalGroup(
         jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotTitlePanelLayout.createSequentialGroup()
            .add(jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jPlotLabelJLabel)
               .add(jPlotNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addContainerGap())
      );

      jPlotSpecPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Curve add/update"));
      jPlotSpecPanel.setToolTipText("Legend:");
      jLabel2.setText("Curve Legend");

      yQuantityButton.setComponentPopupMenu(jSourcePopupMenu);
      yQuantityButton.setText("Y-Quantity...");
      yQuantityButton.addMouseListener(this);

      jYQtyTextField.setEditable(false);
      jYQtyTextField.addActionListener(this);
      jYQtyTextField.addFocusListener(this);

      jXQtyTextField.setEditable(false);
      jXQtyTextField.addActionListener(this);
      jXQtyTextField.addPropertyChangeListener(this);
      jXQtyTextField.addFocusListener(this);
      jXQtyTextField.addInputMethodListener(this);

      xQuantityButton.setText("X-Quantity...");
      xQuantityButton.addMouseListener(this);

      jMuscleSelectButton.setText("Muscles...");
      jMuscleSelectButton.addMouseListener(this);

      jSelectedMusclesTextField.setEditable(false);

      org.jdesktop.layout.GroupLayout jPanel10Layout = new org.jdesktop.layout.GroupLayout(jPanel10);
      jPanel10.setLayout(jPanel10Layout);
      jPanel10Layout.setHorizontalGroup(
         jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel10Layout.createSequentialGroup()
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel10Layout.createSequentialGroup()
                  .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                     .add(org.jdesktop.layout.GroupLayout.LEADING, jMuscleSelectButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                     .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel10Layout.createSequentialGroup()
                        .add(2, 2, 2)
                        .add(xQuantityButton)))
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jXQtyTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 295, Short.MAX_VALUE)
                     .add(jSelectedMusclesTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 295, Short.MAX_VALUE)))
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel10Layout.createSequentialGroup()
                  .add(yQuantityButton)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jYQtyTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 297, Short.MAX_VALUE)))
            .addContainerGap())
      );
      jPanel10Layout.setVerticalGroup(
         jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel10Layout.createSequentialGroup()
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(yQuantityButton)
               .add(jYQtyTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jMuscleSelectButton)
               .add(jSelectedMusclesTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(xQuantityButton)
               .add(jXQtyTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
      );

      jCurveLegendTextField.setText("Curve legend goes here");
      jCurveLegendTextField.addActionListener(this);

      jAdvancedOptionsButton.setText("Advanced...");
      jAdvancedOptionsButton.addActionListener(this);

      org.jdesktop.layout.GroupLayout jPlotSpecPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotSpecPanel);
      jPlotSpecPanel.setLayout(jPlotSpecPanelLayout);
      jPlotSpecPanelLayout.setHorizontalGroup(
         jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotSpecPanelLayout.createSequentialGroup()
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPlotSpecPanelLayout.createSequentialGroup()
                  .addContainerGap()
                  .add(jLabel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 69, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .add(22, 22, 22)
                  .add(jCurveLegendTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 299, Short.MAX_VALUE))
               .add(org.jdesktop.layout.GroupLayout.LEADING, jAdvancedOptionsButton))
            .addContainerGap())
         .add(jPanel10, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
      );
      jPlotSpecPanelLayout.setVerticalGroup(
         jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotSpecPanelLayout.createSequentialGroup()
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jLabel2)
               .add(jCurveLegendTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel10, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jAdvancedOptionsButton)
            .addContainerGap())
      );

      org.jdesktop.layout.GroupLayout jPlotControlPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotControlPanel);
      jPlotControlPanel.setLayout(jPlotControlPanelLayout);
      jPlotControlPanelLayout.setHorizontalGroup(
         jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotControlPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jPlotTitlePanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(jPlotSpecPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .add(11, 11, 11)
            .add(jPlotNavigationPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addContainerGap())
      );
      jPlotControlPanelLayout.setVerticalGroup(
         jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotControlPanelLayout.createSequentialGroup()
            .add(jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPlotNavigationPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPlotControlPanelLayout.createSequentialGroup()
                  .add(jPlotTitlePanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jPlotSpecPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
            .addContainerGap(24, Short.MAX_VALUE))
      );
      jSplitPane1.setRightComponent(jPlotControlPanel);

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 702, Short.MAX_VALUE)
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 628, Short.MAX_VALUE)
      );
   }

   // Code for dispatching events from components to event handlers.

   public void actionPerformed(java.awt.event.ActionEvent evt) {
      if (evt.getSource() == jLoadFileToPlotterMenuItem) {
         JPlotterPanel.this.jLoadFileToPlotterMenuItemActionPerformed(evt);
      }
      else if (evt.getSource() == jClampCheckBox) {
         JPlotterPanel.this.jClampCheckBoxActionPerformed(evt);
      }
      else if (evt.getSource() == jClampToTextField) {
         JPlotterPanel.this.jClampToTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterAddPlotButton) {
         JPlotterPanel.this.jPlotterAddCurveButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterUpdatePlotButton) {
         JPlotterPanel.this.jPlotterUpdatePlotButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterDeletePlotButton) {
         JPlotterPanel.this.jPlotterDeletePlotButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotNameTextField) {
         JPlotterPanel.this.jPlotNameTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jYQtyTextField) {
         JPlotterPanel.this.jYQtyTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jCurveLegendTextField) {
         JPlotterPanel.this.jCurveLegendTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jAdvancedOptionsButton) {
         JPlotterPanel.this.jAdvancedOptionsButtonActionPerformed(evt);
      }
   }

   public void focusGained(java.awt.event.FocusEvent evt) {
   }

   public void focusLost(java.awt.event.FocusEvent evt) {
      if (evt.getSource() == jYQtyTextField) {
         JPlotterPanel.this.jYQtyTextFieldFocusLost(evt);
      }
      else if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldFocusLost(evt);
      }
   }

   public void caretPositionChanged(java.awt.event.InputMethodEvent evt) {
      if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldCaretPositionChanged(evt);
      }
   }

   public void inputMethodTextChanged(java.awt.event.InputMethodEvent evt) {
   }

   public void mouseClicked(java.awt.event.MouseEvent evt) {
   }

   public void mouseEntered(java.awt.event.MouseEvent evt) {
   }

   public void mouseExited(java.awt.event.MouseEvent evt) {
   }

   public void mousePressed(java.awt.event.MouseEvent evt) {
      if (evt.getSource() == yQuantityButton) {
         JPlotterPanel.this.yQuantityButtonMousePressed(evt);
      }
      else if (evt.getSource() == xQuantityButton) {
         JPlotterPanel.this.xQuantityButtonMousePressed(evt);
      }
      else if (evt.getSource() == jMuscleSelectButton) {
         JPlotterPanel.this.jMuscleSelectButtonMousePressed(evt);
      }
   }

   public void mouseReleased(java.awt.event.MouseEvent evt) {
      if (evt.getSource() == yQuantityButton) {
         JPlotterPanel.this.yQuantityButtonMouseReleased(evt);
      }
      else if (evt.getSource() == xQuantityButton) {
         JPlotterPanel.this.xQuantityButtonMouseReleased(evt);
      }
      else if (evt.getSource() == jMuscleSelectButton) {
         JPlotterPanel.this.jMuscleSelectButtonMouseReleased(evt);
      }
   }

   public void propertyChange(java.beans.PropertyChangeEvent evt) {
      if (evt.getSource() == jDomainStartTextField) {
         JPlotterPanel.this.jDomainStartTextFieldPropertyChange(evt);
      }
      else if (evt.getSource() == jDomainEndTextField) {
         JPlotterPanel.this.jDomainEndTextFieldPropertyChange(evt);
      }
      else if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldPropertyChange(evt);
      }
   }// </editor-fold>//GEN-END:initComponents

    private void jAdvancedOptionsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jAdvancedOptionsButtonActionPerformed
// TODO add your handling code here:
        DialogDescriptor dd = new DialogDescriptor(jAdvancedPanel, "AdvancedOptions");
        dd.setModal(true);
        DialogDisplayer.getDefault().createDialog(dd).setVisible(true);
        
    }//GEN-LAST:event_jAdvancedOptionsButtonActionPerformed

    private void jClampCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jClampCheckBoxActionPerformed
// TODO add your handling code here:
        JCheckBox clamped = (JCheckBox)evt.getSource();
        jClampFromTextField.setEnabled(clamped.isSelected());
        jClampToTextField.setEnabled(clamped.isSelected());
    }//GEN-LAST:event_jClampCheckBoxActionPerformed

    private void jMuscleSelectButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jMuscleSelectButtonMouseReleased
// TODO add your handling code here:
        jMuscleSelectButtonMousePressed(evt);
    }//GEN-LAST:event_jMuscleSelectButtonMouseReleased

    private void jMuscleSelectButtonMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jMuscleSelectButtonMousePressed
// TODO add your handling code here:
        // Show muscle selection, multiple
        //XX2
        SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
        String[] muscleNames = guiElem.getActuatorNames();
        QuantityNameFilterJPanel filterPanel = new QuantityNameFilterJPanel(muscleNames);
        DialogDescriptor dlg = new DialogDescriptor(filterPanel,"Select Muscles");
        dlg.setModal(true);
        DialogDisplayer.getDefault().createDialog(dlg).setVisible(true);
        jSelectedMusclesTextField.setText(filterPanel.getSelectedAsString());
        sumCurve=filterPanel.isSumOnly();
        rangeNames = filterPanel.getSelectedAsString().trim().split(",",-1);
        for(int i=0;i<rangeNames.length;i++)
            rangeNames[i]=rangeNames[i].trim();
        updateContextGuiElements();
        // If moment arm analysis, set muscles to rangeNames
 
    }//GEN-LAST:event_jMuscleSelectButtonMousePressed

    private void xQuantityButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_xQuantityButtonMouseReleased
// TODO add your handling code here:
        xQuantityButtonMousePressed(evt);
    }//GEN-LAST:event_xQuantityButtonMouseReleased

    private void xQuantityButtonMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_xQuantityButtonMousePressed
// TODO add your handling code here:
        //XX3
        if (isMuscleSpecificAnalysis()){
            // May plot against motion curve or against a GC
            jXPopupMenu.removeAll();
            SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
            String[] coordNames = guiElem.getCoordinateNames();
            for(int i=0; i<coordNames.length; i++){
                final String coordinateName=coordNames[i];
                JMenuItem coordinateMenuItem = new JMenuItem(coordinateName);
                coordinateMenuItem.addActionListener(new ActionListener(){
                    public void actionPerformed(ActionEvent e) {
                        setDomainName(coordinateName);
                        jXQtyTextField.setText(coordinateName);
                        CoordinateSet cs = currentModel.getDynamicsEngine().getCoordinateSet();
                        AbstractCoordinate coord = cs.get(coordinateName);
                        double conversionToGuiUnits=(coord.getMotionType()==AbstractDof.DofType.Rotational)?Math.toDegrees(1.0):1.0;
                        long l=Math.round(conversionToGuiUnits*coord.getRangeMin());
                        jDomainStartTextField.setValue((double)l);
                        l=Math.round(conversionToGuiUnits*coord.getRangeMax());
                        jDomainEndTextField.setValue((double)l);
                        updateContextGuiElements();
                    }
                });
                jXPopupMenu.add(coordinateMenuItem);
            }
            jXPopupMenu.addSeparator();
            // or motions make a cascade menu 
            ArrayList<PlotterSourceMotion> motionSources=plotterModel.getLoadedMotionSources();
            for(int i=0; i<motionSources.size(); i++){
                final PlotterSourceMotion nextMotion = motionSources.get(i);
                JMenuItem motionMenuItem = new JMenuItem(nextMotion.getDisplayName());
                motionMenuItem.addActionListener(new ActionListener(){
                    public void actionPerformed(ActionEvent e) {
                        setDomainName(nextMotion.getDisplayName()+":time");
                        jXQtyTextField.setText(nextMotion.getDisplayName()+":time");
                        jDomainStartTextField.setValue((double)nextMotion.getDefaultMin("time"));
                        jDomainEndTextField.setValue((double)nextMotion.getDefaultMax("time"));
                        sourceX=nextMotion;
                        updateContextGuiElements();
                    }
                });
                jXPopupMenu.add(motionMenuItem);
            }
            jXPopupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
        } else{
            xSelector.showSingleSelectionPanel(plotterModel,  sourceX);
            jDomainStartTextField.setValue((double)sourceX.getDefaultMin("time"));
            jDomainEndTextField.setValue((double)sourceX.getDefaultMax("time"));
            
            updateContextGuiElements();
        }
        parseDomainOrRangeText(jXQtyTextField, true);

    }//GEN-LAST:event_xQuantityButtonMousePressed
    
    private void yQuantityButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_yQuantityButtonMouseReleased
// TODO add your handling code here:
        yQuantityButtonMousePressed(evt);
    }//GEN-LAST:event_yQuantityButtonMouseReleased
    
    private void yQuantityButtonMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_yQuantityButtonMousePressed
// TODO add your handling code here:
        jSourcePopupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
    }//GEN-LAST:event_yQuantityButtonMousePressed
    
    private void jClampToTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jClampToTextFieldActionPerformed
// TODO add your handling code here:
    }//GEN-LAST:event_jClampToTextFieldActionPerformed
      
   private void jXQtyTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jXQtyTextFieldPropertyChange
// TODO add your handling code here:
   }//GEN-LAST:event_jXQtyTextFieldPropertyChange
   
   private void jXQtyTextFieldCaretPositionChanged(java.awt.event.InputMethodEvent evt) {//GEN-FIRST:event_jXQtyTextFieldCaretPositionChanged
// TODO add your handling code here:
   }//GEN-LAST:event_jXQtyTextFieldCaretPositionChanged
   
    private void jDomainEndTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jDomainEndTextFieldPropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jDomainEndTextFieldPropertyChange
    
    private void jDomainStartTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jDomainStartTextFieldPropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jDomainStartTextFieldPropertyChange
    // AnalysisPick
    private PlotterSourceAnalysis[] initAnalyses() {
        plotterModel.addModel(currentModel);
        xQuantityButton.setEnabled(true);
        ArrayList<PlotterSourceAnalysis> srcs=plotterModel.getAnalysisSources();
        // Add available quantities to jAvailableAnalysesComboBox
        PlotterSourceAnalysis[] availableAnalyses= new PlotterSourceAnalysis[srcs.size()];
        for(int i=0; i<srcs.size();i++)
            availableAnalyses[i] = srcs.get(i);
        return availableAnalyses;
    }
    
   private void jXQtyTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jXQtyTextFieldFocusLost
       updatePlotterWithSelection();
       
   }//GEN-LAST:event_jXQtyTextFieldFocusLost
   
   private void jXQtyTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jXQtyTextFieldActionPerformed
       updatePlotterWithSelection();
       
   }//GEN-LAST:event_jXQtyTextFieldActionPerformed
   
   private void jYQtyTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jYQtyTextFieldFocusLost
       updatePlotterWithSelection();
       
   }//GEN-LAST:event_jYQtyTextFieldFocusLost
   
   private void jYQtyTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jYQtyTextFieldActionPerformed
       updatePlotterWithSelection();
       
   }//GEN-LAST:event_jYQtyTextFieldActionPerformed
   
   private void jPlotterDeletePlotButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterDeletePlotButtonActionPerformed
       
       // Make a cache so that object deletion does not mess up the selections array
       // we're working on.
       Object[] cache = new Object[selectedPathsVector.size()];
       selectedPathsVector.copyInto(cache);
       for(int i=0;i<cache.length; i++){
           TreePath nextPath = (TreePath)cache[i]; // Since the array shrinks!
           Object[] pathObjects = nextPath.getPath();
           int depth =pathObjects.length-1;
           DefaultMutableTreeNode node = (DefaultMutableTreeNode)pathObjects[depth];
           if (node instanceof PlotNode){
               Plot figToDelete = ((Plot)node.getUserObject());
               System.out.println("Delete figure named "+figToDelete.getTitle());
               plotterModel.deletePlot(figToDelete);
           } else if (node instanceof PlotCurveNode){
               PlotCurve cvToDelete = ((PlotCurve)node.getUserObject());
               plotterModel.deleteCurve(cvToDelete);
               System.out.println("Delete Curve named "+cvToDelete.getLegend());
           } else
               JOptionPane.showMessageDialog(this, "Don't know what to delete!");
           
       }
   }//GEN-LAST:event_jPlotterDeletePlotButtonActionPerformed
   
   private void jPlotterUpdatePlotButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterUpdatePlotButtonActionPerformed
       
       // Single Curve is selected, populate the dialog from the Curve and keep a pointer to it for update
       // get Settings and update the curve. The trick is to do it without delete, insert so that colors are kept
       String title =jPlotNameTextField.getText();
       try {
           if (rangeNames.length!=1){ // delete current curve and perform add
               jPlotterDeletePlotButtonActionPerformed(evt);
               jPlotterAddCurveButtonActionPerformed(evt);
               return;
           }
           plotterModel.updateCurve(currentCurve, title, getSettings(),
                   sourceX, getDomainName(), sourceY.get(0), rangeNames[0]);
           // Find node and make it selected
           PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(currentCurve);
           TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
           TreePath path = new TreePath(nodes);
           jPlotsTree.setSelectionPath(path);
       } catch (PlotterException ex) {
           ex.printStackTrace();
       }
       
   }//GEN-LAST:event_jPlotterUpdatePlotButtonActionPerformed
   
   private void jPlotNameTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotNameTextFieldActionPerformed
       
       autoGeneratedPlotTitle=false;
   }//GEN-LAST:event_jPlotNameTextFieldActionPerformed
   
   private void jCurveLegendTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCurveLegendTextFieldActionPerformed
       
       autoGeneratedCurveTitle=false;   // user modified the text field don't intervene!'
   }//GEN-LAST:event_jCurveLegendTextFieldActionPerformed
   /**
    * Function to be invoked when the Add button is pressed
    */
   //XX5
   private void jPlotterAddCurveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterAddCurveButtonActionPerformed
       // The following should repeat for every single Y qty selected
       String title = jPlotNameTextField.getText();
       PlotCurve plotCurve=null;
       try {
           // get Storages from sources
           int numCurves = sumCurve?1:rangeNames.length;
           for(int curveIndex=0; curveIndex<numCurves; curveIndex++){
               PlotCurveSettings settings  = getSettings();
               if (rangeNames.length>1){
                   if (autoGeneratedCurveTitle)
                       settings.setName(rangeNames[curveIndex]+ " vs. "+getDomainName());
                   else
                       settings.setName(settings.getName()+" "+String.valueOf(curveIndex));
               }
               if (isMuscleSpecificAnalysis()){
                   // Create a storage with Proper values for states to be passed in to the AnalysisTool
                   runAnalysisTool((PlotterSourceAnalysis) sourceY.get(0), sourceX);
               }
               plotCurve = plotterModel.addCurve(title, settings,
                       sourceX, getDomainName(), sourceY.get(0), rangeNames[curveIndex]);
           }
           makeCurveCurrent(plotCurve);
           
       } catch (PlotterException ex) {
           // Popup a dialog explaining what went wrong
           JOptionPane.showMessageDialog(this, ex.getMessage());
       }
       this.doLayout();
       repaint();
   }//GEN-LAST:event_jPlotterAddCurveButtonActionPerformed
   
   private void makeCurveCurrent(final PlotCurve plotCurve) {
       // Find node and make it selected
       PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(plotCurve);
       TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
       TreePath path = new TreePath(nodes);
       jPlotsTree.setSelectionPath(path);
       rangeNames = new String[]{plotCurve.getRangeName()};
   }
   
   private void jLoadFileToPlotterMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jLoadFileToPlotterMenuItemActionPerformed
       
       // Browse for Storage or Motion file (for now) and preprocess the file if needed for plotting
       String dataFilename = FileUtils.getInstance().browseForFilename(".sto, .mot", "Files containing data to plot", true);
       if (dataFilename != null){
         try {
           PlotterSourceFile src = new PlotterSourceFile(dataFilename);
           getPlotterModel().addSource(src);
         } catch (IOException ex) {
            ex.printStackTrace();
       }
       }
   }//GEN-LAST:event_jLoadFileToPlotterMenuItemActionPerformed
   
   
   public PlotterModel getPlotterModel() {
       return plotterModel;
   }
   
   private PlotCurveSettings getSettings() {
       return new PlotCurveSettings(this);
   }
   
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JButton jAdvancedOptionsButton;
   private javax.swing.JPanel jAdvancedPanel;
   private javax.swing.JCheckBox jClampCheckBox;
   private javax.swing.JTextField jClampFromTextField;
   private javax.swing.JTextField jClampToTextField;
   private javax.swing.JTextField jCurveLegendTextField;
   private javax.swing.JFormattedTextField jDomainEndTextField;
   private javax.swing.JFormattedTextField jDomainStartTextField;
   private javax.swing.JLabel jLabel1;
   private javax.swing.JLabel jLabel10;
   private javax.swing.JLabel jLabel2;
   private javax.swing.JLabel jLabel3;
   private javax.swing.JLabel jLabel9;
   private javax.swing.JMenuItem jLoadFileToPlotterMenuItem;
   private javax.swing.JPopupMenu jMusclePopupMenu;
   private javax.swing.JButton jMuscleSelectButton;
   private javax.swing.JPanel jPanel1;
   private javax.swing.JPanel jPanel10;
   private javax.swing.JPanel jPlotControlPanel;
   private javax.swing.JLabel jPlotLabelJLabel;
   private javax.swing.JTextField jPlotNameTextField;
   private javax.swing.JPanel jPlotNavigationPanel;
   private javax.swing.JPanel jPlotSpecPanel;
   private javax.swing.JPanel jPlotTitlePanel;
   private javax.swing.JTree jPlotsTree;
   private javax.swing.JButton jPlotterAddPlotButton;
   private javax.swing.JButton jPlotterDeletePlotButton;
   private javax.swing.JMenu jPlotterFileMenu;
   private javax.swing.JMenuBar jPlotterMenuBar;
   private javax.swing.JButton jPlotterUpdatePlotButton;
   private javax.swing.JCheckBox jRectifyCheckBox;
   private javax.swing.JScrollPane jScrollPane1;
   private javax.swing.JTextField jSelectedMusclesTextField;
   private javax.swing.JPopupMenu jSourcePopupMenu;
   private javax.swing.JSplitPane jSplitPane1;
   private javax.swing.JPanel jTopChartingPanel;
   private javax.swing.JPopupMenu jXPopupMenu;
   private javax.swing.JTextField jXQtyTextField;
   private javax.swing.JTextField jYQtyTextField;
   private javax.swing.JButton xQuantityButton;
   private javax.swing.JButton yQuantityButton;
   // End of variables declaration//GEN-END:variables
    
    public String getPlotName() {
        return jPlotNameTextField.getText();
    }
    /*
    public PlotDataSource getSource() {
        return source;
    }
    
    public void setSource(PlotDataSource source) {
        this.source = source;
    }
    */
    private void updateContextGuiElements() {
        currentCurveTitle=getRangeNamesAsString()+" vs. "+getDomainName();
        jCurveLegendTextField.setText(currentCurveTitle);
        if (sourceY==null){
           xQuantityButton.setText("X-Quantity...");
        }
        else if (isMuscleSpecificAnalysis()){
           xQuantityButton.setText("GC or Motion...");
        }
        else if (sourceY.get(0) instanceof PlotterSourceMotion){
           xQuantityButton.setText(sourceY.get(0).getDisplayName()+"...");
           jSelectedMusclesTextField.setText("");
        }
        else if (sourceY.get(0) instanceof PlotterSourceFile){
           xQuantityButton.setText(sourceY.get(0).getDisplayName()+"...");
           jSelectedMusclesTextField.setText("");
        }
    }
    
    public boolean isAutoGeneratedCurveTitle() {
        return autoGeneratedCurveTitle;
    }
    
    public void setAutoGeneratedCurveTitle(boolean autoGeneratedCurveTitle) {
        this.autoGeneratedCurveTitle = autoGeneratedCurveTitle;
    }
    
    public boolean isAutoGeneratedPlotTitle() {
        return autoGeneratedPlotTitle;
    }
    
    public void setAutoGeneratedPlotTitle(boolean autoGeneratedPlotTitle) {
        this.autoGeneratedPlotTitle = autoGeneratedPlotTitle;
    }
    
    public String getCurveName() {
        return jCurveLegendTextField.getText();
    }
    /**
     * This method is to be invoked after X or Y selection either when the selection
     *  dialog is brought down or after user typing in data in the X,Y textfields
     * (and probably a few other situations)
     * to update
     *    - default curve name if not modified by user
     *    - X-bounds
     * Very important piece here is parseDomainOrRangeText see comments there.
     */
    public void updatePlotterWithSelection() {
        // For now anything in x,y text fields is taken as valid, instead we should do more
        // validation that quantities indicated do exist.
      /*
      boolean validX = parseDomainOrRangeText(jXQtyTextField, true);
      if (validX){
          Storage s = sourceX.getStorage();
          if (autoMinX && autoMaxX){
              // Get bounds for domain in proper units
              setMinX(sourceX.getDefaultMin(domainName));
              setMaxX(sourceX.getDefaultMax(domainName));
          }
      }
      yQuantityButton.setEnabled(validX);
      boolean validY = parseDomainOrRangeText(jYQtyTextField, false);
      validXY = validX && validY;
      if (!validXY){
         // Disable Add
         jPlotterAddPlotButton.setEnabled(false);
         return;
      }
       **/
        jPlotterAddPlotButton.setEnabled(true);
        //updateContextGuiElements();
        //updateCurveTitle();
        
    }
    /**
     * TreeSelectionListener implementation
     */
    public void valueChanged(TreeSelectionEvent e) {
        getCurrentTreeSelection(e);
        
        jPlotterDeletePlotButton.setEnabled(false);
        jPlotterUpdatePlotButton.setEnabled(false);
        if (selectedPathsVector.size()==0)
            return;
        
        // Make sure we have a curve before enabling update
        if (selectedPathsVector.size()==1){
            TreeNode lastNode=(TreeNode)selectedPathsVector.get(0).getLastPathComponent();
            if (lastNode instanceof PlotCurveNode){
                // Populate dialog
                PlotCurve cv = (PlotCurve)((PlotCurveNode)lastNode).getUserObject();
                updatePanelFromCurve(cv);
                jPlotterUpdatePlotButton.setEnabled(true);
                jPlotterDeletePlotButton.setEnabled(true);
            }
        } else {   // Enable delete if only curves are selected as we can't delete full plots now'
            boolean allCurves=true;
            for(int i=0; i<selectedPathsVector.size() && allCurves; i++){
                TreeNode lastNode=(TreeNode)selectedPathsVector.get(i).getLastPathComponent();
                allCurves =(lastNode instanceof PlotCurveNode);
            }
            jPlotterDeletePlotButton.setEnabled(allCurves);
        }
    }
    
    private void getCurrentTreeSelection(TreeSelectionEvent e) {
        TreePath[] selectedPaths = e.getPaths();
        for(int i=0;i<selectedPaths.length;i++){
            if (e.isAddedPath(i)){
                selectedPathsVector.add(selectedPaths[i]);
            } else {   //Removed
                selectedPathsVector.remove(selectedPaths[i]);
            }
        }
        //System.out.println("Current selection size ="+selectedPathsVector.size());
    }
    
    void setMinX(double minX) {
        jDomainStartTextField.setValue(minX);
    }
    
    double getMinX() {
        return ((Double)jDomainStartTextField.getValue()).doubleValue();
    }
    
    void setMaxX(double maxX) {
        jDomainEndTextField.setValue(maxX);
    }
    
    double getMaxX() {
        return ((Double)jDomainEndTextField.getValue()).doubleValue();
    }
    
    boolean getRectify() {
        return jRectifyCheckBox.isSelected();
    }
    /**
     * updatePanelFromCurve is invoked when selection on the tree changes.
     * need to make sure that the following are set
     * PlotterSourceInterface  sourceX, sourceY;
     * String      domainName;
     * String[]    rangeNames;
     */
    private void updatePanelFromCurve(PlotCurve cv) {
        // Populate Curve name, filters
        currentCurve=cv;
        jPlotNameTextField.setText(plotterModel.getPlotForCurve(cv).getTitle());
        sourceX=cv.getDomainSource();
        sourceY.clear();
        sourceY.add(cv.getRangeSource());
        setDomainName(cv.getDomainName());
        rangeNames[0] = cv.getRangeName();
        jSelectedMusclesTextField.setText(cv.getRangeName());
        // set title based on figure title
        jCurveLegendTextField.setText(cv.getLegend());
        setMinX(cv.getSettings().getXMin());
        setMaxX(cv.getSettings().getXMax());
        // Form domain label
        ArrayStr arx = cv.getDomainStorage().getColumnLabels();
        String sourceString=cv.getDomainSource().getDisplayName();
        String colName =arx.getitem(cv.getDomainStorageIndex()+1);
        jXQtyTextField.setText(domainName);
        // Form range label
        ArrayStr ary = cv.getRangeStorage().getColumnLabels();
        sourceString=cv.getRangeSource().getDisplayName();
        colName =ary.getitem(cv.getRangeStorageIndex()+1);
        if (cv.getSettings().isMusclePlot()){
            jYQtyTextField.setText(plotterModel.getQuantityDisplayName(cv.getQuantityName()));
        }
        else {
        jYQtyTextField.setText(sourceString+":"+colName);
        }
        // Now the filters
        jRectifyCheckBox.setSelected(false);
        Vector<PlotDataFilter> filters = cv.getSettings().getFilters();
        for(int i=0; i<filters.size(); i++){
            if (filters.get(i) instanceof PlotRectifyFilter)
                jRectifyCheckBox.setSelected(true);
            
        }
    }
    
    public void showTimeCurves(String title, String plot, Storage residualsStore, String[] names) {
        PlotCurve plotCurve=null;
/*      try {
         // Create a source from the Storage
 
         for(int i=0; i<names.length; i++) {
         plotCurve = plotterModel.addCurve(title, getSettings(),
                 residualsStore, "time",
                 residualsStore, names[i]);
         // Find node and make it selected
         PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(plotCurve);
         TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
         TreePath path = new TreePath(nodes);
         jPlotsTree.setSelectionPath(path);
         }
 
      } catch (PlotterException ex) {
         // Popup a dialog explaining what went wrong
         JOptionPane.showMessageDialog(this, ex.getMessage());
      }*/
    }
    
    /**
     * Popups have a single purpose, to populate the Text fields with valid values, but users can
     * type those in manually. The following parse functions try to recover the source storage, columns
     * from the Text fields for quantities. On successful parsing (names and sources local variables are set).
     * The syntax for File sources is File:<xxxx>:<yyyyy>
     **/
    private boolean parseDomainOrRangeText(JTextField jQtyTextField, boolean isDomain) {
        
        String text = jQtyTextField.getText();
        // Check for Empty
        if (text.length()==0)
            return false;
        
        // Check for qualifiers
        // We need to be forgiving in case the user types in the quantity manually
        String trimmed = text.trim();
        // Split around ":
       /*String[] subStrings = trimmed.split(":", 2);
       if (subStrings.length!=2)
           return false;
       String qualifier = subStrings[0];*/
        String columnNameList = trimmed;
        // If file doesn't exist or doesn't have column complain, otherwise
        // set Storage and Column
        String[] columns=columnNameList.trim().split(",",-1);
        if (isDomain){
            if (columns.length!=1){
                JOptionPane.showMessageDialog(this, "Can't have more than one column for domain");
                return false;
            } else{
                setDomainName(columns[0].trim());
                return true; // Should check coordinate exists
            }
        } else {   // range
            for(int i=0; i<columns.length; i++){
                columns[i]=columns[i].trim();
               /*if (source==PlotDataSource.FileSource){
                   PlotterSourceFile source = plotterModel.getSource(qualifier, columns[i]);
                   if (source==null){
                       JOptionPane.showMessageDialog(this, "Column "+columns[i]+" does not exist in file "+qualifier);
                       return false;
                   }
               }*/
            }
            rangeNames = new String[columns.length];
            System.arraycopy(columns, 0, rangeNames, 0, columns.length);
            // set sourceY here after all error detection is done.
            return true;
        }
        
    }
    /**
     * Get a string representing the list of column names
     */
    private String getRangeNamesAsString() {
        String rep="select Y";
        if (isMuscleSpecificAnalysis())
            rep="select muscle";
        if (rangeNames!=null){
            if (isMuscleSpecificAnalysis()){
                rep=jYQtyTextField.getText()+":";
            }
            else
                rep=sourceY.get(0).getDisplayName()+":";
        for(int i=0; i<rangeNames.length; i++){
            rep = rep + rangeNames[i];
            if (i<rangeNames.length-1)
                rep = rep + ",";
        }
        }
        return rep;
    }
    
    public PlotCurve showAnalysisCurveAgainstTime(Model aModel, Storage s,
            String title,
            String curveLegend, String columnName,
            String xLabel, String yLabel) throws PlotterException{
        /*
        sourceX = new PlotterSourceAnalysis(aModel, s, columnName);
        sourceY = sourceX;
        setDomainName("time");
        rangeNames = new String[]{columnName};
        jPlotNameTextField.setText(curveLegend);
        PlotCurveSettings settings  = getSettings();
        PlotCurve plotCurve=null;
        //settings.setXMin(s.getFirstTime());
        //settings.setXMax(s.getLastTime());
        plotCurve = plotterModel.addCurve(title, settings,
                sourceX, getDomainName(),                 sourceY, rangeNames[0]);
        makeCurveCurrent(plotCurve);
         **/
        return null;//;
    }
    
    String getQuantityFilterRegex() {
        return quantityFilterRegex;
    }
    
    public void setQuantityFilterRegex(String quantityFilterRegex) {
        this.quantityFilterRegex = quantityFilterRegex;
    }
    /**
     * This will be triggered when motion time changes.
     * Then we need to update X-crosshairs to match time
     */
    public void update(Observable o, Object arg) {
        if (o instanceof MotionsDB && arg instanceof MotionTimeChangeEvent){
            int x=0;
            MotionTimeChangeEvent motionTimeEvent = (MotionTimeChangeEvent)arg;
            double time=motionTimeEvent.getTime();
            // Should cast arg to proper event and set X-crosshairs
            if (getDomainName().compareTo("time")==0){
                plotterModel.getCurrentPlot().setDomainCrosshair(time);
            }
        }
    }
    /**
     * Run an analysis to compute curves for muscle analyses operating on current model
     * domainName is assumed to be set. If starts with Motion: then we assume we're plotting
     * against a motion curve otherwise it's vs. Generalized coordinate of the current model
     * 
     */
    void runAnalysisTool(PlotterSourceAnalysis source, PlotterSourceInterface motion) {
        AnalyzeTool tool = plotterModel.getAnalyzeTool(currentModel);
        PlotterSourceAnalysis analysisSource = (PlotterSourceAnalysis)source;
        plotterModel.enableDesiredAnalyses(tool, analysisSource, domainName);
        if (motion != null && motion instanceof PlotterSourceMotion){
            tool.setStartTime( motion.getStorage().getFirstTime());
            tool.setFinalTime( motion.getStorage().getLastTime());
            tool.setStatesStorage(motion.getStorage());
        }
        else {
            double NUM_STEPS=100.0;
            int numStates = currentModel.getNumStates();
            double[] states = new double[numStates];
            // Default start from current values of states
            currentModel.getStates(states);
            int xIndex = statesStorage.getStateIndex(getDomainName());
            AbstractCoordinate coord = currentModel.getDynamicsEngine().getCoordinateSet().get(getDomainName());

            double domStart=(Double)jDomainStartTextField.getValue();
            double domEnd=(Double)jDomainEndTextField.getValue();
            if (coord.getMotionType() == AbstractDof.DofType.Rotational){
                domStart=Math.toRadians(domStart);
                domEnd=Math.toRadians(domEnd);
            }
            // Make 100 steps along the way, varying the quantity on sourceX by 1/100 of the distance between domStart & domEnd
            statesStorage.reset();
            for(int i=0; i<NUM_STEPS; i++){
                double time = (double)i;
                double increment = 1./NUM_STEPS*(domEnd-domStart);
                states[xIndex]=domStart+increment*i;
                StateVector newVector = new StateVector();
                newVector.setStates(time, numStates, states);
                statesStorage.append(newVector);
            }
            tool.setStatesStorage(statesStorage);
            tool.setStartTime(0.);
            tool.setFinalTime(NUM_STEPS);
            sourceX=new PlotterSourceAnalysis(currentModel, statesStorage, "");
        }
        statesStorage.print("toolInput.sto");
        analysisSource.getStorage().reset();
        tool.run();
        analysisSource.getStorage().print("toolOutput.sto");
        currentModel.getDynamicsEngine().convertRadiansToDegrees(analysisSource.getStorage());
        currentModel.getDynamicsEngine().convertRadiansToDegrees(statesStorage);
    }
    
    private Storage createStateStorageWithHeader(final Model mdl) {
        // set tool attributes
        Storage statesStorage = new Storage();
        // Column labels for StateStorage
        ArrayStr stateNames = new ArrayStr();
        mdl.getStateNames(stateNames);
        stateNames.insert(0, "time");
        statesStorage.setColumnLabels(stateNames);
        return statesStorage;
    }
    
    private void resetXY() {
        jXQtyTextField.setText("");
        jYQtyTextField.setText("");
        jDomainStartTextField.setText("");
        jDomainEndTextField.setText("");
    }
    
    private void processCurrentModel() {
        if (currentModel!=null){
            initAnalyses();
            statesStorage=createStateStorageWithHeader(currentModel);
        }
        populateYPopup();
    }
    /**
     * Populate the top level pop up for Y-qty to use.
     */
    private void populateYPopup() {
        jSourcePopupMenu.removeAll();
        // Add analyses
        // Add Motions
        // Add files
        if (currentModel!=null){
            // Built in
            ////////////////////////////////////////////////////////////////////////
            // Analyses
            ////////////////////////////////////////////////////////////////////////
            AnalysisSet analyses = currentModel.getAnalysisSet();
            assert(analyses!=null);
            boolean addedSomething=false;
            /// Builtin 
            for (int i=0; i< plotterModel.getBuiltinQuantities().length; i++){
                final String qName = plotterModel.getBuiltinQuantities()[i];
                   JMenuItem quantityMenuItem = new JMenuItem(qName);
                   if (qName.startsWith("moment"))
                       quantityMenuItem.setEnabled(false);
                    jSourcePopupMenu.add(quantityMenuItem);
                    quantityMenuItem.addActionListener(
                            new ActionListener(){
                        public void actionPerformed(ActionEvent e) {
                            // Show multipleSelect dialog with all muscles
                            // Populate YQty text field with selection
                            //XX1
                            jYQtyTextField.setText(qName);
                            useMuscles(true);
                            updateContextGuiElements();
                            sourceY.clear();
                            sourceY.add(new PlotterSourceAnalysis(currentModel, plotterModel.getStorage(qName, currentModel), qName));
                        }
                    });
            }
                        
            for(int i=0;i<analyses.getSize();i++){
                final Analysis nextAnalysis = analyses.get(i);
                // Bultin analyses accouned for in the above block
                if ((nextAnalysis.getName().compareToIgnoreCase("MuscleAnalysis")==0)||
                    (nextAnalysis.getName().compareToIgnoreCase("MomentArmAnalysis")==0)){
                    continue;
                }
                JMenu nextAnalysisSubmenu = new JMenu(nextAnalysis.getName());
                // Get storages and create a menu item for each
                if (nextAnalysis.getName().contains("MomentArm")){
                    //cascade menu for Generalized coordinates to measure moment arm about
                    SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
                    String[] coordNames = guiElem.getCoordinateNames();
                    for(int j=0; j<coordNames.length; j++){
                        final String coordinateName=coordNames[j];
                        JMenuItem coordinateMenuItem = new JMenuItem(coordinateName);
                        coordinateMenuItem.addActionListener(new ActionListener(){
                            public void actionPerformed(ActionEvent e) {
                                //XX4
                                useMuscles(true);
                                jYQtyTextField.setText(nextAnalysis.getName()+":"+coordinateName);
                                updateContextGuiElements();
                             }
                        });
                        nextAnalysisSubmenu.add(coordinateMenuItem);
                    }                    
                    jSourcePopupMenu.add(nextAnalysisSubmenu);
                   continue;
                }
                ArrayStorage storages = nextAnalysis.getStorageList();
                for(int storageIndex=0; storageIndex<storages.getSize(); storageIndex++){
                    final Storage resultStorage = storages.get(storageIndex);
                    JMenuItem quantityMenuItem = new JMenuItem(resultStorage.getName());
                    nextAnalysisSubmenu.add(quantityMenuItem);
                    quantityMenuItem.addActionListener(
                            new ActionListener(){
                        public void actionPerformed(ActionEvent e) {
                            // Show multipleSelect dialog with all muscles
                            // Populate YQty text field with selection
                            //XX1
                            jYQtyTextField.setText(nextAnalysis.getName()+":"+resultStorage.getName());
                            useMuscles(true);
                            updateContextGuiElements();
                            sourceY.clear();
                            sourceY.add(new PlotterSourceAnalysis(currentModel, resultStorage, nextAnalysis.getName()+":"+resultStorage.getName()));
                            }
                    });
                }
                jSourcePopupMenu.add(nextAnalysisSubmenu);
                addedSomething=true;
            }  // Current model's analyses'
            jSourcePopupMenu.addSeparator();
            // Now motions
            ////////////////////////////////////////////////////////////////////////
            // Motions
            ////////////////////////////////////////////////////////////////////////
            addedSomething=false;
            ArrayList<Storage> motions = MotionsDB.getInstance().getModelMotions(currentModel);
            if (motions!=null){
                for(int i=0; i<motions.size(); i++){
                    Storage nextMotion = motions.get(i);
                    getPlotterModel().addMotion(nextMotion);
                }
            }
            ArrayList<PlotterSourceMotion> motionSources=plotterModel.getLoadedMotionSources();
            if (motions!=null && motions.size()>0){
                for(int i=0; i<motions.size(); i++){
                    final PlotterSourceMotion nextMotion = motionSources.get(i);
                    JMenuItem motionMenuItem = new JMenuItem(nextMotion.getDisplayName()+"...");
                    motionMenuItem.addActionListener(new ActionListener(){
                        public void actionPerformed(ActionEvent e) {
                            sourceY.clear();
                            sourceY.add(nextMotion);
                            sourceX = sourceY.get(0);
                            PlotterQuantityNameFilterJPanel filterpanel = new PlotterQuantityNameFilterJPanel(sourceY.get(0));
                            DialogDescriptor dlg = new DialogDescriptor(filterpanel,"Select Motion Column");
                            dlg.setModal(true);
                            DialogDisplayer.getDefault().createDialog(dlg).setVisible(true);
                            if (((Integer)dlg.getValue()).compareTo((Integer)DialogDescriptor.OK_OPTION)==0){
                                jYQtyTextField.setText(sourceY.get(0).getDisplayName()+":"+filterpanel.getSelectedAsString());
                                jXQtyTextField.setText(""); // Clear X on switching Y for motions and files
                                rangeNames = new String[filterpanel.getNumSelected()];
                                System.arraycopy(filterpanel.getSelected(), 0, rangeNames, 0, filterpanel.getNumSelected());
                                useMuscles(false);
                                updateContextGuiElements();
                                
                                //parseDomainOrRangeText(jYQtyTextField, false);
                                //updatePlotterWithSelection();
                            }
                        }});
                        jSourcePopupMenu.add(motionMenuItem);
                        addedSomething=true;
                }
            }
            if (addedSomething)
                jSourcePopupMenu.addSeparator();
        }
        ////////////////////////////////////////////////////////////////////////
        // Free Files
        ////////////////////////////////////////////////////////////////////////
        // Now add free files
        ArrayList<PlotterSourceFile> fileSources=plotterModel.getLoadedFileSources();
        if (fileSources!=null && fileSources.size()>0){
            for(int i=0; i<fileSources.size(); i++){
                final PlotterSourceFile nextSource = fileSources.get(i);
                JMenuItem fileMenuItem = new JMenuItem(nextSource.getDisplayName()+"...");
                fileMenuItem.addActionListener(new ActionListener(){
                    public void actionPerformed(ActionEvent e) {
                        sourceY.setSize(1);
                        sourceY.set(0, nextSource);
                        sourceX = nextSource;
                        PlotterQuantityNameFilterJPanel filterpanel = new PlotterQuantityNameFilterJPanel(sourceX);
                        DialogDescriptor dlg = new DialogDescriptor(filterpanel,"Select file column");
                        dlg.setModal(true);
                        DialogDisplayer.getDefault().createDialog(dlg).setVisible(true);
                        if (((Integer)dlg.getValue()).compareTo((Integer)DialogDescriptor.OK_OPTION)==0){
                            jYQtyTextField.setText(sourceX.getDisplayName()+":"+filterpanel.getSelectedAsString());
                            jXQtyTextField.setText(""); // Clear X on switching Y for motions and files
                            rangeNames = new String[filterpanel.getNumSelected()];
                            System.arraycopy(filterpanel.getSelected(), 0, rangeNames, 0, filterpanel.getNumSelected());
                            useMuscles(false);
                            updateContextGuiElements();
                            //parseDomainOrRangeText(jYQtyTextField, false);
                            //updatePlotterWithSelection();
                        }
                    }});
                    jSourcePopupMenu.add(fileMenuItem);
            }
        }
        JMenuItem newfileMenuItem = new JMenuItem("New file...");
        newfileMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent e) {
                // browse for file
                String dataFilename = FileUtils.getInstance().browseForFilename(".sto, .mot", "Files containing data to plot", true);
                if (dataFilename != null){
                    PlotterSourceFile src= getPlotterModel().addFile(dataFilename);
                    xQuantityButton.setEnabled(getPlotterModel().countSources()>0);
                    populateYPopup();
                }
            }});
            jSourcePopupMenu.add(newfileMenuItem);
    }
    
    private void useMuscles(boolean onOff)
    {
        boolean oldState=isMuscleSpecificAnalysis();
        setMuscleSpecificAnalysis(onOff);
        jMuscleSelectButton.setEnabled(onOff);
        if (onOff!=oldState)
            jSelectedMusclesTextField.setText("");
}

    public String getDomainName() {
        if (domainName==null){
                return "select X";
        }
        return domainName;
    }

    public void setDomainName(String domainName) {
        this.domainName = domainName;
    }

    public boolean isMuscleSpecificAnalysis() {
        return muscleSpecificAnalysis;
    }

    public void setMuscleSpecificAnalysis(boolean muscleSpecificAnalysis) {
        this.muscleSpecificAnalysis = muscleSpecificAnalysis;
    }
    private void validateXY()
    {
       
    }
}
