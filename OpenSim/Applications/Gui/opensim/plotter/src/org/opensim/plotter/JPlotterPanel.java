/*
 * JPlotterPanel.java
 *
 * Created on April 9, 2007, 1:39 PM
 */

package org.opensim.plotter;

import java.awt.BorderLayout;
import java.util.ArrayList;
import java.util.Observable;
import java.util.Vector;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import org.openide.DialogDescriptor;
import org.openide.DialogDisplayer;
import org.opensim.modeling.AbstractCoordinate;
import org.opensim.modeling.AnalyzeTool;
import org.opensim.modeling.ArrayStr;
import org.opensim.modeling.Model;
import org.opensim.modeling.StateVector;
import org.opensim.modeling.Storage;
import org.opensim.motionviewer.MotionTimeChangeEvent;
import org.opensim.utils.FileUtils;
import org.opensim.motionviewer.MotionsDB;
import org.opensim.view.pub.OpenSimDB;
/**
 *
 * @author  Ayman
 */
public class JPlotterPanel extends javax.swing.JPanel
         implements java.awt.event.ActionListener, java.awt.event.MouseListener, javax.swing.event.TreeSelectionListener, java.awt.event.FocusListener, java.util.Observer, java.beans.PropertyChangeListener {
   
   private PlotterModel plotterModel = new PlotterModel();
   public enum PlotDataSource {FileSource, AnalysisSource};
   JPlotterQuantitySelectorPopupList xPopup = null;
   JPlotterQuantitySelectorPopupList yPopup = null;
   private PlotDataSource source=PlotDataSource.FileSource;
   String currentCurveTitle="";
   private boolean autoGeneratedCurveTitle=true;
   private boolean autoMinX=true;
   private boolean autoMaxX=true;
   private boolean autoGeneratedPlotTitle=true;
   boolean  validXY=false;
   Vector<TreePath> selectedPathsVector = new Vector<TreePath>(4);   // Cache used to accumulate user selection of the tree
   PlotCurve currentCurve=null;     //used for update
   PlotterSourceInterface  sourceX, sourceY;
   String      domainName;
   String[]    rangeNames;
   
   private String quantityFilterRegex=".*";
   /**
    * Creates new form JPlotterPanel
    */
   public JPlotterPanel() {
      initComponents();
      jDomainStartTextField.setValue(0.0);
      jDomainEndTextField.setValue(1.0);
      jTopChartingPanel.setLayout(new BorderLayout());
      xPopup = new JPlotterQuantitySelectorPopupList(jXQtyTextField, this, true);
      yPopup = new JPlotterQuantitySelectorPopupList(jYQtyTextField, this, false);
      jPlotsTree.addTreeSelectionListener(this);

      jPlotterDeletePlotButton.setEnabled(false);
      jPlotterUpdatePlotButton.setEnabled(false);
      updatePlotterWithSelection();
      // Add in blank figure by default
      jTopChartingPanel.add(plotterModel.getCurrentPlot().getChartPanel());
      MotionsDB.getInstance().addObserver(this);
   }
   
   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      sourceButtonGroup = new javax.swing.ButtonGroup();
      jPlotterMenuBar = new javax.swing.JMenuBar();
      jPlotterFileMenu = new javax.swing.JMenu();
      jLoadFileToPlotterMenuItem = new javax.swing.JMenuItem();
      jSplitPane1 = new javax.swing.JSplitPane();
      jTopChartingPanel = new javax.swing.JPanel();
      jPlotControlPanel = new javax.swing.JPanel();
      jPlotNavigationPanel = new javax.swing.JPanel();
      jScrollPane1 = new javax.swing.JScrollPane();
      jPlotsTree = new javax.swing.JTree();
      jPanel1 = new javax.swing.JPanel();
      jPlotterAddPlotButton = new javax.swing.JButton();
      jPlotterUpdatePlotButton = new javax.swing.JButton();
      jPlotterDeletePlotButton = new javax.swing.JButton();
      jPlotSpecPanel = new javax.swing.JPanel();
      jAnalysisSourceRadioButton = new javax.swing.JRadioButton();
      jFileSourceRadioButton = new javax.swing.JRadioButton();
      jLabel2 = new javax.swing.JLabel();
      jCurveNameTextField = new javax.swing.JTextField();
      jPanel9 = new javax.swing.JPanel();
      xQuantityButton = new javax.swing.JButton();
      jXQtyTextField = new javax.swing.JTextField();
      jLabel9 = new javax.swing.JLabel();
      jLabel10 = new javax.swing.JLabel();
      jDomainStartTextField = new javax.swing.JFormattedTextField();
      jDomainEndTextField = new javax.swing.JFormattedTextField();
      jPanel10 = new javax.swing.JPanel();
      jLabel4 = new javax.swing.JLabel();
      jOffsetTextField = new javax.swing.JTextField();
      jRectifyCheckBox = new javax.swing.JCheckBox();
      jLabel3 = new javax.swing.JLabel();
      jScaleTextField = new javax.swing.JTextField();
      yQuantityButton = new javax.swing.JButton();
      jYQtyTextField = new javax.swing.JTextField();
      jBrowse4FileButton = new javax.swing.JButton();
      jAvailableAnalysesComboBox = new javax.swing.JComboBox();
      jPlotTitlePanel = new javax.swing.JPanel();
      jPlotLabelJLabel = new javax.swing.JLabel();
      jPlotNameTextField = new javax.swing.JTextField();

      jPlotterFileMenu.setText("File");
      jPlotterFileMenu.setToolTipText("load into or save data from plotter.");
      jLoadFileToPlotterMenuItem.setText("Load File...");
      jLoadFileToPlotterMenuItem.setToolTipText("File with data to plot");
      jLoadFileToPlotterMenuItem.addActionListener(this);

      jPlotterFileMenu.add(jLoadFileToPlotterMenuItem);

      jPlotterMenuBar.add(jPlotterFileMenu);

      jSplitPane1.setDividerLocation(280);
      jSplitPane1.setDividerSize(7);
      jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
      jSplitPane1.setResizeWeight(1.0);
      jSplitPane1.setAutoscrolls(true);
      jSplitPane1.setDoubleBuffered(true);
      jSplitPane1.setOneTouchExpandable(true);
      org.jdesktop.layout.GroupLayout jTopChartingPanelLayout = new org.jdesktop.layout.GroupLayout(jTopChartingPanel);
      jTopChartingPanel.setLayout(jTopChartingPanelLayout);
      jTopChartingPanelLayout.setHorizontalGroup(
         jTopChartingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 594, Short.MAX_VALUE)
      );
      jTopChartingPanelLayout.setVerticalGroup(
         jTopChartingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 269, Short.MAX_VALUE)
      );
      jSplitPane1.setLeftComponent(jTopChartingPanel);

      jPlotControlPanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
      jPlotNavigationPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Plots list"));
      jScrollPane1.setAutoscrolls(true);
      jPlotsTree.setModel(plotterModel.getPlotTreeModel());
      jScrollPane1.setViewportView(jPlotsTree);

      jPlotterAddPlotButton.setText("Add");
      jPlotterAddPlotButton.addActionListener(this);

      jPlotterUpdatePlotButton.setText("Update");
      jPlotterUpdatePlotButton.addActionListener(this);

      jPlotterDeletePlotButton.setText("Delete");
      jPlotterDeletePlotButton.addActionListener(this);

      org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
      jPanel1.setLayout(jPanel1Layout);
      jPanel1Layout.setHorizontalGroup(
         jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel1Layout.createSequentialGroup()
            .add(jPlotterAddPlotButton)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotterUpdatePlotButton)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotterDeletePlotButton)
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );
      jPanel1Layout.setVerticalGroup(
         jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jPlotterAddPlotButton)
               .add(jPlotterUpdatePlotButton)
               .add(jPlotterDeletePlotButton))
            .add(6, 6, 6))
      );

      org.jdesktop.layout.GroupLayout jPlotNavigationPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotNavigationPanel);
      jPlotNavigationPanel.setLayout(jPlotNavigationPanelLayout);
      jPlotNavigationPanelLayout.setHorizontalGroup(
         jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotNavigationPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 193, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addContainerGap())
      );
      jPlotNavigationPanelLayout.setVerticalGroup(
         jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPlotNavigationPanelLayout.createSequentialGroup()
            .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 194, Short.MAX_VALUE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
      );

      jPlotSpecPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Curve add/update"));
      jPlotSpecPanel.setToolTipText("Legend:");
      sourceButtonGroup.add(jAnalysisSourceRadioButton);
      jAnalysisSourceRadioButton.setText("Analysis");
      jAnalysisSourceRadioButton.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jAnalysisSourceRadioButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jAnalysisSourceRadioButton.addActionListener(this);

      sourceButtonGroup.add(jFileSourceRadioButton);
      jFileSourceRadioButton.setSelected(true);
      jFileSourceRadioButton.setText("File");
      jFileSourceRadioButton.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jFileSourceRadioButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jFileSourceRadioButton.addActionListener(this);

      jLabel2.setText("Curve Legend");

      jCurveNameTextField.setText("Curve legend goes here");
      jCurveNameTextField.addActionListener(this);

      xQuantityButton.setText("X-Quantity >");
      xQuantityButton.setEnabled(false);
      xQuantityButton.addMouseListener(this);

      jXQtyTextField.addActionListener(this);
      jXQtyTextField.addFocusListener(this);

      jLabel9.setText("Start");

      jLabel10.setText("End");

      jDomainStartTextField.addPropertyChangeListener(this);

      jDomainEndTextField.addPropertyChangeListener(this);

      org.jdesktop.layout.GroupLayout jPanel9Layout = new org.jdesktop.layout.GroupLayout(jPanel9);
      jPanel9.setLayout(jPanel9Layout);
      jPanel9Layout.setHorizontalGroup(
         jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel9Layout.createSequentialGroup()
            .add(jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
               .add(jPanel9Layout.createSequentialGroup()
                  .add(jLabel9)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED))
               .add(jPanel9Layout.createSequentialGroup()
                  .add(xQuantityButton)
                  .add(18, 18, 18)))
            .add(jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jPanel9Layout.createSequentialGroup()
                  .add(jDomainStartTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 75, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jLabel10)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jDomainEndTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 98, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
               .add(jXQtyTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 199, Short.MAX_VALUE))
            .addContainerGap())
      );
      jPanel9Layout.setVerticalGroup(
         jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel9Layout.createSequentialGroup()
            .add(jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(xQuantityButton)
               .add(jXQtyTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPanel9Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jLabel9)
               .add(jDomainStartTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jLabel10)
               .add(jDomainEndTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
      );

      jLabel4.setText("Offset");

      jRectifyCheckBox.setText("Rectify");
      jRectifyCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jRectifyCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));

      jLabel3.setText("Scale");

      yQuantityButton.setText("Y-Quantity >");
      yQuantityButton.setEnabled(false);
      yQuantityButton.addMouseListener(this);

      jYQtyTextField.addActionListener(this);
      jYQtyTextField.addFocusListener(this);

      org.jdesktop.layout.GroupLayout jPanel10Layout = new org.jdesktop.layout.GroupLayout(jPanel10);
      jPanel10.setLayout(jPanel10Layout);
      jPanel10Layout.setHorizontalGroup(
         jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel10Layout.createSequentialGroup()
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jPanel10Layout.createSequentialGroup()
                  .addContainerGap()
                  .add(jLabel3)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jScaleTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 77, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .add(13, 13, 13)
                  .add(jLabel4)
                  .add(4, 4, 4)
                  .add(jOffsetTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 69, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jRectifyCheckBox))
               .add(jPanel10Layout.createSequentialGroup()
                  .add(yQuantityButton)
                  .add(19, 19, 19)
                  .add(jYQtyTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 198, Short.MAX_VALUE)
                  .add(8, 8, 8)))
            .addContainerGap())
      );
      jPanel10Layout.setVerticalGroup(
         jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel10Layout.createSequentialGroup()
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(yQuantityButton)
               .add(jYQtyTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPanel10Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jLabel3)
               .add(jScaleTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jLabel4)
               .add(jOffsetTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jRectifyCheckBox))
            .add(29, 29, 29))
      );

      jBrowse4FileButton.setText("Browse...");
      jBrowse4FileButton.addActionListener(this);

      jAvailableAnalysesComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
      jAvailableAnalysesComboBox.addActionListener(this);

      org.jdesktop.layout.GroupLayout jPlotSpecPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotSpecPanel);
      jPlotSpecPanel.setLayout(jPlotSpecPanelLayout);
      jPlotSpecPanelLayout.setHorizontalGroup(
         jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotSpecPanelLayout.createSequentialGroup()
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jPlotSpecPanelLayout.createSequentialGroup()
                  .addContainerGap()
                  .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jAnalysisSourceRadioButton)
                     .add(jLabel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 69, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                     .add(jPlotSpecPanelLayout.createSequentialGroup()
                        .add(jAvailableAnalysesComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 87, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(jFileSourceRadioButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 33, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(jBrowse4FileButton))
                     .add(jCurveNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 228, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
               .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                  .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel9, 0, 320, Short.MAX_VALUE)
                  .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel10, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
            .addContainerGap())
      );
      jPlotSpecPanelLayout.setVerticalGroup(
         jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotSpecPanelLayout.createSequentialGroup()
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jLabel2)
               .add(jCurveNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(7, 7, 7)
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jAnalysisSourceRadioButton)
               .add(jAvailableAnalysesComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jFileSourceRadioButton)
               .add(jBrowse4FileButton))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel9, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel10, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 52, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addContainerGap())
      );

      jPlotTitlePanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Headers"));
      jPlotLabelJLabel.setText("Plot Title");

      jPlotNameTextField.setText("Plot title goes here");
      jPlotNameTextField.setToolTipText("Plot Title");
      jPlotNameTextField.addActionListener(this);

      org.jdesktop.layout.GroupLayout jPlotTitlePanelLayout = new org.jdesktop.layout.GroupLayout(jPlotTitlePanel);
      jPlotTitlePanel.setLayout(jPlotTitlePanelLayout);
      jPlotTitlePanelLayout.setHorizontalGroup(
         jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotTitlePanelLayout.createSequentialGroup()
            .add(jPlotLabelJLabel)
            .add(22, 22, 22)
            .add(jPlotNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 247, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addContainerGap(20, Short.MAX_VALUE))
      );
      jPlotTitlePanelLayout.setVerticalGroup(
         jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotTitlePanelLayout.createSequentialGroup()
            .add(jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jPlotLabelJLabel)
               .add(jPlotNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addContainerGap())
      );

      org.jdesktop.layout.GroupLayout jPlotControlPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotControlPanel);
      jPlotControlPanel.setLayout(jPlotControlPanelLayout);
      jPlotControlPanelLayout.setHorizontalGroup(
         jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotControlPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jPlotTitlePanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(jPlotSpecPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotNavigationPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 225, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(3, 3, 3))
      );
      jPlotControlPanelLayout.setVerticalGroup(
         jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotControlPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPlotNavigationPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPlotControlPanelLayout.createSequentialGroup()
                  .add(jPlotTitlePanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jPlotSpecPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
            .add(11, 11, 11))
      );
      jSplitPane1.setRightComponent(jPlotControlPanel);

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 596, Short.MAX_VALUE)
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 574, Short.MAX_VALUE)
      );
   }

   // Code for dispatching events from components to event handlers.

   public void actionPerformed(java.awt.event.ActionEvent evt) {
      if (evt.getSource() == jLoadFileToPlotterMenuItem) {
         JPlotterPanel.this.jLoadFileToPlotterMenuItemActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterAddPlotButton) {
         JPlotterPanel.this.jPlotterAddCurveButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterUpdatePlotButton) {
         JPlotterPanel.this.jPlotterUpdatePlotButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterDeletePlotButton) {
         JPlotterPanel.this.jPlotterDeletePlotButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jAnalysisSourceRadioButton) {
         JPlotterPanel.this.jAnalysisSourceRadioButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jFileSourceRadioButton) {
         JPlotterPanel.this.jFileSourceRadioButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jCurveNameTextField) {
         JPlotterPanel.this.jCurveNameTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jYQtyTextField) {
         JPlotterPanel.this.jYQtyTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jBrowse4FileButton) {
         JPlotterPanel.this.jBrowse4FileButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jAvailableAnalysesComboBox) {
         JPlotterPanel.this.jAvailableAnalysesComboBoxActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotNameTextField) {
         JPlotterPanel.this.jPlotNameTextFieldActionPerformed(evt);
      }
   }

   public void focusGained(java.awt.event.FocusEvent evt) {
   }

   public void focusLost(java.awt.event.FocusEvent evt) {
      if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldFocusLost(evt);
      }
      else if (evt.getSource() == jYQtyTextField) {
         JPlotterPanel.this.jYQtyTextFieldFocusLost(evt);
      }
   }

   public void mouseClicked(java.awt.event.MouseEvent evt) {
   }

   public void mouseEntered(java.awt.event.MouseEvent evt) {
   }

   public void mouseExited(java.awt.event.MouseEvent evt) {
   }

   public void mousePressed(java.awt.event.MouseEvent evt) {
      if (evt.getSource() == yQuantityButton) {
         JPlotterPanel.this.yQuantityButtonMousePressed(evt);
      }
   }

   public void mouseReleased(java.awt.event.MouseEvent evt) {
      if (evt.getSource() == xQuantityButton) {
         JPlotterPanel.this.xQuantityButtonMouseReleased(evt);
      }
      else if (evt.getSource() == yQuantityButton) {
         JPlotterPanel.this.yQuantityButtonMouseReleased(evt);
      }
   }

   public void propertyChange(java.beans.PropertyChangeEvent evt) {
      if (evt.getSource() == jDomainStartTextField) {
         JPlotterPanel.this.jDomainStartTextFieldPropertyChange(evt);
      }
      else if (evt.getSource() == jDomainEndTextField) {
         JPlotterPanel.this.jDomainEndTextFieldPropertyChange(evt);
      }
   }// </editor-fold>//GEN-END:initComponents

    private void jAvailableAnalysesComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jAvailableAnalysesComboBoxActionPerformed
// TODO add your handling code here:
        sourceX = (PlotterSourceInterface) ((JComboBox)evt.getSource()).getSelectedItem();
        sourceY=sourceX;
        
    }//GEN-LAST:event_jAvailableAnalysesComboBoxActionPerformed

    private void jDomainEndTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jDomainEndTextFieldPropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jDomainEndTextFieldPropertyChange

    private void jDomainStartTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jDomainStartTextFieldPropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jDomainStartTextFieldPropertyChange
    // AnalysisPick
    private void jAnalysisSourceRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jAnalysisSourceRadioButtonActionPerformed
// TODO add your handling code here:
         source=PlotDataSource.AnalysisSource;
         plotterModel.addModel(OpenSimDB.getInstance().getCurrentModel());
         xQuantityButton.setEnabled(true);
         ArrayList<PlotterSourceAnalysis> srcs=plotterModel.getAnalysisSources();
         // Add available quantities to jAvailableAnalysesComboBox
         PlotterSourceAnalysis[] availableAnalyses= new PlotterSourceAnalysis[srcs.size()];
         for(int i=0; i<srcs.size();i++)
             availableAnalyses[i] = srcs.get(i);
         jAvailableAnalysesComboBox.setModel(new DefaultComboBoxModel(availableAnalyses));
         // Assume first one is selected
         sourceX = availableAnalyses[0];
         sourceY = sourceX;
         System.gc();
    }//GEN-LAST:event_jAnalysisSourceRadioButtonActionPerformed

    private void jFileSourceRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jFileSourceRadioButtonActionPerformed
// TODO add your handling code here:
         source=PlotDataSource.FileSource;
    }//GEN-LAST:event_jFileSourceRadioButtonActionPerformed

   private void jXQtyTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jXQtyTextFieldFocusLost
      updatePlotterWithSelection();

   }//GEN-LAST:event_jXQtyTextFieldFocusLost

   private void jXQtyTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jXQtyTextFieldActionPerformed
      updatePlotterWithSelection();

   }//GEN-LAST:event_jXQtyTextFieldActionPerformed

   private void jYQtyTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jYQtyTextFieldFocusLost
      updatePlotterWithSelection();

   }//GEN-LAST:event_jYQtyTextFieldFocusLost

   private void jYQtyTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jYQtyTextFieldActionPerformed
      updatePlotterWithSelection();

   }//GEN-LAST:event_jYQtyTextFieldActionPerformed

   private void jBrowse4FileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBrowse4FileButtonActionPerformed
      // Browse for Storage or Motion file (for now) and preprocess the file if needed for plotting
      String dataFilename = FileUtils.getInstance().browseForFilename(".sto, .mot", "Files containing data to plot", true);
      if (dataFilename != null){
         getPlotterModel().addFile(dataFilename);
         xQuantityButton.setEnabled(getPlotterModel().countSources()>0);
      }
   }//GEN-LAST:event_jBrowse4FileButtonActionPerformed

   private void jPlotterDeletePlotButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterDeletePlotButtonActionPerformed

      // Make a cache so that object deletion does not mess up the selections array
      // we're working on.
      Object[] cache = new Object[selectedPathsVector.size()];
      selectedPathsVector.copyInto(cache);
      for(int i=0;i<cache.length; i++){
         TreePath nextPath = (TreePath)cache[i]; // Since the array shrinks!
         Object[] pathObjects = nextPath.getPath();
         int depth =pathObjects.length-1;
         DefaultMutableTreeNode node = (DefaultMutableTreeNode)pathObjects[depth];
         if (node instanceof PlotNode){
            Plot figToDelete = ((Plot)node.getUserObject());
            System.out.println("Delete figure named "+figToDelete.getTitle());
            plotterModel.deletePlot(figToDelete);
         } else if (node instanceof PlotCurveNode){
            PlotCurve cvToDelete = ((PlotCurve)node.getUserObject());
            plotterModel.deleteCurve(cvToDelete);
            System.out.println("Delete Curve named "+cvToDelete.getLegend());
         } else
            JOptionPane.showMessageDialog(this, "Don't know what to delete!");
         
      }
   }//GEN-LAST:event_jPlotterDeletePlotButtonActionPerformed

   private void jPlotterUpdatePlotButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterUpdatePlotButtonActionPerformed

      // Single Curve is selected, populate the dialog from the Curve and keep a pointer to it for update
      // get Settings and update the curve. The trick is to do it without delete, insert so that colors are kept
      String title =jPlotNameTextField.getText();
      try {
         if (rangeNames.length!=1){ // delete current curve and perform add
             jPlotterDeletePlotButtonActionPerformed(evt);
             jPlotterAddCurveButtonActionPerformed(evt);
             return;
         }
         plotterModel.updateCurve(currentCurve, title, getSettings(), 
                 sourceX, domainName, 
                 sourceY, rangeNames[0]);
         // Find node and make it selected        
         PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(currentCurve);
         TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
         TreePath path = new TreePath(nodes); 
         jPlotsTree.setSelectionPath(path);
      } catch (PlotterException ex) {
         ex.printStackTrace();
      }
      
   }//GEN-LAST:event_jPlotterUpdatePlotButtonActionPerformed

   private void jPlotNameTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotNameTextFieldActionPerformed

      autoGeneratedPlotTitle=false;
   }//GEN-LAST:event_jPlotNameTextFieldActionPerformed

   private void jCurveNameTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCurveNameTextFieldActionPerformed

      autoGeneratedCurveTitle=false;   // user modified the text field don't intervene!'
   }//GEN-LAST:event_jCurveNameTextFieldActionPerformed
   // XCallback
   private void xQuantityButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_xQuantityButtonMouseReleased
       if(evt.isPopupTrigger()) {
         xPopup.updateList(plotterModel, source==PlotDataSource.FileSource);
         xPopup.show(evt.getComponent(), evt.getX(), evt.getY());
         updatePlotterWithSelection();
       }

   }//GEN-LAST:event_xQuantityButtonMouseReleased

   private void yQuantityButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_yQuantityButtonMouseReleased
       if(evt.isPopupTrigger()) {
         //yPopup.updateList(plotterModel, sourceButtonGroup.getSelection()==jFileSourceRadioButton.getModel());
         //yPopup.show(evt.getComponent(), evt.getX(), evt.getY());
         sourceY=sourceX;
         PlotterQuantityNameFilterJPanel filterpanel = new PlotterQuantityNameFilterJPanel(sourceX);
         DialogDescriptor dlg = new DialogDescriptor(filterpanel,"Select Quantity");
         dlg.setModal(true);
         DialogDisplayer.getDefault().createDialog(dlg).setVisible(true);
         if (((Integer)dlg.getValue()).compareTo((Integer)DialogDescriptor.OK_OPTION)==0){
            jYQtyTextField.setText(sourceY.getDisplayName()+":"+filterpanel.getSelectedAsString());
            parseDomainOrRangeText(jYQtyTextField, false);
            updatePlotterWithSelection();
         }
       }

   }//GEN-LAST:event_yQuantityButtonMouseReleased

   private void yQuantityButtonMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_yQuantityButtonMousePressed

     yQuantityButtonMouseReleased(evt);
   }//GEN-LAST:event_yQuantityButtonMousePressed
   
   private void jPlotterAddCurveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterAddCurveButtonActionPerformed

      // Analysis curves need to have an analysis run before they can be displayed. 
      // Ask PlotterModel to run.
      if (source==PlotDataSource.AnalysisSource){
         // Create a storage with Proper values for states to be passed in to the AnalysisTool         
         runAnalysisTool(sourceX, domainName, sourceY, 
                 (Double)jDomainStartTextField.getValue(), (Double)jDomainEndTextField.getValue());
      }
      String title = jPlotNameTextField.getText();
      PlotCurve plotCurve=null;
      try {
         // get Storages from sources
         for(int curveIndex=0; curveIndex<rangeNames.length; curveIndex++){
            PlotCurveSettings settings  = getSettings();
            if (rangeNames.length>1){
               if (autoGeneratedCurveTitle)
                  settings.setName(rangeNames[curveIndex]+ " vs. "+domainName);
               else
                  settings.setName(settings.getName()+" "+String.valueOf(curveIndex));
            }
            plotCurve = plotterModel.addCurve(title, settings, 
                                    sourceX, domainName, 
                                    sourceY, rangeNames[curveIndex]);
         }
            makeCurveCurrent(plotCurve);
         
      } catch (PlotterException ex) {
         // Popup a dialog explaining what went wrong
         JOptionPane.showMessageDialog(this, ex.getMessage());
      }
      this.doLayout();
      repaint();
   }//GEN-LAST:event_jPlotterAddCurveButtonActionPerformed

    private void makeCurveCurrent(final PlotCurve plotCurve) {
        // Find node and make it selected        
        PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(plotCurve);
        TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
        TreePath path = new TreePath(nodes); 
        jPlotsTree.setSelectionPath(path);
    }
   
   private void jLoadFileToPlotterMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jLoadFileToPlotterMenuItemActionPerformed

      // Browse for Storage or Motion file (for now) and preprocess the file if needed for plotting
      String dataFilename = FileUtils.getInstance().browseForFilename(".sto, .mot", "Files containing data to plot", true);
      if (dataFilename != null){
         PlotterSourceFile src = new PlotterSourceFile(dataFilename);
         getPlotterModel().addSource(src);
      }
   }//GEN-LAST:event_jLoadFileToPlotterMenuItemActionPerformed
   

   public PlotterModel getPlotterModel() {
      return plotterModel;
   }

   private PlotCurveSettings getSettings() {
      return new PlotCurveSettings(this);
   }
   
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JRadioButton jAnalysisSourceRadioButton;
   private javax.swing.JComboBox jAvailableAnalysesComboBox;
   private javax.swing.JButton jBrowse4FileButton;
   private javax.swing.JTextField jCurveNameTextField;
   private javax.swing.JFormattedTextField jDomainEndTextField;
   private javax.swing.JFormattedTextField jDomainStartTextField;
   private javax.swing.JRadioButton jFileSourceRadioButton;
   private javax.swing.JLabel jLabel10;
   private javax.swing.JLabel jLabel2;
   private javax.swing.JLabel jLabel3;
   private javax.swing.JLabel jLabel4;
   private javax.swing.JLabel jLabel9;
   private javax.swing.JMenuItem jLoadFileToPlotterMenuItem;
   private javax.swing.JTextField jOffsetTextField;
   private javax.swing.JPanel jPanel1;
   private javax.swing.JPanel jPanel10;
   private javax.swing.JPanel jPanel9;
   private javax.swing.JPanel jPlotControlPanel;
   private javax.swing.JLabel jPlotLabelJLabel;
   private javax.swing.JTextField jPlotNameTextField;
   private javax.swing.JPanel jPlotNavigationPanel;
   private javax.swing.JPanel jPlotSpecPanel;
   private javax.swing.JPanel jPlotTitlePanel;
   private javax.swing.JTree jPlotsTree;
   private javax.swing.JButton jPlotterAddPlotButton;
   private javax.swing.JButton jPlotterDeletePlotButton;
   private javax.swing.JMenu jPlotterFileMenu;
   private javax.swing.JMenuBar jPlotterMenuBar;
   private javax.swing.JButton jPlotterUpdatePlotButton;
   private javax.swing.JCheckBox jRectifyCheckBox;
   private javax.swing.JTextField jScaleTextField;
   private javax.swing.JScrollPane jScrollPane1;
   private javax.swing.JSplitPane jSplitPane1;
   private javax.swing.JPanel jTopChartingPanel;
   private javax.swing.JTextField jXQtyTextField;
   private javax.swing.JTextField jYQtyTextField;
   private javax.swing.ButtonGroup sourceButtonGroup;
   private javax.swing.JButton xQuantityButton;
   private javax.swing.JButton yQuantityButton;
   // End of variables declaration//GEN-END:variables
   
   public String getPlotName()
   {
      return jPlotNameTextField.getText();
   }

   public PlotDataSource getSource() {
      return source;
   }

   public void setSource(PlotDataSource source) {
      this.source = source;
   }

   private void updatePlotTitle() {
      
   }

   private void updateCurveTitle() {
      if (isAutoGeneratedCurveTitle()){
         currentCurveTitle=getRangeNamesAsString()+" vs. "+domainName;
         jCurveNameTextField.setText(currentCurveTitle);
      }
   }

   public boolean isAutoGeneratedCurveTitle() {
      return autoGeneratedCurveTitle;
   }

   public void setAutoGeneratedCurveTitle(boolean autoGeneratedCurveTitle) {
      this.autoGeneratedCurveTitle = autoGeneratedCurveTitle;
   }

   public boolean isAutoGeneratedPlotTitle() {
      return autoGeneratedPlotTitle;
   }

   public void setAutoGeneratedPlotTitle(boolean autoGeneratedPlotTitle) {
      this.autoGeneratedPlotTitle = autoGeneratedPlotTitle;
   }

   public String getCurveName() {
      return jCurveNameTextField.getText();
   }
   /**
    * This method is to be invoked after X or Y selection either when the selection 
    *  dialog is brought down or after user typing in data in the X,Y textfields 
    * (and probably a few other situations)
    * to update 
    *    - default curve name if not modified by user
    *    - X-bounds
    * Very important piece here is parseDomainOrRangeText see comments there.
    */
   public void updatePlotterWithSelection()
   {
      // For now anything in x,y text fields is taken as valid, instead we should do more 
      // validation that quantities indicated do exist.
      boolean validX = parseDomainOrRangeText(jXQtyTextField, true);
      if (validX){
          Storage s = sourceX.getStorage();
          if (autoMinX && autoMaxX){
              if (domainName.compareTo("time")==0){
                  setMinX(sourceX.getStorage().getFirstTime());
                  setMaxX(sourceX.getStorage().getLastTime());
              } else {
                  setMinX(0.0);
                  setMaxX(1.0);
              }
          }
      }
      yQuantityButton.setEnabled(validX);
      boolean validY = parseDomainOrRangeText(jYQtyTextField, false);
      validXY = validX && validY;
      if (!validXY){
         // Disable Add
         jPlotterAddPlotButton.setEnabled(false);
         return;
      }
      jPlotterAddPlotButton.setEnabled(true);
      updatePlotTitle();
      updateCurveTitle();
      
   }
   /**
    * TreeSelectionListener implementation
    */
   public void valueChanged(TreeSelectionEvent e) {
      getCurrentTreeSelection(e);
      
      jPlotterDeletePlotButton.setEnabled(false);
      jPlotterUpdatePlotButton.setEnabled(false);
      if (selectedPathsVector.size()==0)
         return;

      // Make sure we have a curve before enabling update
      if (selectedPathsVector.size()==1){
         TreeNode lastNode=(TreeNode)selectedPathsVector.get(0).getLastPathComponent();
         if (lastNode instanceof PlotCurveNode){
            // Populate dialog
            PlotCurve cv = (PlotCurve)((PlotCurveNode)lastNode).getUserObject();
            updatePanelFromCurve(cv);
            jPlotterUpdatePlotButton.setEnabled(true);
            jPlotterDeletePlotButton.setEnabled(true);
         }
      }
      else {   // Enable delete if only curves are selected as we can't delete full plots now'
         boolean allCurves=true;
         for(int i=0; i<selectedPathsVector.size() && allCurves; i++){
            TreeNode lastNode=(TreeNode)selectedPathsVector.get(i).getLastPathComponent();
            allCurves =(lastNode instanceof PlotCurveNode);
         }
         jPlotterDeletePlotButton.setEnabled(allCurves);
      }
   }

   private void getCurrentTreeSelection(TreeSelectionEvent e) {
      TreePath[] selectedPaths = e.getPaths();
      for(int i=0;i<selectedPaths.length;i++){
         if (e.isAddedPath(i)){
            selectedPathsVector.add(selectedPaths[i]);
         }
         else {   //Removed
            selectedPathsVector.remove(selectedPaths[i]);         
         }
      }
      //System.out.println("Current selection size ="+selectedPathsVector.size());
   }
   
   void setMinX(double minX)
   {
      jDomainStartTextField.setValue(minX);
   }
   
   double getMinX()
   {
      return ((Double)jDomainStartTextField.getValue()).doubleValue();
   }
   
   void setMaxX(double maxX)
   {
      jDomainEndTextField.setValue(maxX);
   }
   
   double getMaxX()
   {
      return ((Double)jDomainEndTextField.getValue()).doubleValue();
   }

   double getScaleFactor() {
      String text=jScaleTextField.getText();
      if (text.compareTo("")==0) return 1.0;
      return Double.parseDouble(text);
   }

   double getOffset() {
      String text=jOffsetTextField.getText();
      if (text.compareTo("")==0) return 0.0;
      return Double.parseDouble(text);
   }

   boolean getRectify() {
      return jRectifyCheckBox.isSelected();
   }
   /**
    * updatePanelFromCurve is invoked when selection on the tree changes.
    * need to make sure that the following are set
    * PlotterSourceInterface  sourceX, sourceY;
    * String      domainName;
    * String[]    rangeNames;
    */
   private void updatePanelFromCurve(PlotCurve cv) {
      // Populate Curve name, filters
      currentCurve=cv;
      jPlotNameTextField.setText(plotterModel.getPlotForCurve(cv).getTitle());
      sourceX=cv.getDomainSource();
      sourceY=cv.getRangeSource();
      domainName = cv.getDomainName();
      rangeNames[0] = cv.getRangeName();
      // set title based on figure title
      jCurveNameTextField.setText(cv.getLegend());
      setMinX(cv.getSettings().getXMin());
      setMaxX(cv.getSettings().getXMax());
      // Form domain label
      ArrayStr arx = cv.getDomainStorage().getColumnLabels();
      String sourceString=cv.getDomainSource().getDisplayName();
      String colName =arx.getitem(cv.getDomainStorageIndex()+1);
      jXQtyTextField.setText(sourceString+":"+colName);
      // Form range label
      ArrayStr ary = cv.getRangeStorage().getColumnLabels();
      sourceString=cv.getRangeSource().getDisplayName();
      colName =ary.getitem(cv.getRangeStorageIndex()+1);
      jYQtyTextField.setText(sourceString+":"+colName);
      // Now the filters
      jRectifyCheckBox.setSelected(false);
      jOffsetTextField.setText("");
      jScaleTextField.setText("");
      Vector<PlotDataFilter> filters = cv.getSettings().getFilters();
      for(int i=0; i<filters.size(); i++){
         if (filters.get(i) instanceof PlotOffsetFilter)
            jOffsetTextField.setText(String.valueOf(((PlotOffsetFilter)filters.get(i)).value));
         if (filters.get(i) instanceof PlotScaleFilter)
            jScaleTextField.setText(String.valueOf(((PlotScaleFilter)filters.get(i)).value));
         if (filters.get(i) instanceof PlotRectifyFilter)
            jRectifyCheckBox.setSelected(true);
         
      }
   }
   
   public void showTimeCurves(String title, String plot, Storage residualsStore, String[] names) {
      PlotCurve plotCurve=null;
/*      try {
         // Create a source from the Storage
         
         for(int i=0; i<names.length; i++) {
         plotCurve = plotterModel.addCurve(title, getSettings(), 
                 residualsStore, "time", 
                 residualsStore, names[i]);
         // Find node and make it selected        
         PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(plotCurve);
         TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
         TreePath path = new TreePath(nodes); 
         jPlotsTree.setSelectionPath(path);
         }
         
      } catch (PlotterException ex) {
         // Popup a dialog explaining what went wrong
         JOptionPane.showMessageDialog(this, ex.getMessage());
      }*/
     }

   /**
    * Popups have a single purpose, to populate the Text fields with valid values, but users can 
    * type those in manually. The following parse functions try to recover the source storage, columns
    * from the Text fields for quantities. On successful parsing (names and sources local variables are set).
    * The syntax for File sources is File:<xxxx>:<yyyyy>
    **/
   private boolean parseDomainOrRangeText(JTextField jQtyTextField, boolean isDomain) {
       
       String text = jQtyTextField.getText();
       // Check for Empty
       if (text.length()==0)
           return false;
       // Check for qualifiers
       // We need to be forgiving in case the user types in the quantity manually
       String trimmed = text.trim();
       // Split around ":
       String[] subStrings = trimmed.split(":", 2);
       if (subStrings.length!=2)
           return false;
       String qualifier = subStrings[0];
       String columnNameList = subStrings[1];
       // If file doesn't exist or doesn't have column complain, otherwise
       // set Storage and Column
       String[] columns=columnNameList.trim().split(",",-1);
       if (isDomain){
           if (columns.length!=1){
               JOptionPane.showMessageDialog(this, "Can't have more than one column for domain");
               return false;
           } else{
               if (source==PlotDataSource.FileSource){
                   PlotterSourceInterface source = plotterModel.getSource(qualifier, columns[0]);
                   if (source!=null){
                       sourceX = source;
                       domainName = columns[0].trim();
                   }
                   return (source!=null);
               }
               else {   // Analysis
                   domainName = columns[0].trim();
                   return true; // Should check coordinate exists
               }
           }
       } else {   // range
           for(int i=0; i<columns.length; i++){
               columns[i]=columns[i].trim();
               if (source==PlotDataSource.FileSource){
                   PlotterSourceFile source = plotterModel.getSource(qualifier, columns[i]);
                   if (source==null){
                       JOptionPane.showMessageDialog(this, "Column "+columns[i]+" does not exist in file "+qualifier);
                       return false;
                   }
               }
           }
           rangeNames = new String[columns.length];
           System.arraycopy(columns, 0, rangeNames, 0, columns.length);
           // set sourceY here after all error detection is done.
           if (source==PlotDataSource.FileSource)
                sourceY = plotterModel.getSource(qualifier, columns[0]);
           return true;
       }
       
   }
   /**
    * Get a string representing the list of column names 
    */
   private String getRangeNamesAsString()
   {
      String rep="";
      for(int i=0; i<rangeNames.length; i++){
         rep = rep + rangeNames[i];
         if (i<rangeNames.length-1)
            rep = rep + ",";
      }
      return rep;
   }

    public PlotCurve showAnalysisCurveAgainstTime(Model aModel, Storage s, 
                                        String title,
                                        String curveLegend, String columnName, 
                                        String xLabel, String yLabel) throws PlotterException{
        sourceX = new PlotterSourceAnalysis(aModel, s, columnName);
        sourceY = sourceX;
        domainName = "time";
        rangeNames = new String[]{columnName};
        jPlotNameTextField.setText(curveLegend);
        PlotCurveSettings settings  = getSettings();
        PlotCurve plotCurve=null;
        //settings.setXMin(s.getFirstTime());
        //settings.setXMax(s.getLastTime());
        plotCurve = plotterModel.addCurve(title, settings, 
                                    sourceX, domainName, 
                                    sourceY, rangeNames[0]);
        makeCurveCurrent(plotCurve);
        return plotCurve;
    }

    String getQuantityFilterRegex() {
        return quantityFilterRegex;
    }

     public void setQuantityFilterRegex(String quantityFilterRegex) {
        this.quantityFilterRegex = quantityFilterRegex;
    }
    /**
     * This will be triggered when motion time changes. 
     * Then we need to update X-crosshairs to match time
     */
    public void update(Observable o, Object arg) {
        if (o instanceof MotionsDB && arg instanceof MotionTimeChangeEvent){
            int x=0;
            MotionTimeChangeEvent motionTimeEvent = (MotionTimeChangeEvent)arg;
            double time=motionTimeEvent.getTime();
            // Should cast arg to proper event and set X-crosshairs
            if (domainName.compareTo("time")==0){
                plotterModel.getCurrentPlot().setDomainCrosshair(time);
            }
        }
    }
   void runAnalysisTool(PlotterSourceInterface sourceX, String domainName, PlotterSourceInterface sourceY, double domStart, double domEnd) {
      PlotterSourceAnalysis analysisSource = (PlotterSourceAnalysis)sourceX;
      Model mdl = analysisSource.getModel();
      AnalyzeTool tool = plotterModel.getAnalyzeTool(mdl);
      double NUM_STEPS=100.0;
      // set tool attributes
      Storage statesStorage = new Storage();
      int numStates = mdl.getNumStates();
      double[] states = new double[numStates];
      // Default start from current values of states
      mdl.getStates(states);
      
      // Column labels for StateStorage
      ArrayStr stateNames = new ArrayStr();
      mdl.getStateNames(stateNames);
      stateNames.insert(0, "time");
      statesStorage.setColumnLabels(stateNames);
      int xIndex = statesStorage.getStateIndex(domainName);
      AbstractCoordinate coord = mdl.getDynamicsEngine().getCoordinateSet().get(domainName);
      double startOverride=coord.getRangeMin();
      double endOverride=coord.getRangeMax();
      // Make 100 steps along the way, varying the quantity on sourceX by 1/100 of the distance between domStart & domEnd
      for(int i=0; i<100; i++){
         double time = (double)i;
         double increment = 1./NUM_STEPS*(endOverride-startOverride);
         states[xIndex]=startOverride+increment*i;
         StateVector newVector = new StateVector();
         newVector.setStates(time, numStates, states);
         statesStorage.append(newVector);
      }
      tool.setStatesStorage(statesStorage);
      tool.setStartTime(0.0);
      tool.setFinalTime(100.0);
      tool.run();
      statesStorage.print("toolInput.sto");
      // Now need to append statesStorage
      statesStorage.addToRdStorage(analysisSource.getStorage(), 0.0, 100.);
      statesStorage.print("myStateStorage.sto");
   }
}
