/*
 * JPlotterPanel.java
 *
 * Created on April 9, 2007, 1:39 PM
 */

package org.opensim.plotter;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Observable;
import java.util.Vector;
import javax.swing.AbstractAction;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFormattedTextField;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.JTextField;
import javax.swing.KeyStroke;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import org.openide.DialogDescriptor;
import org.openide.DialogDisplayer;
import org.openide.NotifyDescriptor;
import org.opensim.modeling.AbstractCoordinate;
import org.opensim.modeling.AbstractDof;
import org.opensim.modeling.Analysis;
import org.opensim.modeling.AnalysisSet;
import org.opensim.modeling.AnalyzeTool;
import org.opensim.modeling.ArrayDouble;
import org.opensim.modeling.ArrayStorage;
import org.opensim.modeling.ArrayStr;
import org.opensim.modeling.CoordinateSet;
import org.opensim.modeling.Model;
import org.opensim.modeling.OpenSimObject;
import org.opensim.modeling.StateVector;
import org.opensim.modeling.Storage;
import org.opensim.motionviewer.MotionEvent;
import org.opensim.motionviewer.MotionTimeChangeEvent;
import org.opensim.utils.FileUtils;
import org.opensim.motionviewer.MotionsDB;
import org.opensim.view.ModelEvent;
import org.opensim.view.ObjectSetCurrentEvent;
import org.opensim.view.SingleModelGuiElements;
import org.opensim.view.pub.OpenSimDB;
import org.opensim.view.pub.ViewDB;
/**
 *
 * @author  Ayman
 */
public class JPlotterPanel extends javax.swing.JPanel
        implements java.awt.event.ActionListener, javax.swing.event.TreeSelectionListener, java.awt.event.FocusListener, java.util.Observer, java.beans.PropertyChangeListener, java.awt.event.InputMethodListener, java.awt.event.MouseListener {
   
   // PlotterModel kkeps track of two things
   // 1. For motions and free files, a PlotterSourceInterface is created and maintained so that
   //      files don't need to be re read/parsed'
   // 2. It serves as the model backing the tree of plots/figures.
   private PlotterModel plotterModel = new PlotterModel();
   public enum PlotDataSource {FileSource, MotionSource, AnalysisSource};
   JPlotterQuantitySelector xSelector = null;
   String currentCurveTitle="";
   private boolean autoGeneratedCurveTitle=true;
   Vector<TreePath> selectedPathsVector = new Vector<TreePath>(4);   // Cache used to accumulate user selection of the tree
   PlotCurve currentCurve=null;     //used for update
   // We keep track of the following (as a state for the dialog/panel:
   PlotterSourceInterface  sourceX; // either a motion column, storage column or a gencoord
   PlotterSourceInterface sourceY; // Range source
   private String      domainName;  // single domain name
   private String[]    rangeNames;  // many range names
   private boolean     builtinMuscleCurve=false;   // Whether muscle selection is required for specified Y qty
   boolean sumCurve=false;
   
   // Plotting from a motion or storage has obvious domain, sourceX values
   //       range names are for multiple curves or one sum curve. Single sourceY
   // MotionCurve: domainName: motion-time
   //              rangeNames: motion-columns
   //              sourceX: motion
   //              sourceY: motion.
   //              in case of sum, rangeNames[] are summed.
   // Plotting builtin muscle curves requires running an analysis that can produce one
   // or many storages->sources. 
   // If not plotting against a motion
   // The options should be as follows (FiberLength and MomentArm used as example):
   // FiberLength: domainName: Gencoord
   //              rangeNames: selectedMuscles
   //              sourceX: statesStorage (built on the fly or from a motion file)
   //              sourceY: single analysis result storage.(name=FiberLength).
   //              in case of sum, rangeNames[] are summed.
   //              ylabel=sourceY[0].getDisplayName();
   // MomentArm: domainName: GencoordToVary
   //              rangeNames: selectedMuscles
   //              sourceX: statesStorage (built on the fly or from a motion file)
   //              sourceY: single analysis result storage.(name=MomentArm_GencoordAbout).   
   //              in case of sum, rangeNames[] are summed.
   // 
   // 
   Model currentModel = OpenSimDB.getInstance().getCurrentModel();
   private Storage statesStorage;
   private boolean clamp=false;
   double  yMin, yMax;
   private boolean modelChanged=true;
   /**
    * Creates new form JPlotterPanel
    */
   public JPlotterPanel() {
      initComponents();
      jDomainStartTextField.setValue(0.0);
      jDomainEndTextField.setValue(1.0);
      jDomainStartTextField.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
      jDomainStartTextField.getActionMap().put("check", new handleReturnAction(jDomainStartTextField));
      jDomainEndTextField.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
      jDomainEndTextField.getActionMap().put("check", new handleReturnAction(jDomainEndTextField));
      jFormattedTextFieldYmin.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
      jFormattedTextFieldYmin.getActionMap().put("check", new handleReturnAction(jFormattedTextFieldYmin));
      jFormattedTextFieldYmax.getInputMap().put(KeyStroke.getKeyStroke(
                                KeyEvent.VK_ENTER, 0),
                                "check");
      jFormattedTextFieldYmax.getActionMap().put("check", new handleReturnAction(jFormattedTextFieldYmax));

      jTopChartingPanel.setLayout(new BorderLayout());
      xSelector = new JPlotterQuantitySelector(jXQtyTextField, this, true);
      //ySelector = new JPlotterQuantitySelector(jYQtyTextField, this, false);
      jPlotsTree.addTreeSelectionListener(this);
      
      jPlotterDeletePlotButton.setEnabled(false);
      //jPlotterUpdatePlotButton.setEnabled(false);
      jPlotterAddPlotButton.setEnabled(validateXY());
      // Add in blank figure by default
      jTopChartingPanel.add(plotterModel.getCurrentPlot().getChartPanel());
      //jPropertiesButton.setComponentPopupMenu(plotterModel.getCurrentPlot().getChartPanel().getPopupMenu());
      jPropertiesButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                plotterModel.getCurrentPlot().getChartPanel().doEditChartProperties();
            }
        });
      processCurrentModel();
      useMuscles(false);
      jPlotsTree.setRootVisible(false);
      //printPlotDescriptor();
   }
   
   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      jPlotterMenuBar = new javax.swing.JMenuBar();
      jPlotterFileMenu = new javax.swing.JMenu();
      jLoadFileToPlotterMenuItem = new javax.swing.JMenuItem();
      jSourcePopupMenu = new javax.swing.JPopupMenu();
      jXPopupMenu = new javax.swing.JPopupMenu();
      jMusclePopupMenu = new javax.swing.JPopupMenu();
      jAdvancedPanel = new javax.swing.JPanel();
      jClampCheckBox = new javax.swing.JCheckBox();
      jLabel1 = new javax.swing.JLabel();
      jLabel3 = new javax.swing.JLabel();
      jRectifyCheckBox = new javax.swing.JCheckBox();
      jLabel9 = new javax.swing.JLabel();
      jDomainStartTextField = new javax.swing.JFormattedTextField();
      jLabel10 = new javax.swing.JLabel();
      jDomainEndTextField = new javax.swing.JFormattedTextField();
      jFormattedTextFieldYmin = new javax.swing.JFormattedTextField();
      jFormattedTextFieldYmax = new javax.swing.JFormattedTextField();
      jPlotTitlePanel = new javax.swing.JPanel();
      jPlotLabelJLabel = new javax.swing.JLabel();
      jPlotNameTextField = new javax.swing.JTextField();
      jPlotPropertiesPopupMenu = new javax.swing.JPopupMenu();
      jSplitPane1 = new javax.swing.JSplitPane();
      jTopChartingPanel = new javax.swing.JPanel();
      jPlotControlPanel = new javax.swing.JPanel();
      jPlotNavigationPanel = new javax.swing.JPanel();
      jScrollPane1 = new javax.swing.JScrollPane();
      jPlotsTree = new javax.swing.JTree();
      jPanel1 = new javax.swing.JPanel();
      jPlotterAddPlotButton = new javax.swing.JButton();
      jPlotterDeletePlotButton = new javax.swing.JButton();
      jPropertiesButton = new javax.swing.JButton();
      jPlotSpecPanel = new javax.swing.JPanel();
      jLabel2 = new javax.swing.JLabel();
      jCurveLegendTextField = new javax.swing.JTextField();
      yQuantityButton = new javax.swing.JButton();
      jMuscleSelectButton = new javax.swing.JButton();
      xQuantityButton = new javax.swing.JButton();
      jAdvancedOptionsButton = new javax.swing.JButton();
      jYQtyTextField = new javax.swing.JTextField();
      jSelectedMusclesTextField = new javax.swing.JTextField();
      jXQtyTextField = new javax.swing.JTextField();
      jSummaryAdvancedTextField = new javax.swing.JTextField();

      jPlotterFileMenu.setText("File");
      jPlotterFileMenu.setToolTipText("load into or save data from plotter.");
      jLoadFileToPlotterMenuItem.setText("Load File...");
      jLoadFileToPlotterMenuItem.setToolTipText("File with data to plot");
      jLoadFileToPlotterMenuItem.addActionListener(this);

      jPlotterFileMenu.add(jLoadFileToPlotterMenuItem);

      jPlotterMenuBar.add(jPlotterFileMenu);

      jClampCheckBox.setText("Clamp");
      jClampCheckBox.setToolTipText("Clamp Y value to limits between from, to");
      jClampCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jClampCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jClampCheckBox.addActionListener(this);

      jLabel1.setText("ymin");

      jLabel3.setText("ymax");

      jRectifyCheckBox.setText("Rectify");
      jRectifyCheckBox.setToolTipText("Plot absolute Y value");
      jRectifyCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
      jRectifyCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
      jRectifyCheckBox.addActionListener(this);

      jLabel9.setText("xmin");

      jDomainStartTextField.setToolTipText("domain start");
      jDomainStartTextField.addActionListener(this);
      jDomainStartTextField.addPropertyChangeListener(this);

      jLabel10.setText("xmax");

      jDomainEndTextField.setToolTipText("domain end");
      jDomainEndTextField.addPropertyChangeListener(this);

      jFormattedTextFieldYmin.setEditable(false);
      jFormattedTextFieldYmin.setToolTipText("clamp from value");
      jFormattedTextFieldYmin.addActionListener(this);

      jFormattedTextFieldYmax.setEditable(false);
      jFormattedTextFieldYmax.setToolTipText("clamp to value");
      jFormattedTextFieldYmax.setEnabled(false);

      org.jdesktop.layout.GroupLayout jAdvancedPanelLayout = new org.jdesktop.layout.GroupLayout(jAdvancedPanel);
      jAdvancedPanel.setLayout(jAdvancedPanelLayout);
      jAdvancedPanelLayout.setHorizontalGroup(
         jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jAdvancedPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jRectifyCheckBox)
               .add(jAdvancedPanelLayout.createSequentialGroup()
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jClampCheckBox)
                     .add(jAdvancedPanelLayout.createSequentialGroup()
                        .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                           .add(org.jdesktop.layout.GroupLayout.LEADING, jAdvancedPanelLayout.createSequentialGroup()
                              .add(jLabel9)
                              .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                              .add(jDomainStartTextField))
                           .add(org.jdesktop.layout.GroupLayout.LEADING, jAdvancedPanelLayout.createSequentialGroup()
                              .add(jLabel1)
                              .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                              .add(jFormattedTextFieldYmin, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 82, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                  .add(10, 10, 10)
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jLabel10)
                     .add(jLabel3))
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(jDomainEndTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 70, Short.MAX_VALUE)
                     .add(jFormattedTextFieldYmax, 0, 0, Short.MAX_VALUE))
                  .addContainerGap())))
      );
      jAdvancedPanelLayout.setVerticalGroup(
         jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jAdvancedPanelLayout.createSequentialGroup()
            .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jAdvancedPanelLayout.createSequentialGroup()
                  .addContainerGap()
                  .add(jRectifyCheckBox)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(jClampCheckBox)
                  .add(8, 8, 8)
                  .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(jFormattedTextFieldYmin, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                     .add(jLabel3)
                     .add(jLabel1)))
               .add(jAdvancedPanelLayout.createSequentialGroup()
                  .add(55, 55, 55)
                  .add(jFormattedTextFieldYmax, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jAdvancedPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jLabel9)
               .add(jDomainStartTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jDomainEndTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jLabel10))
            .addContainerGap())
      );
      jPlotTitlePanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Headers"));
      jPlotLabelJLabel.setText("Plot Title");

      jPlotNameTextField.setToolTipText("Plot Title");

      org.jdesktop.layout.GroupLayout jPlotTitlePanelLayout = new org.jdesktop.layout.GroupLayout(jPlotTitlePanel);
      jPlotTitlePanel.setLayout(jPlotTitlePanelLayout);
      jPlotTitlePanelLayout.setHorizontalGroup(
         jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotTitlePanelLayout.createSequentialGroup()
            .add(jPlotLabelJLabel)
            .add(22, 22, 22)
            .add(jPlotNameTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 259, Short.MAX_VALUE)
            .addContainerGap())
      );
      jPlotTitlePanelLayout.setVerticalGroup(
         jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotTitlePanelLayout.createSequentialGroup()
            .add(jPlotTitlePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jPlotLabelJLabel)
               .add(jPlotNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addContainerGap())
      );

      jSplitPane1.setDividerLocation(300);
      jSplitPane1.setDividerSize(7);
      jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
      jSplitPane1.setResizeWeight(1.0);
      jSplitPane1.setAutoscrolls(true);
      jSplitPane1.setDoubleBuffered(true);
      jSplitPane1.setOneTouchExpandable(true);
      org.jdesktop.layout.GroupLayout jTopChartingPanelLayout = new org.jdesktop.layout.GroupLayout(jTopChartingPanel);
      jTopChartingPanel.setLayout(jTopChartingPanelLayout);
      jTopChartingPanelLayout.setHorizontalGroup(
         jTopChartingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 610, Short.MAX_VALUE)
      );
      jTopChartingPanelLayout.setVerticalGroup(
         jTopChartingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 299, Short.MAX_VALUE)
      );
      jSplitPane1.setLeftComponent(jTopChartingPanel);

      jPlotControlPanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
      jPlotNavigationPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Curves List"));
      jScrollPane1.setAutoscrolls(true);
      jPlotsTree.setModel(plotterModel.getPlotTreeModel());
      jPlotsTree.addMouseListener(this);

      jScrollPane1.setViewportView(jPlotsTree);

      jPlotterAddPlotButton.setText("Add");
      jPlotterAddPlotButton.addActionListener(this);

      jPlotterDeletePlotButton.setText("Delete");
      jPlotterDeletePlotButton.addActionListener(this);

      jPropertiesButton.setComponentPopupMenu(jPlotPropertiesPopupMenu);
      jPropertiesButton.setText("Properties...");

      org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
      jPanel1.setLayout(jPanel1Layout);
      jPanel1Layout.setHorizontalGroup(
         jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPanel1Layout.createSequentialGroup()
            .add(jPlotterAddPlotButton)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotterDeletePlotButton)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPropertiesButton)
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );
      jPanel1Layout.setVerticalGroup(
         jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jPlotterAddPlotButton)
               .add(jPlotterDeletePlotButton)
               .add(jPropertiesButton))
            .add(6, 6, 6))
      );

      org.jdesktop.layout.GroupLayout jPlotNavigationPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotNavigationPanel);
      jPlotNavigationPanel.setLayout(jPlotNavigationPanelLayout);
      jPlotNavigationPanelLayout.setHorizontalGroup(
         jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotNavigationPanelLayout.createSequentialGroup()
            .add(jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jScrollPane1)
               .add(org.jdesktop.layout.GroupLayout.LEADING, jPlotNavigationPanelLayout.createSequentialGroup()
                  .add(10, 10, 10)
                  .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );
      jPlotNavigationPanelLayout.setVerticalGroup(
         jPlotNavigationPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPlotNavigationPanelLayout.createSequentialGroup()
            .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 89, Short.MAX_VALUE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
      );

      jPlotSpecPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Curve Add/Update"));
      jPlotSpecPanel.setToolTipText("");
      jLabel2.setText("Curve Name");

      jCurveLegendTextField.setToolTipText("Name of curve, to show in legend, Curves List.");
      jCurveLegendTextField.addActionListener(this);

      yQuantityButton.setText("Y-Quantity...");
      yQuantityButton.addMouseListener(this);

      jMuscleSelectButton.setText("Muscles...");
      jMuscleSelectButton.addMouseListener(this);

      xQuantityButton.setText("X-Quantity...");
      xQuantityButton.addMouseListener(this);

      jAdvancedOptionsButton.setText("Advanced...");
      jAdvancedOptionsButton.addActionListener(this);

      jYQtyTextField.setEditable(false);
      jYQtyTextField.addActionListener(this);
      jYQtyTextField.addFocusListener(this);

      jSelectedMusclesTextField.setEditable(false);

      jXQtyTextField.setEditable(false);
      jXQtyTextField.addActionListener(this);
      jXQtyTextField.addPropertyChangeListener(this);
      jXQtyTextField.addFocusListener(this);
      jXQtyTextField.addInputMethodListener(this);

      jSummaryAdvancedTextField.setEditable(false);
      jSummaryAdvancedTextField.setToolTipText("summary of advanced options");

      org.jdesktop.layout.GroupLayout jPlotSpecPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotSpecPanel);
      jPlotSpecPanel.setLayout(jPlotSpecPanelLayout);
      jPlotSpecPanelLayout.setHorizontalGroup(
         jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotSpecPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
               .add(org.jdesktop.layout.GroupLayout.TRAILING, jPlotSpecPanelLayout.createSequentialGroup()
                  .add(jLabel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 107, Short.MAX_VALUE)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED))
               .add(jMuscleSelectButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(jAdvancedOptionsButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 97, Short.MAX_VALUE)
               .add(xQuantityButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(yQuantityButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(jCurveLegendTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 166, Short.MAX_VALUE)
               .add(org.jdesktop.layout.GroupLayout.TRAILING, jSummaryAdvancedTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 166, Short.MAX_VALUE)
               .add(jSelectedMusclesTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 166, Short.MAX_VALUE)
               .add(org.jdesktop.layout.GroupLayout.TRAILING, jXQtyTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 166, Short.MAX_VALUE)
               .add(org.jdesktop.layout.GroupLayout.TRAILING, jYQtyTextField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 166, Short.MAX_VALUE))
            .addContainerGap())
      );
      jPlotSpecPanelLayout.setVerticalGroup(
         jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jPlotSpecPanelLayout.createSequentialGroup()
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jCurveLegendTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jLabel2))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(yQuantityButton)
               .add(jYQtyTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jSelectedMusclesTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jMuscleSelectButton))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jXQtyTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(xQuantityButton))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotSpecPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(jSummaryAdvancedTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(jAdvancedOptionsButton)))
      );

      org.jdesktop.layout.GroupLayout jPlotControlPanelLayout = new org.jdesktop.layout.GroupLayout(jPlotControlPanel);
      jPlotControlPanel.setLayout(jPlotControlPanelLayout);
      jPlotControlPanelLayout.setHorizontalGroup(
         jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPlotControlPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotSpecPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(jPlotNavigationPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addContainerGap())
      );
      jPlotControlPanelLayout.setVerticalGroup(
         jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, jPlotControlPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(jPlotControlPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
               .add(jPlotNavigationPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
               .add(jPlotSpecPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addContainerGap())
      );
      jSplitPane1.setRightComponent(jPlotControlPanel);

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 612, Short.MAX_VALUE)
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(jSplitPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 512, Short.MAX_VALUE)
      );
   }

   // Code for dispatching events from components to event handlers.

   public void actionPerformed(java.awt.event.ActionEvent evt) {
      if (evt.getSource() == jLoadFileToPlotterMenuItem) {
         JPlotterPanel.this.jLoadFileToPlotterMenuItemActionPerformed(evt);
      }
      else if (evt.getSource() == jClampCheckBox) {
         JPlotterPanel.this.jClampCheckBoxActionPerformed(evt);
      }
      else if (evt.getSource() == jRectifyCheckBox) {
         JPlotterPanel.this.jRectifyCheckBoxActionPerformed(evt);
      }
      else if (evt.getSource() == jDomainStartTextField) {
         JPlotterPanel.this.jDomainStartTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jFormattedTextFieldYmin) {
         JPlotterPanel.this.jFormattedTextFieldYminActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterAddPlotButton) {
         JPlotterPanel.this.jPlotterAddCurveButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jPlotterDeletePlotButton) {
         JPlotterPanel.this.jPlotterDeletePlotButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jCurveLegendTextField) {
         JPlotterPanel.this.jCurveLegendTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jAdvancedOptionsButton) {
         JPlotterPanel.this.jAdvancedOptionsButtonActionPerformed(evt);
      }
      else if (evt.getSource() == jYQtyTextField) {
         JPlotterPanel.this.jYQtyTextFieldActionPerformed(evt);
      }
      else if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldActionPerformed(evt);
      }
   }

   public void focusGained(java.awt.event.FocusEvent evt) {
   }

   public void focusLost(java.awt.event.FocusEvent evt) {
      if (evt.getSource() == jYQtyTextField) {
         JPlotterPanel.this.jYQtyTextFieldFocusLost(evt);
      }
      else if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldFocusLost(evt);
      }
   }

   public void caretPositionChanged(java.awt.event.InputMethodEvent evt) {
      if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldCaretPositionChanged(evt);
      }
   }

   public void inputMethodTextChanged(java.awt.event.InputMethodEvent evt) {
   }

   public void mouseClicked(java.awt.event.MouseEvent evt) {
   }

   public void mouseEntered(java.awt.event.MouseEvent evt) {
   }

   public void mouseExited(java.awt.event.MouseEvent evt) {
   }

   public void mousePressed(java.awt.event.MouseEvent evt) {
      if (evt.getSource() == jPlotsTree) {
         JPlotterPanel.this.jPlotsTreeMousePressed(evt);
      }
      else if (evt.getSource() == yQuantityButton) {
         JPlotterPanel.this.yQuantityButtonMousePressed(evt);
      }
      else if (evt.getSource() == jMuscleSelectButton) {
         JPlotterPanel.this.jMuscleSelectButtonMousePressed(evt);
      }
      else if (evt.getSource() == xQuantityButton) {
         JPlotterPanel.this.xQuantityButtonMousePressed(evt);
      }
   }

   public void mouseReleased(java.awt.event.MouseEvent evt) {
      if (evt.getSource() == jPlotsTree) {
         JPlotterPanel.this.jPlotsTreeMouseReleased(evt);
      }
      else if (evt.getSource() == yQuantityButton) {
         JPlotterPanel.this.yQuantityButtonMouseReleased(evt);
      }
      else if (evt.getSource() == jMuscleSelectButton) {
         JPlotterPanel.this.jMuscleSelectButtonMouseReleased(evt);
      }
      else if (evt.getSource() == xQuantityButton) {
         JPlotterPanel.this.xQuantityButtonMouseReleased(evt);
      }
   }

   public void propertyChange(java.beans.PropertyChangeEvent evt) {
      if (evt.getSource() == jDomainStartTextField) {
         JPlotterPanel.this.jDomainStartTextFieldPropertyChange(evt);
      }
      else if (evt.getSource() == jDomainEndTextField) {
         JPlotterPanel.this.jDomainEndTextFieldPropertyChange(evt);
      }
      else if (evt.getSource() == jXQtyTextField) {
         JPlotterPanel.this.jXQtyTextFieldPropertyChange(evt);
      }
   }// </editor-fold>//GEN-END:initComponents

   private void jPlotsTreeMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPlotsTreeMouseReleased
// TODO add your handling code here:
     if (evt.isPopupTrigger())
       invokeTreePopupIfNeeded(evt.getX(), evt.getY());
   }//GEN-LAST:event_jPlotsTreeMouseReleased

   private void jPlotsTreeMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPlotsTreeMousePressed
      if (evt.isPopupTrigger())
       invokeTreePopupIfNeeded(evt.getX(), evt.getY());
// TODO add your handling code here:
   }//GEN-LAST:event_jPlotsTreeMousePressed

   private void jFormattedTextFieldYminActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jFormattedTextFieldYminActionPerformed
// TODO add your handling code here:
   }//GEN-LAST:event_jFormattedTextFieldYminActionPerformed

   private void jDomainStartTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jDomainStartTextFieldActionPerformed
// TODO add your handling code here:
   }//GEN-LAST:event_jDomainStartTextFieldActionPerformed

   private void jRectifyCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRectifyCheckBoxActionPerformed
// TODO add your handling code here:
   }//GEN-LAST:event_jRectifyCheckBoxActionPerformed
   
    private void jAdvancedOptionsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jAdvancedOptionsButtonActionPerformed
// TODO add your handling code here:
       DialogDescriptor dd = new DialogDescriptor(jAdvancedPanel, "AdvancedOptions");
       dd.setModal(true);
       DialogDisplayer.getDefault().createDialog(dd).setVisible(true);
       setClamp(jClampCheckBox.isSelected());
      updateSummary();
    }//GEN-LAST:event_jAdvancedOptionsButtonActionPerformed

   private void updateSummary() {
      String summary = "Rectify ="+jRectifyCheckBox.isSelected()+
                       ", x:["+
                       jDomainStartTextField.getValue()+","+
                       jDomainEndTextField.getValue()+"]";
      if (isClamp())
              summary=summary+" y:["+
                      jFormattedTextFieldYmin.getValue()+", "+
                      jFormattedTextFieldYmax.getValue()+"]";
      
      jSummaryAdvancedTextField.setText(summary);
   }
    
    private void jClampCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jClampCheckBoxActionPerformed
// TODO add your handling code here:
       JCheckBox clamped = (JCheckBox)evt.getSource();
       jFormattedTextFieldYmin.setEnabled(clamped.isSelected());
       jFormattedTextFieldYmin.setEditable(clamped.isSelected());
       jFormattedTextFieldYmax.setEditable(clamped.isSelected());
       jFormattedTextFieldYmax.setEnabled(clamped.isSelected());
    }//GEN-LAST:event_jClampCheckBoxActionPerformed
    
    private void jMuscleSelectButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jMuscleSelectButtonMouseReleased
// TODO add your handling code here:
       //jMuscleSelectButtonMousePressed(evt);
    }//GEN-LAST:event_jMuscleSelectButtonMouseReleased
    
    private void jMuscleSelectButtonMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jMuscleSelectButtonMousePressed
        String preSelected=jSelectedMusclesTextField.getText();
// TODO add your handling code here:
       // Show muscle selection, multiple
       //XX2
        if (currentModel==null || builtinMuscleCurve==false)
           return;
        SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
        String[] muscleNames = guiElem.getActuatorNames();
        final QuantityNameFilterJPanel filterPanel = new QuantityNameFilterJPanel(muscleNames, preSelected);
        DialogDescriptor filterDlg = new DialogDescriptor(filterPanel, "Select muscles", false, null);
        filterDlg.setOptions(new Object[]{new JButton("Close")});
        filterPanel.addSelectionChangeListener(new TableModelListener(){
            public void tableChanged(TableModelEvent e) {
                jSelectedMusclesTextField.setText(filterPanel.getSelectedAsString());
                sumCurve=filterPanel.isSumOnly();
                if (sumCurve)
                   rangeNames = filterPanel.getSelectedAsString().trim().split("\\+",-1);
                else
                   rangeNames = filterPanel.getSelectedAsString().trim().split(",",-1);
                for(int i=0;i<rangeNames.length;i++)
                   rangeNames[i]=rangeNames[i].trim();
                updateContextGuiElements();
                jPlotterAddPlotButton.setEnabled(validateXY());
            }});
/*            public void actionPerformed(ActionEvent e) {
            }
        };*/
        DialogDisplayer.getDefault().createDialog(filterDlg).setVisible(true);
       // The following will be called from an Apply/MakeCurves button on the filterDlg
      //printPlotDescriptor();
       
    }//GEN-LAST:event_jMuscleSelectButtonMousePressed
    
    private void xQuantityButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_xQuantityButtonMouseReleased
// TODO add your handling code here:
       //xQuantityButtonMousePressed(evt);
    }//GEN-LAST:event_xQuantityButtonMouseReleased
    
    private void xQuantityButtonMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_xQuantityButtonMousePressed
// TODO add your handling code here:
       //XX3
       if (isBuiltinMuscleCurve()){
          // May plot against motion curve or against a GC
          jXPopupMenu.removeAll();
          SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
          String[] coordNames = guiElem.getCoordinateNames();
          for(int i=0; i<coordNames.length; i++){
             final String coordinateName=coordNames[i];
             JMenuItem coordinateMenuItem = new JMenuItem(coordinateName);
             coordinateMenuItem.addActionListener(new ActionListener(){
                public void actionPerformed(ActionEvent e) {
                   setDomainName(coordinateName);
                   jXQtyTextField.setText(coordinateName);
                   CoordinateSet cs = currentModel.getDynamicsEngine().getCoordinateSet();
                   AbstractCoordinate coord = cs.get(coordinateName);
                   double conversionToGuiUnits=(coord.getMotionType()==AbstractDof.DofType.Rotational)?Math.toDegrees(1.0):1.0;
                   long l=Math.round(conversionToGuiUnits*coord.getRangeMin());
                   jDomainStartTextField.setValue((double)l);
                   l=Math.round(conversionToGuiUnits*coord.getRangeMax());
                   jDomainEndTextField.setValue((double)l);
                   updateContextGuiElements();
                   jPlotterAddPlotButton.setEnabled(validateXY());
      //printPlotDescriptor();
                }
             });
             jXPopupMenu.add(coordinateMenuItem);
          }
          jXPopupMenu.addSeparator();
          // for motions make a cascade menu
          ArrayList<PlotterSourceMotion> motionSources=plotterModel.getLoadedMotionSources();
          for(int i=0; i<motionSources.size(); i++){
             final PlotterSourceMotion nextMotion = motionSources.get(i);
             JMenuItem motionMenuItem = new JMenuItem(nextMotion.getDisplayName());
             motionMenuItem.addActionListener(new ActionListener(){
                public void actionPerformed(ActionEvent e) {
                   setDomainName(nextMotion.getDisplayName()+":time");
                   jXQtyTextField.setText(nextMotion.getDisplayName()+":time");
                   jDomainStartTextField.setValue((double)nextMotion.getDefaultMin("time"));
                   jDomainEndTextField.setValue((double)nextMotion.getDefaultMax("time"));
                   sourceX=nextMotion;
                   jPlotterAddPlotButton.setEnabled(validateXY());
                   updateContextGuiElements();
      //printPlotDescriptor();
                }
             });
             jXPopupMenu.add(motionMenuItem);
          }
          jXPopupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
      //printPlotDescriptor();
       } else{    // Select X from a motion or a file
          if (plotterModel.countSources()==0 || sourceX==null)
             return;
          xSelector.showSingleSelectionPanel(plotterModel,  sourceX);
          jDomainStartTextField.setValue((double)sourceX.getDefaultMin("time"));
          jDomainEndTextField.setValue((double)sourceX.getDefaultMax("time"));
          String dn = xSelector.getColumnToUse();
          setDomainName(dn);
          updateContextGuiElements();
          jPlotterAddPlotButton.setEnabled(validateXY());
      //printPlotDescriptor();
       }
       parseDomainOrRangeText(jXQtyTextField, true);
       
    }//GEN-LAST:event_xQuantityButtonMousePressed
    
    private void yQuantityButtonMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_yQuantityButtonMouseReleased
// TODO add your handling code here:
       //yQuantityButtonMousePressed(evt);
    }//GEN-LAST:event_yQuantityButtonMouseReleased
    
    private void yQuantityButtonMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_yQuantityButtonMousePressed
// TODO add your handling code here:
       jSourcePopupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
    }//GEN-LAST:event_yQuantityButtonMousePressed
        
   private void jXQtyTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jXQtyTextFieldPropertyChange
// TODO add your handling code here:
   }//GEN-LAST:event_jXQtyTextFieldPropertyChange
   
   private void jXQtyTextFieldCaretPositionChanged(java.awt.event.InputMethodEvent evt) {//GEN-FIRST:event_jXQtyTextFieldCaretPositionChanged
// TODO add your handling code here:
   }//GEN-LAST:event_jXQtyTextFieldCaretPositionChanged
   
    private void jDomainEndTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jDomainEndTextFieldPropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jDomainEndTextFieldPropertyChange
    
    private void jDomainStartTextFieldPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jDomainStartTextFieldPropertyChange
// TODO add your handling code here:
    }//GEN-LAST:event_jDomainStartTextFieldPropertyChange
    // AnalysisPick
    private PlotterSourceAnalysis[] initAnalyses() {
       plotterModel.addModel(currentModel);
       xQuantityButton.setEnabled(true);
       ArrayList<PlotterSourceAnalysis> srcs=plotterModel.getAnalysisSources();
       // Add available quantities to jAvailableAnalysesComboBox
       PlotterSourceAnalysis[] availableAnalyses= new PlotterSourceAnalysis[srcs.size()];
       for(int i=0; i<srcs.size();i++)
          availableAnalyses[i] = srcs.get(i);
       return availableAnalyses;
    }
    
   private void jXQtyTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jXQtyTextFieldFocusLost
      jPlotterAddPlotButton.setEnabled(validateXY());
      
   }//GEN-LAST:event_jXQtyTextFieldFocusLost
   
   private void jXQtyTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jXQtyTextFieldActionPerformed
      jPlotterAddPlotButton.setEnabled(validateXY());
      
   }//GEN-LAST:event_jXQtyTextFieldActionPerformed
   
   private void jYQtyTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jYQtyTextFieldFocusLost
      jPlotterAddPlotButton.setEnabled(validateXY());
      
   }//GEN-LAST:event_jYQtyTextFieldFocusLost
   
   private void jYQtyTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jYQtyTextFieldActionPerformed
      jPlotterAddPlotButton.setEnabled(validateXY());
      
   }//GEN-LAST:event_jYQtyTextFieldActionPerformed
   
   private void jPlotterDeletePlotButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterDeletePlotButtonActionPerformed
      
      // Make a cache so that object deletion does not mess up the selections array
      // we're working on.
      Object[] cache = new Object[selectedPathsVector.size()];
      selectedPathsVector.copyInto(cache);
      for(int i=0;i<cache.length; i++){
         TreePath nextPath = (TreePath)cache[i]; // Since the array shrinks!
         Object[] pathObjects = nextPath.getPath();
         int depth =pathObjects.length-1;
         DefaultMutableTreeNode node = (DefaultMutableTreeNode)pathObjects[depth];
         if (node instanceof PlotNode){
            Plot figToDelete = ((Plot)node.getUserObject());
            plotterModel.deletePlot(figToDelete);
         } else if (node instanceof PlotCurveNode){
            PlotCurve cvToDelete = ((PlotCurve)node.getUserObject());
            plotterModel.deleteCurve(cvToDelete);
         } else
            JOptionPane.showMessageDialog(this, "Don't know what to delete!");
         
      }
   }//GEN-LAST:event_jPlotterDeletePlotButtonActionPerformed
         
   private void jCurveLegendTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCurveLegendTextFieldActionPerformed
      
      autoGeneratedCurveTitle=false;   // user modified the text field don't intervene!'
   }//GEN-LAST:event_jCurveLegendTextFieldActionPerformed
   /**
    * Function to be invoked when the Add button is pressed
    */
   //XX5
   private void jPlotterAddCurveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPlotterAddCurveButtonActionPerformed
       // The following should repeat for every single Y qty selected
       String title = jPlotNameTextField.getText();
       PlotCurve plotCurve=null;
       if (isBuiltinMuscleCurve()){
           // run AnalysisTool once since model can't change in between'
           runAnalysisTool((PlotterSourceAnalysis) sourceY, sourceX, rangeNames);
       }
       // get Storages from sources
       int numCurves = sumCurve?1:rangeNames.length;
       PlotCurveSettings settings  = getSettings();
       String nameFromSettings=settings.getName();
       String nameFromRanges=getRangeNamesAsString();
       autoGeneratedCurveTitle=(nameFromSettings.compareTo(nameFromRanges)==0);
       jPlotsTree.clearSelection();
       for(int curveIndex=0; curveIndex<numCurves; curveIndex++){
           if (rangeNames.length>1){ // if user specified append index
               if (autoGeneratedCurveTitle)
                   settings.setName(sumCurve?getRangeNamesAsString("+"):rangeNames[curveIndex]);
               else{
                   if (numCurves==1)
                        settings.setName(nameFromSettings);
                   else
                        settings.setName(nameFromSettings+" "+String.valueOf(curveIndex));
               }
               // Make one string representing "+" separated 
           }
           // Add name for y-axis here
           if (sumCurve)
                plotCurve = plotterModel.addCurveMultipleRangeNames(title, settings,
                   sourceX, getDomainName(), sourceY, rangeNames);
           else 
                plotCurve = plotterModel.addCurveSingleRangeName(title, settings,
                   sourceX, getDomainName(), sourceY, rangeNames[curveIndex]);
           
            makeCurveCurrent(plotCurve);
       }
       
       this.doLayout();
       repaint();
   }//GEN-LAST:event_jPlotterAddCurveButtonActionPerformed
   
   private void makeCurveCurrent(final PlotCurve plotCurve) {
      // Find node and make it selected
      PlotCurveNode cvnode=((PlotTreeModel)plotterModel.getPlotTreeModel()).findCurveNode(plotCurve);
      TreeNode[] nodes = ((PlotTreeModel)plotterModel.getPlotTreeModel()).getPathToRoot(cvnode);
      TreePath path = new TreePath(nodes);
      jPlotsTree.addSelectionPath(path);
   }
   
   private void jLoadFileToPlotterMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jLoadFileToPlotterMenuItemActionPerformed
      
      // Browse for Storage or Motion file (for now) and preprocess the file if needed for plotting
      String dataFilename = FileUtils.getInstance().browseForFilename(".sto, .mot", "Files containing data to plot", true);
      if (dataFilename != null){
         try {
            PlotterSourceFile src = new PlotterSourceFile(dataFilename);
            getPlotterModel().addSource(src);
         } catch (IOException ex) {
            ex.printStackTrace();
         }
      }
   }//GEN-LAST:event_jLoadFileToPlotterMenuItemActionPerformed
   
   
   public PlotterModel getPlotterModel() {
      return plotterModel;
   }
   
   private PlotCurveSettings getSettings() {
      return new PlotCurveSettings(this);
   }
   
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JButton jAdvancedOptionsButton;
   private javax.swing.JPanel jAdvancedPanel;
   private javax.swing.JCheckBox jClampCheckBox;
   private javax.swing.JTextField jCurveLegendTextField;
   private javax.swing.JFormattedTextField jDomainEndTextField;
   private javax.swing.JFormattedTextField jDomainStartTextField;
   private javax.swing.JFormattedTextField jFormattedTextFieldYmax;
   private javax.swing.JFormattedTextField jFormattedTextFieldYmin;
   private javax.swing.JLabel jLabel1;
   private javax.swing.JLabel jLabel10;
   private javax.swing.JLabel jLabel2;
   private javax.swing.JLabel jLabel3;
   private javax.swing.JLabel jLabel9;
   private javax.swing.JMenuItem jLoadFileToPlotterMenuItem;
   private javax.swing.JPopupMenu jMusclePopupMenu;
   private javax.swing.JButton jMuscleSelectButton;
   private javax.swing.JPanel jPanel1;
   private javax.swing.JPanel jPlotControlPanel;
   private javax.swing.JLabel jPlotLabelJLabel;
   private javax.swing.JTextField jPlotNameTextField;
   private javax.swing.JPanel jPlotNavigationPanel;
   private javax.swing.JPopupMenu jPlotPropertiesPopupMenu;
   private javax.swing.JPanel jPlotSpecPanel;
   private javax.swing.JPanel jPlotTitlePanel;
   private javax.swing.JTree jPlotsTree;
   private javax.swing.JButton jPlotterAddPlotButton;
   private javax.swing.JButton jPlotterDeletePlotButton;
   private javax.swing.JMenu jPlotterFileMenu;
   private javax.swing.JMenuBar jPlotterMenuBar;
   private javax.swing.JButton jPropertiesButton;
   private javax.swing.JCheckBox jRectifyCheckBox;
   private javax.swing.JScrollPane jScrollPane1;
   private javax.swing.JTextField jSelectedMusclesTextField;
   private javax.swing.JPopupMenu jSourcePopupMenu;
   private javax.swing.JSplitPane jSplitPane1;
   private javax.swing.JTextField jSummaryAdvancedTextField;
   private javax.swing.JPanel jTopChartingPanel;
   private javax.swing.JPopupMenu jXPopupMenu;
   private javax.swing.JTextField jXQtyTextField;
   private javax.swing.JTextField jYQtyTextField;
   private javax.swing.JButton xQuantityButton;
   private javax.swing.JButton yQuantityButton;
   // End of variables declaration//GEN-END:variables
   
   public String getPlotName() {
      return jPlotNameTextField.getText();
   }

   private void updateContextGuiElements() {
      currentCurveTitle=getRangeNamesAsString();
      jCurveLegendTextField.setText(currentCurveTitle);
   }
   
   public boolean isAutoGeneratedCurveTitle() {
      return autoGeneratedCurveTitle;
   }
   
   public void setAutoGeneratedCurveTitle(boolean autoGeneratedCurveTitle) {
      this.autoGeneratedCurveTitle = autoGeneratedCurveTitle;
   }
   
   public String getCurveName() {
      return jCurveLegendTextField.getText();
   }
   /**
    * This method is to be invoked after X or Y selection either when the selection
    *  dialog is brought down or after user typing in data in the X,Y textfields
    * (and probably a few other situations)
    * to update
    *    - default curve name if not modified by user
    *    - X-bounds
    * Very important piece here is parseDomainOrRangeText see comments there.
    *
   public void updatePlotterWithSelection() {
      jPlotterAddPlotButton.setEnabled(validateXY());
      
   }*/
   /**
    * TreeSelectionListener implementation
    */
   public void valueChanged(TreeSelectionEvent e) {
      getCurrentTreeSelection(e);
      
      jPlotterDeletePlotButton.setEnabled(false);
      //jPlotterUpdatePlotButton.setEnabled(false);
      if (selectedPathsVector.size()==0)
         return;
      
      // Make sure we have a curve before enabling update
      if (selectedPathsVector.size()==1){
         TreeNode lastNode=(TreeNode)selectedPathsVector.get(0).getLastPathComponent();
         if (lastNode instanceof PlotCurveNode){
            // Populate dialog
            PlotCurve cv = (PlotCurve)((PlotCurveNode)lastNode).getUserObject();
            updatePanelFromCurve(cv);
            //jPlotterUpdatePlotButton.setEnabled(true);
            jPlotterDeletePlotButton.setEnabled(true);
         }
      } else {   // Enable delete if only curves are selected as we can't delete full plots now'
         boolean allCurves=true;
         for(int i=0; i<selectedPathsVector.size() && allCurves; i++){
            TreeNode lastNode=(TreeNode)selectedPathsVector.get(i).getLastPathComponent();
            allCurves =(lastNode instanceof PlotCurveNode);
         }
         jPlotterDeletePlotButton.setEnabled(allCurves);
      }
   }
   
   private void getCurrentTreeSelection(TreeSelectionEvent e) {
      TreePath[] selectedPaths = e.getPaths();
      for(int i=0;i<selectedPaths.length;i++){
         if (e.isAddedPath(i)){
            selectedPathsVector.add(selectedPaths[i]);
         } else {   //Removed
            selectedPathsVector.remove(selectedPaths[i]);
         }
      }
   }
   
   void setMinX(double minX) {
      jDomainStartTextField.setValue(minX);
   }
   
   double getMinX() {
      return ((Double)jDomainStartTextField.getValue()).doubleValue();
   }
   
   void setMaxX(double maxX) {
      jDomainEndTextField.setValue(maxX);
   }
   
   double getMaxX() {
      return ((Double)jDomainEndTextField.getValue()).doubleValue();
   }
   
   boolean getRectify() {
      return jRectifyCheckBox.isSelected();
   }
   /**
    * updatePanelFromCurve is invoked when selection on the tree changes.
    * need to make sure that the following are set
    * PlotterSourceInterface  sourceX, sourceY;
    * String      domainName;
    * String[]    rangeNames;
    */
   private void updatePanelFromCurve(PlotCurve cv) {
      // Populate Curve name, filters
       /*
      currentCurve=cv;
      jPlotNameTextField.setText(plotterModel.getPlotForCurve(cv).getTitle());
      sourceX=cv.getDomainSource();
      sourceY=cv.getRangeSource();
      setDomainName(cv.getDomainName());
      String[] curveRangeNames = cv.getRangeNames();
      rangeNames = new String[curveRangeNames.length];
      System.arraycopy(curveRangeNames, 0, rangeNames, 0, curveRangeNames.length);
      if (cv.getSettings().isMusclePlot())
         jSelectedMusclesTextField.setText(PlotterModel.makeSumString(rangeNames));
      else
         jSelectedMusclesTextField.setText("");
      // set title based on figurxe title
      jCurveLegendTextField.setText(cv.getLegend());
      setMinX(cv.getSettings().getXMin());
      setMaxX(cv.getSettings().getXMax());
      // Form domain label
      //ArrayStr arx = cv.getDomainStorage().getColumnLabels();
      String sourceString=cv.getDomainSource().getDisplayName();
      String colName =cv.getDomainName();
      jXQtyTextField.setText(domainName);
      // Form range label
      //ArrayStr ary = cv.getRangeStorage().getColumnLabels();
      sourceString=cv.getRangeSource().getDisplayName();
      colName =PlotterModel.makeSumString(cv.getRangeNames());
      if (cv.getSettings().isMusclePlot()){
         jYQtyTextField.setText(sourceY.getDisplayName());
      } else {
         jYQtyTextField.setText(colName);
      }
      // Now the filters
      jRectifyCheckBox.setSelected(false);
      Vector<PlotDataFilter> filters = cv.getSettings().getFilters();
      for(int i=0; i<filters.size(); i++){
         if (filters.get(i) instanceof PlotRectifyFilter)
            jRectifyCheckBox.setSelected(true);
         
      }*/
   }
   
   public void showTimeCurves(String title, String plot, Storage residualsStore, String[] names) {
   }
   
   /**
    * Popups have a single purpose, to populate the Text fields with valid values, but users can
    * type those in manually. The following parse functions try to recover the source storage, columns
    * from the Text fields for quantities. On successful parsing (names and sources local variables are set).
    * The syntax for File sources is File:<xxxx>:<yyyyy>
    **/
   private boolean parseDomainOrRangeText(JTextField jQtyTextField, boolean isDomain) {
      
      String text = jQtyTextField.getText();
      // Check for Empty
      if (text.length()==0)
         return false;
      
      // Check for qualifiers
      // We need to be forgiving in case the user types in the quantity manually
      String trimmed = text.trim();
      // Split around ":
      String columnNameList = trimmed;
      // If file doesn't exist or doesn't have column complain, otherwise
      // set Storage and Column
      String[] columns=columnNameList.trim().split(",",-1);
      if (isDomain){
         if (columns.length!=1){
            JOptionPane.showMessageDialog(this, "Can't have more than one column for domain");
            return false;
         } else{
            setDomainName(columns[0].trim());
            return true; // Should check coordinate exists
         }
      } else {   // range
         for(int i=0; i<columns.length; i++){
            columns[i]=columns[i].trim();
         }
         rangeNames = new String[columns.length];
         System.arraycopy(columns, 0, rangeNames, 0, columns.length);
         // set sourceY here after all error detection is done.
         return true;
      }
      
   }
   private String getRangeNamesAsString() {
       return getRangeNamesAsString(",");
   }
   /**
    * Get a string representing the list of column names
    */
  private String getRangeNamesAsString(String separator) {
      String rep="";
       /*NoQualifiers
       if (isBuiltinMuscleCurve())
         rep="select muscle";
       **/
      if (rangeNames!=null){
          /*NoQualifiers
         if (isBuiltinMuscleCurve()){
            rep=jYQtyTextField.getText()+":";
         } else
            rep=sourceY.getDisplayName()+":";
           **/
         for(int i=0; i<rangeNames.length; i++){
            rep = rep + rangeNames[i];
            if (i<rangeNames.length-1)
               rep = rep + separator;
         }
      }
      return rep;
   }
   
   public PlotCurve showAnalysisCurveAgainstTime(Model aModel, Storage s,
           String title,
           String curveLegend, String columnName,
           String xLabel, String yLabel) {
        /*
        sourceX = new PlotterSourceAnalysis(aModel, s, columnName);
        sourceY = sourceX;
        setDomainName("time");
        rangeNames = new String[]{columnName};
        jPlotNameTextField.setText(curveLegend);
        PlotCurveSettings settings  = getSettings();
        PlotCurve plotCurve=null;
        //settings.setXMin(s.getFirstTime());
        //settings.setXMax(s.getLastTime());
        plotCurve = plotterModel.addCurveSingleRangeName(title, settings,
                sourceX, getDomainName(),                 sourceY, rangeNames[0]);
        makeCurveCurrent(plotCurve);
         **/
      return null;//;
   }
   /**
    * This will be triggered when motion time changes.
    * Then we need to update X-crosshairs to match time
    */
   public void update(Observable o, Object arg) {
      if (o instanceof MotionsDB) {
         if (arg instanceof MotionTimeChangeEvent){
            MotionTimeChangeEvent motionTimeEvent = (MotionTimeChangeEvent)arg;
            double time=motionTimeEvent.getTime();
            // Should cast arg to proper event and set X-crosshairs
            if (getDomainName().compareTo("time")==0){
               plotterModel.getCurrentPlot().setDomainCrosshair(time);
            }
         }
         else if (arg instanceof MotionEvent){
            MotionEvent mev = (MotionEvent) arg;
            if (mev.getOperation()==mev.getOperation().Open && mev.getModel()==currentModel){
               plotterModel.addMotion(mev.getMotion());
               populateYPopup();
            }
         }
      }
      else if (o instanceof OpenSimDB){
         if (arg instanceof ObjectSetCurrentEvent) {
            ObjectSetCurrentEvent evt = (ObjectSetCurrentEvent)arg;
            Vector<OpenSimObject> objs = evt.getObjects();
            // If any of the event objects is a model, this means there is a new
            // current model. So update the Y menu.
            for (int i=0; i<objs.size(); i++) {
               if (objs.get(i) instanceof Model) {
                  currentModel = (Model)objs.get(i);
                  processCurrentModel();
                  populateYPopup();           
                  break;
               }
            }
         } else if (arg instanceof ModelEvent) {
            ModelEvent evt = (ModelEvent)arg;
            if (evt.getModel()==currentModel && evt.getOperation()==ModelEvent.Operation.Close){
               currentModel=null;
               populateYPopup();            
            }
            else if (evt.getOperation()==ModelEvent.Operation.SetCurrent){
               currentModel=evt.getModel();
               populateYPopup();           
            }
            // Handle model open so that an AnalyzeTool is created.
         }
      }
   }
   /**
    * Run an analysis to compute curves for muscle analyses operating on current model
    * domainName is assumed to be set. If starts with Motion: then we assume we're plotting
    * against a motion curve otherwise it's vs. Generalized coordinate of the current model
    *
    */
   void runAnalysisTool(PlotterSourceAnalysis source, PlotterSourceInterface motion, String[] ranges) {
      AnalyzeTool tool = plotterModel.getAnalyzeTool(currentModel);
      tool.setSolveForEquilibrium(true);
      PlotterSourceAnalysis analysisSource = (PlotterSourceAnalysis)source;
      plotterModel.configureAnalyses(tool, analysisSource, domainName, ranges);
      // Save the state before running the analysis so that we can restore the model afterwards
      int numStates = currentModel.getNumStates();
      ArrayStr stateNames = new ArrayStr();
      currentModel.getStateNames(stateNames);
      // Save states for later restoration so that the GUI and model are in sync. after analysis
      double[] saveStates = new double[numStates];
      currentModel.getStates(saveStates);
      
      Storage extendedMotionStorage;
       if (motion != null && motion instanceof PlotterSourceMotion){
         tool.setStartTime( motion.getStorage().getFirstTime());
         tool.setFinalTime( motion.getStorage().getLastTime());
         statesStorage = buildStatesStorageFromMotion(motion.getStorage(), false, 1.0);
         tool.setStatesStorage(statesStorage);
      } else {
          // make states for analysis by setting fiberlength and activation and form complete storage
          double[] statesForAnalysis = new double[numStates];
          currentModel.getStates(statesForAnalysis);
          setNonzeroDefaultValues(stateNames, statesForAnalysis);
         double NUM_STEPS=100.0;
         int xIndex = statesStorage.getStateIndex(getDomainName());
         AbstractCoordinate coord = currentModel.getDynamicsEngine().getCoordinateSet().get(getDomainName());
         
         double domStart=(Double)jDomainStartTextField.getValue();
         double domEnd=(Double)jDomainEndTextField.getValue();
         if (coord.getMotionType() == AbstractDof.DofType.Rotational){
            domStart=Math.toRadians(domStart);
            domEnd=Math.toRadians(domEnd);
         }
         // Make 100 steps along the way, varying the quantity on sourceX by 1/100 of the distance between domStart & domEnd
         statesStorage.purge();
         for(int i=0; i<NUM_STEPS; i++){
            double time = (double)i;
            double increment = 1./NUM_STEPS*(domEnd-domStart);
            double val=domStart+increment*i;
            //double degVal = Math.toDegrees(val);
            //System.out.println("Step="+i+", val="+degVal);
            statesForAnalysis[xIndex]=val;
            StateVector newVector = new StateVector();
            newVector.setStates(time, numStates, statesForAnalysis);
            statesStorage.append(newVector);
         }
         tool.setStatesStorage(statesStorage);
         tool.setStartTime(0.);
         tool.setFinalTime(NUM_STEPS);
         sourceX=new PlotterSourceAnalysis(currentModel, statesStorage, "");
         statesStorage.print("toolInput.sto");
      }
      tool.setPrintResultFiles(false);
      analysisSource.getStorage().purge();
      tool.run();
      analysisSource.getStorage().print("toolOutput.sto");
      currentModel.getDynamicsEngine().convertRadiansToDegrees(analysisSource.getStorage());
      currentModel.getDynamicsEngine().convertRadiansToDegrees(statesStorage);
      currentModel.setStates(saveStates);
   }

    private void setNonzeroDefaultValues(final ArrayStr stateNames, final double[] statesForAnalysis) {
        for(int i=0; i<statesForAnalysis.length; i++){
           if (stateNames.getitem(i).endsWith(".fiber_length"))
              statesForAnalysis[i]=0.01;
           else if (stateNames.getitem(i).endsWith(".activation"))
              statesForAnalysis[i]=1.0;        // Should be filled from GUI.
        }
    }
   
   private Storage createStateStorageWithHeader(final Model mdl) {
      // set tool attributes
      Storage statesStorage = new Storage();
      // Column labels for StateStorage
      ArrayStr stateNames = new ArrayStr();
      mdl.getStateNames(stateNames);
      stateNames.insert(0, "time");
      statesStorage.setColumnLabels(stateNames);
      return statesStorage;
   }
   
   private void resetXY() {
      jXQtyTextField.setText("");
      jYQtyTextField.setText("");
      jDomainStartTextField.setText("");
      jDomainEndTextField.setText("");
   }
   
   private void processCurrentModel() {
      if (currentModel!=null){
         initAnalyses();
         statesStorage=createStateStorageWithHeader(currentModel);
      }
      populateYPopup();
   }
   /**
    * Populate the top level pop up for Y-qty to use.
    */
   private void populateYPopup() {
      jSourcePopupMenu.removeAll();
      // Add analyses
      // Add Motions
      // Add files
      if (currentModel!=null){
         // Built in
         ////////////////////////////////////////////////////////////////////////
         // Analyses
         ////////////////////////////////////////////////////////////////////////
         AnalysisSet analyses = currentModel.getAnalysisSet();
         assert(analyses!=null);
         boolean addedSomething=false;
         /// Builtin
         for (int i=0; i< plotterModel.getBuiltinQuantities().length; i++){
            final String qName = plotterModel.getBuiltinQuantities()[i];
            if (qName.startsWith("moment")){   // Need a cascade menu to select a GC
               final String internalName=(qName.equalsIgnoreCase("moment"))?"Moment_":"MomentArm_";
               JMenu gcMenu = new JMenu(qName);
               SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
               String[] coordNames = guiElem.getCoordinateNames();
               for(int j=0; j<coordNames.length; j++){
                  final String coordinateName=coordNames[j];
                  JMenuItem coordinateMenuItem = new JMenuItem(coordinateName);
                  coordinateMenuItem.addActionListener(new ActionListener(){
                     public void actionPerformed(ActionEvent e) {
                        //XX4
                        useMuscles(true);
                        jYQtyTextField.setText(coordinateName +" "+qName);
                        updateContextGuiElements();
                        sourceY=(new PlotterSourceAnalysis(currentModel, plotterModel.getStorage(internalName+coordinateName, currentModel), qName));
                  //printPlotDescriptor();
                     }
                  });
                  gcMenu.add(coordinateMenuItem);
               }
               jSourcePopupMenu.add(gcMenu);
               continue;
            }
            JMenuItem quantityMenuItem = new JMenuItem(qName);
            jSourcePopupMenu.add(quantityMenuItem);
            quantityMenuItem.addActionListener(
                    new ActionListener(){
               public void actionPerformed(ActionEvent e) {
                  // Show multipleSelect dialog with all muscles
                  // Populate YQty text field with selection
                  //XX1
                  jYQtyTextField.setText(qName);
                  useMuscles(true);
                  updateContextGuiElements();
                  sourceY=(new PlotterSourceAnalysis(currentModel, plotterModel.getStorage(qName, currentModel), qName));
                  //printPlotDescriptor();
               }
            });
         }
         // Other Analyses
         for(int i=0;i<analyses.getSize();i++){
            final Analysis nextAnalysis = analyses.get(i);
            if (nextAnalysis.getName().equalsIgnoreCase("MuscleAnalysis"))
               continue;
            JMenu nextAnalysisSubmenu = new JMenu(nextAnalysis.getName());
            // Get storages and create a menu item for each
            ArrayStorage storages = nextAnalysis.getStorageList();
            for(int storageIndex=0; storageIndex<storages.getSize(); storageIndex++){
               final Storage resultStorage = storages.get(storageIndex);
               JMenuItem quantityMenuItem = new JMenuItem(resultStorage.getName());
               nextAnalysisSubmenu.add(quantityMenuItem);
               quantityMenuItem.addActionListener(
                       new ActionListener(){
                  public void actionPerformed(ActionEvent e) {
                     // Show multipleSelect dialog with all muscles
                     // Populate YQty text field with selection
                     //XX1
                     jYQtyTextField.setText(nextAnalysis.getName()+":"+resultStorage.getName());
                     useMuscles(true);
                     updateContextGuiElements();
                     sourceY=(new PlotterSourceAnalysis(currentModel, resultStorage, nextAnalysis.getName()+":"+resultStorage.getName()));
                     //printPlotDescriptor();
                  }
               });
            }
            jSourcePopupMenu.add(nextAnalysisSubmenu);
            addedSomething=true;
         }  // Current model's analyses'
         jSourcePopupMenu.addSeparator();
         // Now motions
         ////////////////////////////////////////////////////////////////////////
         // Motions
         ////////////////////////////////////////////////////////////////////////
         addedSomething=false;
         ArrayList<Storage> motions = MotionsDB.getInstance().getModelMotions(currentModel);
         if (motions!=null){
            for(int i=0; i<motions.size(); i++){
               Storage nextMotionStorage = motions.get(i);
               // Make a copy with correct units e.g. degrees here
               final PlotterSourceInterface nextMotion=getPlotterModel().addMotion(nextMotionStorage);
               JMenuItem motionMenuItem = new JMenuItem(nextMotion.getDisplayName()+"...");
               motionMenuItem.addActionListener(new MotionSelectionListener(nextMotion));
                  jSourcePopupMenu.add(motionMenuItem);
                  addedSomething=true;
            }
         }
         if (addedSomething)
            jSourcePopupMenu.addSeparator();
      }
      ////////////////////////////////////////////////////////////////////////
      // Free Files
      ////////////////////////////////////////////////////////////////////////
      // Now add free files
      ArrayList<PlotterSourceFile> fileSources=plotterModel.getLoadedFileSources();
      if (fileSources!=null && fileSources.size()>0){
         for(int i=0; i<fileSources.size(); i++){
            final PlotterSourceFile nextSource = fileSources.get(i);
            JMenuItem fileMenuItem = new JMenuItem(nextSource.getDisplayName()+"...");
            fileMenuItem.addActionListener(new FileSelectionListener(nextSource));
               jSourcePopupMenu.add(fileMenuItem);
         }
      }
      JMenuItem newfileMenuItem = new JMenuItem("New file...");
      newfileMenuItem.addActionListener(new ActionListener(){
         public void actionPerformed(ActionEvent e) {
            // browse for file
            String dataFilename = FileUtils.getInstance().browseForFilename(".sto, .mot", "Files containing data to plot", true);
            if (dataFilename != null){
               PlotterSourceFile src= getPlotterModel().addFile(dataFilename);
               xQuantityButton.setEnabled(getPlotterModel().countSources()>0);
               populateYPopup();
               // Proceed as if it's selected'
               new FileSelectionListener(src).actionPerformed(null);
            }
         }});
         jSourcePopupMenu.add(newfileMenuItem);
   }
   
   private void useMuscles(boolean onOff) {
      boolean oldState=isBuiltinMuscleCurve();
      setBuiltinMuscleCurve(onOff);
      jMuscleSelectButton.setEnabled(onOff);
      if (onOff==false)
         jSelectedMusclesTextField.setText("");
   }
   
   public String getDomainName() {
      if (domainName==null){
         return "select X";
      }
      return domainName;
   }
   
   public void setDomainName(String domainName) {
      this.domainName = domainName;
   }
   
   public boolean isBuiltinMuscleCurve() {
      return builtinMuscleCurve;
   }
   
   public void setBuiltinMuscleCurve(boolean muscleSpecific) {
      this.builtinMuscleCurve = muscleSpecific;
   }
   
   private boolean validateXY() {
       boolean validXY=false;
       if (sourceY==null)
           return false;
      // Same file source in both X, Y
       if (sourceY instanceof PlotterSourceFile){
           if ((sourceX!=null) &&
                   (sourceX instanceof PlotterSourceFile) &&
                   sourceX.getStorage()==sourceY.getStorage())
               validXY=sourceX.isValidName(jXQtyTextField.getText());  // Check some X is selected and is valid for file
           return validXY;
       }
       if (sourceY instanceof PlotterSourceMotion){
           if ((sourceX!=null) &&
                   (sourceX instanceof PlotterSourceMotion) &&
                   sourceX.getStorage()==sourceY.getStorage())
               validXY=sourceX.isValidName(jXQtyTextField.getText());
           return validXY;
       }
       if (builtinMuscleCurve){
           // Check that some muscles have been selected
           String dom = getDomainName();
           // Todo check dom is valid so that Add is not enabled prematurely
           //
           return validateMuscleNames(rangeNames);
           // Y is one of the built in quantities or a user's analysis'
           //if (sourceY!=null && sourceY.size()>0){   // Same file source in both X, Y
           //if (sourceY instanceof PlotterSourceAnalysis){
           // X could be either a motion, motion column or a gc
           // quantity should always be non-empty either a muscle or a group of muscles
           //int x=0;
           //}
           //}
       }
       return false;
   }

   public boolean isClamp() {
      return clamp;
   }

   public void setClamp(boolean clamp) {
      this.clamp = clamp;
   }

   double getMinY() {
      return ((Double)jFormattedTextFieldYmin.getValue()).doubleValue();
   }

   double getMaxY() {
      return ((Double)jFormattedTextFieldYmax.getValue()).doubleValue();
   }
   class handleReturnAction extends AbstractAction {
        JFormattedTextField jFormattedTextField;
        public handleReturnAction(JFormattedTextField textfield)
        {
           jFormattedTextField = textfield;
        }
        public void actionPerformed(ActionEvent e) {
           if (!jFormattedTextField.isEditValid()) { //The text is invalid.
              String text = jFormattedTextField.getText();
              // Try to parse the text into a double as it could be out of range, in this case truncate
              try {
                  double valueFromTextField = Double.parseDouble(text);
                  jFormattedTextField.setText(String.valueOf(valueFromTextField)) ;
                  jFormattedTextField.commitEdit();
              }
              catch (NumberFormatException ex){
                 // Really invalid text for a double
              }
              catch (ParseException ex){
                 // Really invalid text for a double
              }
         }
        }
     }

   public boolean isModelChanged() {
      return modelChanged;
   }

   public void setModelChanged(boolean modelChanged) {
      this.modelChanged = modelChanged;
   }

   private void invokeTreePopupIfNeeded(int evtX, int evtY) {
      TreePath clickedElement = jPlotsTree.getPathForLocation(evtX, evtY);
       
      //  Display the name of the selected tree element in the selection field
      String clickedElementName;
      if (clickedElement != null){
         Object[] pathObjects = clickedElement.getPath();
         int depth =pathObjects.length-1;
         DefaultMutableTreeNode node = (DefaultMutableTreeNode)pathObjects[depth];
         PlotCurve cv=null;
         if (node instanceof PlotNode){ // Chart properties
         } else if (node instanceof PlotCurveNode){
            cv = ((PlotCurve)node.getUserObject());
         }
         final PlotCurve cv2=cv;
         JPopupMenu curvePopup = new JPopupMenu();
         JMenuItem infoMenuItem = new JMenuItem("Info...");
         infoMenuItem.addActionListener(new ActionListener(){
                public void actionPerformed(ActionEvent e) {
                    // Make label of curve name, domain name, range name
                 NotifyDescriptor.Message dlg =
                         new NotifyDescriptor.Message("Curve Name: "+cv2.getCurveSeries().getKey()+
                         " of "+cv2.getRangeNames()+" vs. "+cv2.getDomainName());
                 DialogDisplayer.getDefault().notify(dlg);
                }});
         curvePopup.add(infoMenuItem);
         JMenuItem renamMenuItem = new JMenuItem("Rename...");
         renamMenuItem.addActionListener(new ActionListener(){
             public void actionPerformed(ActionEvent e) {
                 NotifyDescriptor.InputLine dlg =
                         new NotifyDescriptor.InputLine("Current Name: "+cv2.getCurveSeries().getKey(), "Rename Curve to");
                 if(DialogDisplayer.getDefault().notify(dlg)==NotifyDescriptor.OK_OPTION){
                     String newName = dlg.getInputText();
                     cv2.getCurveSeries().setKey(newName);
                     cv2.getCurveSeries().fireSeriesChanged();
                 }
             }
         });
         curvePopup.add(renamMenuItem);
         curvePopup.show(jPlotsTree, evtX, evtY);
      }
      
   }

   /** 
    * Handle file selection pick in Quantity Y popup
    */
   private class FileSelectionListener implements ActionListener {

      private PlotterSourceFile nextSource;

      public FileSelectionListener(PlotterSourceFile nextSource) {
         super();
         this.nextSource = nextSource;
      }

      public void actionPerformed(ActionEvent e) {
         sourceY=nextSource;
         sourceX = nextSource;
         PlotterQuantityNameFilterJPanel filterpanel = new PlotterQuantityNameFilterJPanel(sourceX);
         String dialogTitle="";
         if (sourceX instanceof PlotterSourceMotion)
            dialogTitle="Select motion quantity";
         else
            dialogTitle="Select data column(s) to plot";
         DialogDescriptor dlg = new DialogDescriptor(filterpanel, dialogTitle);
         dlg.setModal(true);
         DialogDisplayer.getDefault().createDialog(dlg).setVisible(true);
         if (((Integer) dlg.getValue()).compareTo((Integer) DialogDescriptor.OK_OPTION) == 0) {
            jYQtyTextField.setText(filterpanel.getSelectedAsString());
            rangeNames = new String[filterpanel.getNumSelected()];
            System.arraycopy(filterpanel.getSelected(), 0, rangeNames, 0, filterpanel.getNumSelected());
            useMuscles(false);
            updateContextGuiElements();
            jPlotterAddPlotButton.setEnabled(validateXY());
//printPlotDescriptor();
         }
      }
   }

   /** 
    * Handle motion pick in Quantity Y popup
    */
   private class MotionSelectionListener implements ActionListener {

      private PlotterSourceInterface nextMotion;

      public MotionSelectionListener(PlotterSourceInterface nextMotion) {
         super();
         this.nextMotion = nextMotion;
      }

      public void actionPerformed(ActionEvent e) {
         sourceY=(nextMotion);
         sourceX = sourceY;
         PlotterQuantityNameFilterJPanel filterpanel = new PlotterQuantityNameFilterJPanel(sourceY);
         DialogDescriptor dlg = new DialogDescriptor(filterpanel, "Select Motion Quantity");
         dlg.setModal(true);
         DialogDisplayer.getDefault().createDialog(dlg).setVisible(true);
         if (((Integer) dlg.getValue()).compareTo((Integer) DialogDescriptor.OK_OPTION) == 0) {
            jYQtyTextField.setText( filterpanel.getSelectedAsString());
            rangeNames = new String[filterpanel.getNumSelected()];
            System.arraycopy(filterpanel.getSelected(), 0, rangeNames, 0, filterpanel.getNumSelected());
            useMuscles(false);
            updateContextGuiElements();
            jPlotterAddPlotButton.setEnabled(validateXY());
 //printPlotDescriptor();
         }
      }
   }

   void printPlotDescriptor()
   {
       System.out.println("================================");
       System.out.println("Domain name =["+domainName+"]");
       if (rangeNames==null)
            System.out.println("Range name =["+null+"]");
       else{
           System.out.println("Range names length =["+rangeNames.length+"]");
           for(int i=0; i<rangeNames.length; i++)
                System.out.println("Range names =["+rangeNames[i]+"]");
       }
       System.out.println("flags sum=["+sumCurve+"], muscle=["+builtinMuscleCurve+"]");
       if (sourceX == null)
            System.out.println("sourceX =["+null+"]");
       else
           System.out.println("sourceX =["+sourceX.getDisplayName()+"]");
       if (sourceY == null)
            System.out.println("sourceY =["+null+"]");
       else{
           System.out.println("sourceY =["+sourceY.getDisplayName()+"]");
       }
        System.out.println("================================");
          
   }
   private Storage buildStatesStorageFromMotion(Storage motionsStorage, boolean overrideActivation, double newActivation) {
      // Make a new Storage with correct size/labels
      Storage outputStorage = new Storage();
      int numStates = currentModel.getNumStates();
      ArrayStr stateNames = new ArrayStr();
      currentModel.getStateNames(stateNames);
      ArrayStr stateNamesWithTime = new ArrayStr(stateNames);
      stateNamesWithTime.insert(0, "time");
      outputStorage.setColumnLabels(stateNames);
      // Cycle thru stateNames if name exists in motionsStorage then use it,
      // if activation orride with passed in value if desired
      ArrayStr motionStateNames = motionsStorage.getColumnLabels();
      for(int i=0; i<motionStateNames.getSize(); i++){
         System.out.println("motionStateNames "+i+" is "+motionStateNames.getitem(i));
      }
      ArrayList<Integer> mapColumns= new ArrayList<Integer>(stateNames.getSize());
      ArrayList<Boolean> activationColumns= new ArrayList<Boolean>(stateNames.getSize());
      int numRows = motionsStorage.getSize();
      for(int i=0; i<numStates;i++){
         String currentStateName=stateNames.getitem(i);
         int indexInMotionFile = motionStateNames.findIndex(currentStateName)-1; // account 4 time
         mapColumns.add(i, indexInMotionFile);
         activationColumns.add(i, currentStateName.endsWith(".activation"));
      }
      double[] buffer = new double[numStates];
      for(int i=0; i<numRows; i++){
         StateVector statesFromMotion = motionsStorage.getStateVector(i);
         int numColumnsInMotionFile = statesFromMotion.getSize();
         ArrayDouble dataFromMotion=statesFromMotion.getData();
         StateVector outputStateVector = new StateVector(numStates);
         for(int j=0; j<numStates;j++){
            if (mapColumns.get(j)!=-2){
               buffer[j]=dataFromMotion.getitem(mapColumns.get(j));
            }
            else
               buffer[j]=0.0;
            if (activationColumns.get(j) && overrideActivation)
               buffer[j]=newActivation;
         }
         outputStateVector.setStates(statesFromMotion.getTime(), numStates, buffer);
         outputStorage.append(outputStateVector);
      }
      return outputStorage;
   }

   private boolean validateMuscleNames(String[] rangeNames) {
      boolean validMuscles = false;
      if (rangeNames == null || currentModel==null)   // Have to have a model
         return false;
      
      SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
      Vector<String> muscleNames = guiElem.getMuscleNames();
      validMuscles = true;
      for(int i=0; i< rangeNames.length && validMuscles; i++){
         validMuscles=(muscleNames.contains(rangeNames[i]));
      }
      return validMuscles;
   }

   void updatePlotterWithSelection() {
            jPlotterAddPlotButton.setEnabled(validateXY());
   }
   
}
