package org.opensim.view.markerEditor;

import java.awt.Dimension;
import java.awt.Toolkit;
import java.io.Serializable;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Observable;
import java.util.Observer;
import java.util.Vector;
import javax.swing.JOptionPane;
import org.openide.ErrorManager;
import org.openide.nodes.Node;
import org.openide.util.NbBundle;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;
import org.opensim.modeling.AbstractBody;
import org.opensim.modeling.AbstractMarker;
import org.opensim.modeling.BodySet;
import org.opensim.modeling.MarkerSet;
import org.opensim.modeling.Model;
import org.opensim.modeling.OpenSimObject;
import org.opensim.view.ClearSelectedObjectsEvent;
import org.opensim.view.DragObjectsEvent;
import org.opensim.view.ExplorerTopComponent;
import org.opensim.view.ModelEvent;
import org.opensim.view.NameChangedEvent;
import org.opensim.view.ObjectSelectedEvent;
import org.opensim.view.ObjectSetCurrentEvent;
import org.opensim.view.ObjectsChangedEvent;
import org.opensim.view.SingleModelGuiElements;
import org.opensim.view.SingleModelVisuals;
import org.opensim.view.nodes.OneMarkerNode;
import org.opensim.view.pub.OpenSimDB;
import org.opensim.view.pub.ViewDB;

/**
 * Top component which displays something.
 */
final public class MarkerEditorTopComponent extends TopComponent implements Observer {

   private static MarkerEditorTopComponent instance;
   /** path to the icon used by the component and its open action */
//    static final String ICON_PATH = "SET/PATH/TO/ICON/HERE";

   private Model currentModel = null;
   private AbstractMarker currentMarker = null; // the marker that is currently shown in the Marker Editor window
   private Hashtable<AbstractMarker, Boolean> pendingChanges = new Hashtable<AbstractMarker, Boolean>();
   private Hashtable<AbstractMarker, AbstractMarker> savedMarkers = new Hashtable<AbstractMarker, AbstractMarker>();
   private NumberFormat positionFormat = NumberFormat.getInstance();

   private static final String PREFERRED_ID = "MarkerEditorTopComponent";

   private MarkerEditorTopComponent() {
      positionFormat.setMinimumFractionDigits(5);

      initComponents();
      setName(NbBundle.getMessage(MarkerEditorTopComponent.class, "CTL_MarkerEditorTopComponent"));
      setToolTipText(NbBundle.getMessage(MarkerEditorTopComponent.class, "HINT_MarkerEditorTopComponent"));
//        setIcon(Utilities.loadImage(ICON_PATH, true));
      ViewDB.getInstance().addObserver(this);
      OpenSimDB.getInstance().addObserver(this);
      setupComponent(null);
   }

   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      MarkerEditorScrollPane = new javax.swing.JScrollPane();
      MarkerEditorPanel = new javax.swing.JPanel();
      ModelNameLabel = new javax.swing.JLabel();
      BodySelectLabel = new javax.swing.JLabel();
      OffsetPanel = new javax.swing.JPanel();
      XLabel = new javax.swing.JLabel();
      XTextField = new javax.swing.JTextField();
      YLabel = new javax.swing.JLabel();
      YTextField = new javax.swing.JTextField();
      ZLabel = new javax.swing.JLabel();
      ZTextField = new javax.swing.JTextField();
      MarkerNameTextField = new javax.swing.JTextField();
      MarkerNameLabel = new javax.swing.JLabel();
      MarkerComboBox = new javax.swing.JComboBox();
      MarkerSelectLabel = new javax.swing.JLabel();
      BackupAllButton = new javax.swing.JButton();
      BackupButton = new javax.swing.JButton();
      RestoreAllButton = new javax.swing.JButton();
      RestoreButton = new javax.swing.JButton();
      BodyComboBox = new javax.swing.JComboBox();

      org.openide.awt.Mnemonics.setLocalizedText(ModelNameLabel, "Model:");

      org.openide.awt.Mnemonics.setLocalizedText(BodySelectLabel, "Body");

      OffsetPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Offset"));
      OffsetPanel.setName("offset");
      org.openide.awt.Mnemonics.setLocalizedText(XLabel, "X");

      XTextField.setText("1.2345");
      XTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            XTextFieldActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(YLabel, "Y");

      YTextField.setText("1.2345");
      YTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            YTextFieldActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(ZLabel, "Z");

      ZTextField.setText("1.2345");
      ZTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            ZTextFieldActionPerformed(evt);
         }
      });

      org.jdesktop.layout.GroupLayout OffsetPanelLayout = new org.jdesktop.layout.GroupLayout(OffsetPanel);
      OffsetPanel.setLayout(OffsetPanelLayout);
      OffsetPanelLayout.setHorizontalGroup(
         OffsetPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(OffsetPanelLayout.createSequentialGroup()
            .add(XLabel)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(XTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 80, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(13, 13, 13)
            .add(YLabel)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(YTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 80, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(14, 14, 14)
            .add(ZLabel)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(ZTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 80, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );
      OffsetPanelLayout.setVerticalGroup(
         OffsetPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(OffsetPanelLayout.createSequentialGroup()
            .add(OffsetPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(XLabel)
               .add(XTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(YLabel)
               .add(YTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(ZLabel)
               .add(ZTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );

      MarkerNameTextField.setText("<marker name>");
      MarkerNameTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            MarkerNameTextFieldActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(MarkerNameLabel, "Name");

      MarkerComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "<marker name>", "Item 2", "Item 3", "Item 4" }));
      MarkerComboBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            MarkerComboBoxActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(MarkerSelectLabel, "Marker");

      org.openide.awt.Mnemonics.setLocalizedText(BackupAllButton, "Backup all");
      BackupAllButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            BackupAllButtonActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(BackupButton, "Backup");
      BackupButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            BackupButtonActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(RestoreAllButton, "Restore all");
      RestoreAllButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            RestoreAllButtonActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(RestoreButton, "Restore");
      RestoreButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            RestoreButtonActionPerformed(evt);
         }
      });

      BodyComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "<body name>", "Item 2", "Item 3", "Item 4" }));
      BodyComboBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            BodyComboBoxActionPerformed(evt);
         }
      });

      org.jdesktop.layout.GroupLayout MarkerEditorPanelLayout = new org.jdesktop.layout.GroupLayout(MarkerEditorPanel);
      MarkerEditorPanel.setLayout(MarkerEditorPanelLayout);
      MarkerEditorPanelLayout.setHorizontalGroup(
         MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(MarkerEditorPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(ModelNameLabel)
               .add(OffsetPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(MarkerEditorPanelLayout.createSequentialGroup()
                  .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                     .add(BodySelectLabel)
                     .add(MarkerSelectLabel))
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                     .add(BodyComboBox, 0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                     .add(MarkerComboBox, 0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                  .add(25, 25, 25)
                  .add(MarkerNameLabel)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(MarkerNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 140, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
               .add(MarkerEditorPanelLayout.createSequentialGroup()
                  .add(RestoreButton)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(RestoreAllButton)
                  .add(51, 51, 51)
                  .add(BackupButton)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(BackupAllButton)))
            .addContainerGap(20, Short.MAX_VALUE))
      );
      MarkerEditorPanelLayout.setVerticalGroup(
         MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(MarkerEditorPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(ModelNameLabel)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(MarkerSelectLabel)
               .add(MarkerComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(MarkerNameLabel)
               .add(MarkerNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(BodySelectLabel)
               .add(BodyComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(23, 23, 23)
            .add(OffsetPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(20, 20, 20)
            .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(RestoreButton)
               .add(RestoreAllButton)
               .add(BackupButton)
               .add(BackupAllButton))
            .addContainerGap(20, Short.MAX_VALUE))
      );
      MarkerEditorScrollPane.setViewportView(MarkerEditorPanel);

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(MarkerEditorScrollPane)
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(MarkerEditorScrollPane)
      );
   }// </editor-fold>//GEN-END:initComponents

   private void RestoreAllButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RestoreAllButtonActionPerformed
      restoreAllMarkers();
   }//GEN-LAST:event_RestoreAllButtonActionPerformed

   private void RestoreButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RestoreButtonActionPerformed
      restoreMarker();
   }//GEN-LAST:event_RestoreButtonActionPerformed

   private void BackupAllButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BackupAllButtonActionPerformed
      backupMarkers();
   }//GEN-LAST:event_BackupAllButtonActionPerformed

   private void BackupButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BackupButtonActionPerformed
      backupMarker();
   }//GEN-LAST:event_BackupButtonActionPerformed

   private void MarkerNameTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MarkerNameTextFieldActionPerformed
      javax.swing.JTextField field = (javax.swing.JTextField)evt.getSource();
      if (currentMarker == null || currentMarker.getName().equals(MarkerNameTextField.getText()) == true)
         return;
      if (validName(MarkerNameTextField.getText()) == false)
         return;
      currentMarker.setName(MarkerNameTextField.getText());
      // Let the event handler update the marker editor, because marker names
      // could also be changed from outside the editor.
      NameChangedEvent evnt = new NameChangedEvent(currentMarker);
      OpenSimDB.getInstance().setChanged();
      OpenSimDB.getInstance().notifyObservers(evnt);
   }//GEN-LAST:event_MarkerNameTextFieldActionPerformed

   private void BodyComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BodyComboBoxActionPerformed
      javax.swing.JComboBox bodyComboBox = (javax.swing.JComboBox)evt.getSource();
      AbstractBody oldBody = currentMarker.getBody();
      BodySet bodies = currentModel.getDynamicsEngine().getBodySet();
      AbstractBody newBody = bodies.get(bodyComboBox.getSelectedIndex());
      if (AbstractBody.getCPtr(newBody) != AbstractBody.getCPtr(oldBody)) {
         currentMarker.setBody(newBody, true);
         updateOffsetFields();
         setPendingChanges(true, currentMarker, true);
         // tell the ViewDB to redraw the model
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(currentModel);
         vis.updateMarkerGeometry(currentMarker);
         ViewDB.getInstance().repaintAll();
      }
   }//GEN-LAST:event_BodyComboBoxActionPerformed

   private void OffsetComponentEntered(java.awt.event.ActionEvent evt, int component) {
      javax.swing.JTextField field = (javax.swing.JTextField)evt.getSource();
      double[] offset = new double[3];
      double newValue;
      currentMarker.getOffset(offset);
      try {
         newValue = positionFormat.parse(field.getText()).doubleValue();
      } catch (ParseException ex) {
         Toolkit.getDefaultToolkit().beep();
         field.setText(positionFormat.format(offset[component]));
         return;
      }
      // format the number and write it back into the text field
      field.setText(positionFormat.format(newValue));

      // update the model if the number has changed
      if (offset[component] != newValue) {
         offset[component] = newValue;
         currentMarker.setOffset(offset);
         setPendingChanges(true, currentMarker, true);
         // tell the ViewDB to redraw the model
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(currentModel);
         vis.updateMarkerGeometry(currentMarker);
         ViewDB.getInstance().repaintAll();
      }
   }

   private void ZTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ZTextFieldActionPerformed
      OffsetComponentEntered(evt, 2);
   }//GEN-LAST:event_ZTextFieldActionPerformed

   private void YTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_YTextFieldActionPerformed
      OffsetComponentEntered(evt, 1);
   }//GEN-LAST:event_YTextFieldActionPerformed

   private void XTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_XTextFieldActionPerformed
      OffsetComponentEntered(evt, 0);
   }//GEN-LAST:event_XTextFieldActionPerformed

   private void MarkerComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MarkerComboBoxActionPerformed
      if (currentModel == null)
         return;
      String nameOfNewMarker = MarkerComboBox.getSelectedItem().toString();
      AbstractMarker newMarker = currentModel.getDynamicsEngine().getMarkerSet().get(nameOfNewMarker);
      if (newMarker != null && AbstractMarker.getCPtr(newMarker) != AbstractMarker.getCPtr(currentMarker)) {
         currentMarker = newMarker;
         updateBackupRestoreButtons();
         setupComponent(currentMarker);
      }
   }//GEN-LAST:event_MarkerComboBoxActionPerformed
    
    
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JButton BackupAllButton;
   private javax.swing.JButton BackupButton;
   private javax.swing.JComboBox BodyComboBox;
   private javax.swing.JLabel BodySelectLabel;
   private javax.swing.JComboBox MarkerComboBox;
   private javax.swing.JPanel MarkerEditorPanel;
   private javax.swing.JScrollPane MarkerEditorScrollPane;
   private javax.swing.JLabel MarkerNameLabel;
   private javax.swing.JTextField MarkerNameTextField;
   private javax.swing.JLabel MarkerSelectLabel;
   private javax.swing.JLabel ModelNameLabel;
   private javax.swing.JPanel OffsetPanel;
   private javax.swing.JButton RestoreAllButton;
   private javax.swing.JButton RestoreButton;
   private javax.swing.JLabel XLabel;
   private javax.swing.JTextField XTextField;
   private javax.swing.JLabel YLabel;
   private javax.swing.JTextField YTextField;
   private javax.swing.JLabel ZLabel;
   private javax.swing.JTextField ZTextField;
   // End of variables declaration//GEN-END:variables

   public void setupComponent(AbstractMarker newMarker) {
      SingleModelGuiElements guiElem = null;
      MarkerSet markerSet = null;

      if (currentModel != null) {
         markerSet = currentModel.getDynamicsEngine().getMarkerSet();
         if (newMarker == null && markerSet.getSize() > 0)
            newMarker = markerSet.get(0);
      }

      // Set the current marker to the newly selected one (should only be null
      // if the model is null or if the model has no markers).
      currentMarker = newMarker;

      if (currentModel == null) {
         ModelNameLabel.setText("Model: No models");
         MarkerNameLabel.setEnabled(false);
         MarkerNameTextField.setText("");
         MarkerNameTextField.setEnabled(false);
         MarkerSelectLabel.setEnabled(false);
         MarkerComboBox.setEnabled(false);
         BodySelectLabel.setEnabled(false);
         BodyComboBox.setEnabled(false);
         XLabel.setEnabled(false);
         XTextField.setEnabled(false);
         YLabel.setEnabled(false);
         YTextField.setEnabled(false);
         ZLabel.setEnabled(false);
         ZTextField.setEnabled(false);
      } else {
         guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
         ModelNameLabel.setText("Model: " + currentModel.getName());
         if (markerSet.getSize() > 0) {
            MarkerComboBox.setEnabled(true);
            MarkerComboBox.setModel(new javax.swing.DefaultComboBoxModel(guiElem.getMarkerNames()));
         } else {
            MarkerComboBox.setEnabled(false);
         }
         BodyComboBox.setModel(new javax.swing.DefaultComboBoxModel(guiElem.getBodyNames()));
      }
      
      if (currentMarker == null) {
         MarkerNameLabel.setEnabled(false);
         MarkerNameTextField.setText("");
         MarkerNameTextField.setEnabled(false);
         MarkerSelectLabel.setEnabled(false);
         MarkerComboBox.setEnabled(false);
         BodySelectLabel.setEnabled(false);
         BodyComboBox.setEnabled(false);
         XLabel.setEnabled(false);
         XTextField.setEnabled(false);
         YLabel.setEnabled(false);
         YTextField.setEnabled(false);
         ZLabel.setEnabled(false);
         ZTextField.setEnabled(false);
      } else {
         MarkerNameLabel.setEnabled(true);
         MarkerNameTextField.setEnabled(true);
         MarkerSelectLabel.setEnabled(true);
         MarkerComboBox.setEnabled(true);
         MarkerComboBox.setSelectedIndex(findElement(guiElem.getMarkerNames(), currentMarker.getName()));
         BodySelectLabel.setEnabled(true);
         BodyComboBox.setEnabled(true);
         XLabel.setEnabled(true);
         XTextField.setEnabled(true);
         YLabel.setEnabled(true);
         YTextField.setEnabled(true);
         ZLabel.setEnabled(true);
         ZTextField.setEnabled(true);
      }

      updateBackupRestoreButtons();

      if (currentModel != null && currentMarker != null)
      {
         MarkerNameTextField.setText(currentMarker.getName());
         BodyComboBox.setSelectedIndex(findElement(guiElem.getBodyNames(), currentMarker.getBody().getName()));
         updateOffsetFields();
      }

      Dimension d = new Dimension(420, 240);
      MarkerEditorPanel.setPreferredSize(d);
      
      this.revalidate();
      this.repaint();
   }

   private void updateOffsetFields() {
      double[] offset = new double[3];
      currentMarker.getOffset(offset);
      XTextField.setText(positionFormat.format(offset[0]));
      YTextField.setText(positionFormat.format(offset[1]));
      ZTextField.setText(positionFormat.format(offset[2]));
   }

   private void updateBackupRestoreButtons() {
      if (currentMarker != null) {
         boolean state = pendingChanges.get(currentMarker);
         if (RestoreButton.isEnabled() != state)
            RestoreButton.setEnabled(state);
         if (BackupButton.isEnabled() != state)
            BackupButton.setEnabled(state);
      } else {
         BackupButton.setEnabled(false);
         RestoreButton.setEnabled(false);
         BackupAllButton.setEnabled(false);
         RestoreAllButton.setEnabled(false);
         return;
      }

      boolean anyPendingChanges = false;
      Enumeration<AbstractMarker> markers = pendingChanges.keys();
      while(markers.hasMoreElements()) {
         AbstractMarker next = markers.nextElement();
         if (pendingChanges.get(next) == true) {
            anyPendingChanges = true;
            break;
         }
      }
      if (RestoreAllButton.isEnabled() != anyPendingChanges)
         RestoreAllButton.setEnabled(anyPendingChanges);
      if (BackupAllButton.isEnabled() != anyPendingChanges)
         BackupAllButton.setEnabled(anyPendingChanges);
   }

   private void setPendingChanges(boolean state, AbstractMarker marker, boolean update) {
      pendingChanges.put(marker, state);

      if (update)
         updateBackupRestoreButtons();

      // Mark the model as dirty as well.
      if (state == true && currentModel != null) {
         SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
         guiElem.setUnsavedChangesFlag(true);
      }
   }
   
   private void setAllPendingChanges(boolean state) {
      boolean needsRepainting = false;
      Enumeration<AbstractMarker> markers = pendingChanges.keys();
      while(markers.hasMoreElements()) {
         AbstractMarker next = markers.nextElement();
         pendingChanges.put(next, state);
      }

      updateBackupRestoreButtons();

      // Mark the model as dirty as well.
      if (state == true && currentModel != null) {
         SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
         guiElem.setUnsavedChangesFlag(true);
      }
   }

   private void backupMarker() {
      setPendingChanges(false, currentMarker, true);
      AbstractMarker savedMarker = AbstractMarker.safeDownCast(currentMarker.copy());
      savedMarkers.put(currentMarker, savedMarker);
   }

   /* This is called when the user clicks on the "Backup All" button.
    * It backs up only the markers that have been modified since they
    * were last backed up.
    */
   private void backupMarkers() {
      // Should never be null, but just in case...
       if (currentModel == null)
          return;

      // Loop through the marker set, backing up only the ones that have been modified.
      MarkerSet markers = currentModel.getDynamicsEngine().getMarkerSet();
      for (int i=0; i<markers.getSize(); i++) {
         AbstractMarker marker = markers.get(i);
         if (pendingChanges.get(marker)) {
             AbstractMarker savedMarker = savedMarkers.get(marker);
             // Copy the elements of the saved marker into the [regular] marker.
             savedMarker.copy(marker);
         }
      }

      setAllPendingChanges(false);
   }

   /* This is called when the current model is closed or switched. It deletes
    * all backed up markers, and then if there is a current model, it makes a
    * new set of backups for that model.
    */
   private void backupAllMarkers() {
      // Delete any existing marker backups, and clear the savedMarkers hash table.
      Iterator<AbstractMarker> markerIter = savedMarkers.values().iterator();
      while(markerIter.hasNext())
         AbstractMarker.deleteMarker(markerIter.next());
      savedMarkers.clear();

      pendingChanges.clear();

      // Make a backup of each actuator in the current model and add it to the savedMarkers hash table.
      if (currentModel != null) {
         MarkerSet markers = currentModel.getDynamicsEngine().getMarkerSet();
         for (int i=0; i<markers.getSize(); i++) {
            AbstractMarker savedMarker = AbstractMarker.safeDownCast(markers.get(i).copy());
            savedMarkers.put(markers.get(i), savedMarker);
            pendingChanges.put(markers.get(i), false);
         }
      }
   }

   private void restoreMarker() {
      // Should never be null, but just in case...
      if (currentMarker == null || currentModel == null)
         return;
      AbstractMarker savedMarker = savedMarkers.get(currentMarker);
      if (savedMarker == null)
         return;

      SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(currentModel);

      // If the name has changed, fire an event.
      if (currentMarker.getName().equals(savedMarker.getName()) == false) {
         NameChangedEvent ev = new NameChangedEvent(currentMarker);
         OpenSimDB.getInstance().setChanged();
         OpenSimDB.getInstance().notifyObservers(ev);
      }

      // Copy the elements of the saved marker into the current marker.
      currentMarker.copy(savedMarker);
      vis.updateMarkerGeometry(currentMarker);

      setPendingChanges(false, currentMarker, false);
      setupComponent(currentMarker);
      ViewDB.getInstance().repaintAll();
   }

   private void restoreAllMarkers() {
      // Should never be null, but just in case...
       if (currentModel == null)
          return;

      boolean updateEditor = false;
      SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(currentModel);

      // Make a note if the current actuator needs to be restored, so you can call
      // setupComponent() later.
      if (pendingChanges.get(currentMarker))
          updateEditor = true;

      // Loop through the marker set, restoring only the ones that have been modified.
      MarkerSet markers = currentModel.getDynamicsEngine().getMarkerSet();
      for (int i=0; i<markers.getSize(); i++) {
         AbstractMarker marker = markers.get(i);
         if (pendingChanges.get(marker)) {
            AbstractMarker savedMarker = savedMarkers.get(marker);
            // If the name has changed, fire an event.
            if (marker.getName().equals(savedMarker.getName()) == false) {
               NameChangedEvent ev = new NameChangedEvent(marker);
               OpenSimDB.getInstance().setChanged();
               OpenSimDB.getInstance().notifyObservers(ev);
            }

            // Copy the elements of the saved marker into the [regular] marker.
            marker.copy(savedMarker);
            vis.updateMarkerGeometry(marker);
         }
      }

      setAllPendingChanges(false);
      if (updateEditor)
         setupComponent(currentMarker);
      ViewDB.getInstance().repaintAll();
   }

   private boolean validName(String markerName)
   {
      if (currentModel != null && currentMarker != null) {
         if (markerName.length() < 1) {
            MarkerNameTextField.setText(currentMarker.getName());
            return false;
         }
         AbstractMarker existingMarker = currentModel.getDynamicsEngine().getMarkerSet().get(markerName);
         if (existingMarker != null && AbstractMarker.getCPtr(existingMarker) != AbstractMarker.getCPtr(currentMarker)) {
            MarkerNameTextField.setText(currentMarker.getName());
            Object[] options = {"OK"};
            String message = "The name \"" + markerName + "\" is already being used. Please choose a different marker name";
            int answer = JOptionPane.showOptionDialog(this,
                         message,
                         "Marker Editor",
                         JOptionPane.OK_OPTION,
                         JOptionPane.WARNING_MESSAGE,
                         null,
                         options,
                         options[0]);
            return false;
         } else {
            return true;
         }
      }

      return false;
   }

   // Called from update(), this function handles name changes to any marker in
   // the current model. It assumes that the marker's name has already been
   // changed, so only the marker editor needs to be updated.
   private void updateMarkerName(AbstractMarker marker) {
      SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
      String [] markerNames = guiElem.getMarkerNames();
      MarkerComboBox.setModel(new javax.swing.DefaultComboBoxModel(markerNames));
      if (currentMarker != null) {
         int foo = findElement(markerNames, currentMarker.getName());
         MarkerComboBox.setSelectedIndex(findElement(markerNames, currentMarker.getName()));
         if (currentMarker.equals(marker))
            MarkerNameTextField.setText(currentMarker.getName());
      }
      setPendingChanges(true, marker, true);
   }

   public void open() {
      AbstractMarker newMarker = null;
      Node[] selected = ExplorerTopComponent.findInstance().getExplorerManager().getSelectedNodes();
      if (selected.length > 0 && selected[0] instanceof OneMarkerNode) {
         OneMarkerNode markerNode = (OneMarkerNode) selected[0];
         newMarker = AbstractMarker.safeDownCast(markerNode.getOpenSimObject());
         if (newMarker != null && AbstractMarker.getCPtr(newMarker) != AbstractMarker.getCPtr(currentMarker)) {
            Model newModel = newMarker.getBody().getDynamicsEngine().getModel();
            if (Model.getCPtr(newModel) != Model.getCPtr(currentModel)) {
               Object[] options = {"OK"};
               int answer = JOptionPane.showOptionDialog(this,
                       "You can only edit markers that are in the current model.",
                       "Marker Editor",
                       JOptionPane.DEFAULT_OPTION,
                       JOptionPane.WARNING_MESSAGE,
                       null,
                       options,
                       options[0]);
            } else {
               currentMarker = newMarker;
               setPendingChanges(false, currentMarker, false);
               setupComponent(currentMarker);
            }
         }
      } else {
         setAllPendingChanges(false);
         setupComponent(null);
      }
      super.open();
      this.requestActive();
   }

   public void update(Observable o, Object arg) {
      if (o instanceof ViewDB) {
         if (arg instanceof ObjectSelectedEvent) {
            ObjectSelectedEvent ev = (ObjectSelectedEvent)arg;
            //updateAttachmentSelections(ev.getSelectedObject(), ev.getState());
         } else if (arg instanceof ClearSelectedObjectsEvent) {
            if (currentMarker != null) {
            }
         } else if (arg instanceof DragObjectsEvent) {
            //dragMusclePoints((DragObjectsEvent)arg);
         }
      } else if (o instanceof OpenSimDB) {
         // if current model is being switched due to open/close or change current then
         // update tool window
         if (arg instanceof ModelEvent) {
            final ModelEvent evt = (ModelEvent)arg;
            if (evt.getOperation() == ModelEvent.Operation.Close && OpenSimDB.getInstance().getCurrentModel() == null) {
               currentModel = null;
               currentMarker = null;
               backupAllMarkers();
               setAllPendingChanges(false);
               setupComponent(null);
            }
            // Do we need to handle close separately or should we be called with SetCurrent of null model?
         } else if (arg instanceof ObjectSetCurrentEvent) {
            ObjectSetCurrentEvent evt = (ObjectSetCurrentEvent)arg;
            Vector<OpenSimObject> objs = evt.getObjects();
            // If any of the event objects is a model not equal to the current model, this means there is a new
            // current model. So clear out the panel.
            for (int i=0; i<objs.size(); i++) {
               if (objs.get(i) instanceof Model) {
                  if (currentModel == null || !currentModel.equals(objs.get(i))) {
                     currentModel = (Model)objs.get(i);
                     currentMarker = null;
                     backupAllMarkers();
                     setAllPendingChanges(false);
                     setupComponent(null);
                     break;
                  }
               }
            }
         } else if (arg instanceof ObjectsChangedEvent) {
         } else if (arg instanceof NameChangedEvent) {
            NameChangedEvent ev = (NameChangedEvent)arg;
            if (ev.getObject() instanceof Model) {
               if (currentModel != null && currentModel.equals(ev.getObject())) {
                  ModelNameLabel.setText("Model: " + currentModel.getName());
               }
            } else if (ev.getObject() instanceof AbstractMarker) {
               AbstractMarker marker = (AbstractMarker)ev.getObject();
               if (currentModel != null && currentModel.equals(marker.getBody().getDynamicsEngine().getModel()))
                  updateMarkerName(marker);
            }
         }
      }
   }

   private int findElement(String[] nameList, String name) {
      int i;
      for (i = 0; i < nameList.length; i++)
         if (nameList[i].equals(name))
            return i;
      return -1;
   }

    /**
     * Gets default instance. Do not use directly: reserved for *.settings files only,
     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.
     * To obtain the singleton instance, use {@link findInstance}.
     */
    public static synchronized MarkerEditorTopComponent getDefault() {
       if (instance == null) {
          instance = new MarkerEditorTopComponent();
       }
       return instance;
    }
    
    /**
     * Obtain the MarkerEditorTopComponent instance. Never call {@link #getDefault} directly!
     */
    public static synchronized MarkerEditorTopComponent findInstance() {
       TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
       if (win == null) {
          ErrorManager.getDefault().log(ErrorManager.WARNING, "Cannot find MarkerEditor component. It will not be located properly in the window system.");
          return getDefault();
       }
       if (win instanceof MarkerEditorTopComponent) {
          return (MarkerEditorTopComponent)win;
       }
       ErrorManager.getDefault().log(ErrorManager.WARNING, "There seem to be multiple components with the '" + PREFERRED_ID + "' ID. That is a potential source of errors and unexpected behavior.");
       return getDefault();
    }
    
    public int getPersistenceType() {
       return TopComponent.PERSISTENCE_ALWAYS;
    }
    
    public void componentOpened() {
       // TODO add custom code on component opening
    }
    
    public void componentClosed() {
       // TODO add custom code on component closing
    }
    
    /** replaces this in object stream */
    public Object writeReplace() {
       return new ResolvableHelper();
    }
    
    protected String preferredID() {
       return PREFERRED_ID;
    }
    
    final static class ResolvableHelper implements Serializable {
       private static final long serialVersionUID = 1L;
       public Object readResolve() {
          return MarkerEditorTopComponent.getDefault();
       }
    }
}

