package org.opensim.view.markerEditor;

import java.awt.Dimension;
import java.awt.Toolkit;
import java.io.Serializable;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Observable;
import java.util.Observer;
import java.util.Vector;
import javax.swing.JOptionPane;
import org.openide.ErrorManager;
import org.openide.nodes.Node;
import org.openide.util.NbBundle;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;
import org.opensim.modeling.AbstractBody;
import org.opensim.modeling.AbstractDynamicsEngine;
import org.opensim.modeling.AbstractMarker;
import org.opensim.modeling.BodySet;
import org.opensim.modeling.Marker;
import org.opensim.modeling.MarkerSet;
import org.opensim.modeling.Model;
import org.opensim.modeling.OpenSimObject;
import org.opensim.view.ClearSelectedObjectsEvent;
import org.opensim.view.DragObjectsEvent;
import org.opensim.view.ExplorerTopComponent;
import org.opensim.view.ModelEvent;
import org.opensim.view.ObjectSelectedEvent;
import org.opensim.view.ObjectSetCurrentEvent;
import org.opensim.view.ObjectsAddedEvent;
import org.opensim.view.ObjectsChangedEvent;
import org.opensim.view.ObjectsDeletedEvent;
import org.opensim.view.ObjectsRenamedEvent;
import org.opensim.view.SelectedObject;
import org.opensim.view.SingleModelGuiElements;
import org.opensim.view.SingleModelVisuals;
import org.opensim.view.nodes.OneMarkerNode;
import org.opensim.view.pub.OpenSimDB;
import org.opensim.view.pub.ViewDB;

/**
 * Top component which displays something.
 */
final public class MarkerEditorTopComponent extends TopComponent implements Observer {

   private static MarkerEditorTopComponent instance;
   /** path to the icon used by the component and its open action */
//    static final String ICON_PATH = "SET/PATH/TO/ICON/HERE";

   private enum MarkerState {UNMODIFIED, MODIFIED, ADDED, DELETED};
   private Model currentModel = null;
   private AbstractMarker currentMarker = null; // the marker that is currently shown in the Marker Editor window
   private Hashtable<AbstractMarker, MarkerState> pendingChanges = new Hashtable<AbstractMarker, MarkerState>();
   private Hashtable<AbstractMarker, AbstractMarker> savedMarkers = new Hashtable<AbstractMarker, AbstractMarker>();
   private NumberFormat positionFormat = NumberFormat.getInstance();

   private static final String PREFERRED_ID = "MarkerEditorTopComponent";

   private MarkerEditorTopComponent() {
      positionFormat.setMinimumFractionDigits(5);

      initComponents();
      setName(NbBundle.getMessage(MarkerEditorTopComponent.class, "CTL_MarkerEditorTopComponent"));
      setToolTipText(NbBundle.getMessage(MarkerEditorTopComponent.class, "HINT_MarkerEditorTopComponent"));
//        setIcon(Utilities.loadImage(ICON_PATH, true));
      ViewDB.getInstance().addObserver(this);
      OpenSimDB.getInstance().addObserver(this);
      setupComponent(null);
   }

   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      MarkerEditorScrollPane = new javax.swing.JScrollPane();
      MarkerEditorPanel = new javax.swing.JPanel();
      ModelNameLabel = new javax.swing.JLabel();
      BodySelectLabel = new javax.swing.JLabel();
      OffsetPanel = new javax.swing.JPanel();
      XLabel = new javax.swing.JLabel();
      XTextField = new javax.swing.JTextField();
      YLabel = new javax.swing.JLabel();
      YTextField = new javax.swing.JTextField();
      ZLabel = new javax.swing.JLabel();
      ZTextField = new javax.swing.JTextField();
      MarkerNameTextField = new javax.swing.JTextField();
      MarkerNameLabel = new javax.swing.JLabel();
      MarkerComboBox = new javax.swing.JComboBox();
      MarkerSelectLabel = new javax.swing.JLabel();
      BackupAllButton = new javax.swing.JButton();
      BackupButton = new javax.swing.JButton();
      RestoreAllButton = new javax.swing.JButton();
      RestoreButton = new javax.swing.JButton();
      BodyComboBox = new javax.swing.JComboBox();
      AddMarkerButton = new javax.swing.JButton();
      DeleteMarkerButton = new javax.swing.JButton();

      org.openide.awt.Mnemonics.setLocalizedText(ModelNameLabel, "Model:");

      org.openide.awt.Mnemonics.setLocalizedText(BodySelectLabel, "Body");

      OffsetPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Offset"));
      OffsetPanel.setName("offset");
      org.openide.awt.Mnemonics.setLocalizedText(XLabel, "X");

      XTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            XTextFieldActionPerformed(evt);
         }
      });
      XTextField.addFocusListener(new java.awt.event.FocusAdapter() {
         public void focusLost(java.awt.event.FocusEvent evt) {
            XTextFieldFocusLost(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(YLabel, "Y");

      YTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            YTextFieldActionPerformed(evt);
         }
      });
      YTextField.addFocusListener(new java.awt.event.FocusAdapter() {
         public void focusLost(java.awt.event.FocusEvent evt) {
            YTextFieldFocusLost(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(ZLabel, "Z");

      ZTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            ZTextFieldActionPerformed(evt);
         }
      });
      ZTextField.addFocusListener(new java.awt.event.FocusAdapter() {
         public void focusLost(java.awt.event.FocusEvent evt) {
            ZTextFieldFocusLost(evt);
         }
      });

      org.jdesktop.layout.GroupLayout OffsetPanelLayout = new org.jdesktop.layout.GroupLayout(OffsetPanel);
      OffsetPanel.setLayout(OffsetPanelLayout);
      OffsetPanelLayout.setHorizontalGroup(
         OffsetPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(OffsetPanelLayout.createSequentialGroup()
            .add(XLabel)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(XTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 80, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(13, 13, 13)
            .add(YLabel)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(YTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 80, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .add(14, 14, 14)
            .add(ZLabel)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(ZTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 80, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );
      OffsetPanelLayout.setVerticalGroup(
         OffsetPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(OffsetPanelLayout.createSequentialGroup()
            .add(OffsetPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(XLabel)
               .add(XTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(YLabel)
               .add(YTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(ZLabel)
               .add(ZTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
      );

      MarkerNameTextField.setText("<marker name>");
      MarkerNameTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            MarkerNameTextFieldActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(MarkerNameLabel, "Name");

      MarkerComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "<marker name>", "Item 2", "Item 3", "Item 4" }));
      MarkerComboBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            MarkerComboBoxActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(MarkerSelectLabel, "Marker");

      org.openide.awt.Mnemonics.setLocalizedText(BackupAllButton, "Backup all");
      BackupAllButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            BackupAllButtonActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(BackupButton, "Backup current");
      BackupButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            BackupButtonActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(RestoreAllButton, "Restore all");
      RestoreAllButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            RestoreAllButtonActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(RestoreButton, "Restore current");
      RestoreButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            RestoreButtonActionPerformed(evt);
         }
      });

      BodyComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "<body name>", "Item 2", "Item 3", "Item 4" }));
      BodyComboBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            BodyComboBoxActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(AddMarkerButton, "Add New");
      AddMarkerButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            AddMarkerButtonActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(DeleteMarkerButton, "Delete Current");
      DeleteMarkerButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            DeleteMarkerButtonActionPerformed(evt);
         }
      });

      org.jdesktop.layout.GroupLayout MarkerEditorPanelLayout = new org.jdesktop.layout.GroupLayout(MarkerEditorPanel);
      MarkerEditorPanel.setLayout(MarkerEditorPanelLayout);
      MarkerEditorPanelLayout.setHorizontalGroup(
         MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(MarkerEditorPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(ModelNameLabel)
               .add(MarkerEditorPanelLayout.createSequentialGroup()
                  .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                     .add(BodySelectLabel)
                     .add(MarkerSelectLabel))
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                     .add(BodyComboBox, 0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                     .add(MarkerComboBox, 0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                  .add(25, 25, 25)
                  .add(MarkerNameLabel)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(MarkerNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 140, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
               .add(OffsetPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(MarkerEditorPanelLayout.createSequentialGroup()
                  .add(RestoreButton)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(RestoreAllButton)
                  .add(51, 51, 51)
                  .add(BackupButton)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(BackupAllButton))
               .add(MarkerEditorPanelLayout.createSequentialGroup()
                  .add(AddMarkerButton)
                  .add(44, 44, 44)
                  .add(DeleteMarkerButton)))
            .addContainerGap(94, Short.MAX_VALUE))
      );
      MarkerEditorPanelLayout.setVerticalGroup(
         MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(MarkerEditorPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(ModelNameLabel)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(MarkerSelectLabel)
               .add(MarkerComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(MarkerNameLabel)
               .add(MarkerNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(BodySelectLabel)
               .add(BodyComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(12, 12, 12)
            .add(OffsetPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(AddMarkerButton)
               .add(DeleteMarkerButton))
            .add(12, 12, 12)
            .add(MarkerEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(RestoreButton)
               .add(RestoreAllButton)
               .add(BackupButton)
               .add(BackupAllButton))
            .addContainerGap(20, Short.MAX_VALUE))
      );
      MarkerEditorScrollPane.setViewportView(MarkerEditorPanel);

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(MarkerEditorScrollPane)
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(layout.createSequentialGroup()
            .add(MarkerEditorScrollPane)
            .addContainerGap())
      );
   }// </editor-fold>//GEN-END:initComponents

   private void ZTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_ZTextFieldFocusLost
      if (!evt.isTemporary() && currentMarker != null)
         OffsetComponentEntered((javax.swing.JTextField)evt.getSource(), 2);
   }//GEN-LAST:event_ZTextFieldFocusLost

   private void YTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_YTextFieldFocusLost
      if (!evt.isTemporary() && currentMarker != null)
         OffsetComponentEntered((javax.swing.JTextField)evt.getSource(), 1);
   }//GEN-LAST:event_YTextFieldFocusLost

   private void XTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_XTextFieldFocusLost
      if (!evt.isTemporary() && currentMarker != null)
         OffsetComponentEntered((javax.swing.JTextField)evt.getSource(), 0);
   }//GEN-LAST:event_XTextFieldFocusLost

   private void DeleteMarkerButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_DeleteMarkerButtonActionPerformed
      deleteMarker(currentMarker, true);
   }//GEN-LAST:event_DeleteMarkerButtonActionPerformed

   private void AddMarkerButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AddMarkerButtonActionPerformed
      addMarker();
   }//GEN-LAST:event_AddMarkerButtonActionPerformed

   private void RestoreAllButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RestoreAllButtonActionPerformed
      restoreAllMarkers();
   }//GEN-LAST:event_RestoreAllButtonActionPerformed

   private void RestoreButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RestoreButtonActionPerformed
      restoreMarker();
   }//GEN-LAST:event_RestoreButtonActionPerformed

   private void BackupAllButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BackupAllButtonActionPerformed
      backupAllMarkers();
   }//GEN-LAST:event_BackupAllButtonActionPerformed

   private void BackupButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BackupButtonActionPerformed
      backupMarker();
   }//GEN-LAST:event_BackupButtonActionPerformed

   private void MarkerNameTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MarkerNameTextFieldActionPerformed
      javax.swing.JTextField field = (javax.swing.JTextField)evt.getSource();
      if (currentMarker == null || currentMarker.getName().equals(MarkerNameTextField.getText()) == true)
         return;
      if (validName(MarkerNameTextField.getText()) == false)
         return;
      currentMarker.setName(MarkerNameTextField.getText());
      // Update the marker list in the ViewDB and then generate an event
      // so other tools can update accordingly.
      ViewDB.getInstance().getModelGuiElements(currentModel).updateMarkerNames();
      Vector<OpenSimObject> objs = new Vector<OpenSimObject>(1);
      objs.add(currentMarker);
      ObjectsRenamedEvent evnt = new ObjectsRenamedEvent(this, currentModel, objs);
      OpenSimDB.getInstance().setChanged();
      OpenSimDB.getInstance().notifyObservers(evnt);
   }//GEN-LAST:event_MarkerNameTextFieldActionPerformed

   private void BodyComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BodyComboBoxActionPerformed
      javax.swing.JComboBox bodyComboBox = (javax.swing.JComboBox)evt.getSource();
      AbstractBody oldBody = currentMarker.getBody();
      BodySet bodies = currentModel.getDynamicsEngine().getBodySet();
      AbstractBody newBody = bodies.get(bodyComboBox.getSelectedIndex());
      if (AbstractBody.getCPtr(newBody) != AbstractBody.getCPtr(oldBody)) {
         currentMarker.setBody(newBody, true);
         updateOffsetFields();
         setPendingChanges(MarkerState.MODIFIED, currentMarker, true);
         // tell the ViewDB to redraw the model
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(currentModel);
         vis.updateMarkerGeometry(currentMarker);
         ViewDB.getInstance().repaintAll();
      }
   }//GEN-LAST:event_BodyComboBoxActionPerformed

   private void OffsetComponentEntered(javax.swing.JTextField field, int component) {
      double[] offset = new double[3];
      double newValue;
      currentMarker.getOffset(offset);
      try {
         newValue = positionFormat.parse(field.getText()).doubleValue();
      } catch (ParseException ex) {
         Toolkit.getDefaultToolkit().beep();
         field.setText(positionFormat.format(offset[component]));
         return;
      }
      // format the number and write it back into the text field
      field.setText(positionFormat.format(newValue));

      // update the model if the number has changed
      if (offset[component] != newValue) {
         offset[component] = newValue;
         currentMarker.setOffset(offset);
         setPendingChanges(MarkerState.MODIFIED, currentMarker, true);
         // tell the ViewDB to redraw the model
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(currentModel);
         vis.updateMarkerGeometry(currentMarker);
         ViewDB.getInstance().repaintAll();
      }
   }

   private void ZTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ZTextFieldActionPerformed
      if (currentMarker != null)
         OffsetComponentEntered((javax.swing.JTextField)evt.getSource(), 2);
   }//GEN-LAST:event_ZTextFieldActionPerformed

   private void YTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_YTextFieldActionPerformed
      if (currentMarker != null)
         OffsetComponentEntered((javax.swing.JTextField)evt.getSource(), 1);
   }//GEN-LAST:event_YTextFieldActionPerformed

   private void XTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_XTextFieldActionPerformed
      if (currentMarker != null)
         OffsetComponentEntered((javax.swing.JTextField)evt.getSource(), 0);
   }//GEN-LAST:event_XTextFieldActionPerformed

   private void MarkerComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MarkerComboBoxActionPerformed
      if (currentModel == null)
         return;
      String nameOfNewMarker = MarkerComboBox.getSelectedItem().toString();
      AbstractMarker newMarker = currentModel.getDynamicsEngine().getMarkerSet().get(nameOfNewMarker);
      if (newMarker != null && AbstractMarker.getCPtr(newMarker) != AbstractMarker.getCPtr(currentMarker)) {
         currentMarker = newMarker;
         updateBackupRestoreButtons();
         setupComponent(currentMarker);
      }
   }//GEN-LAST:event_MarkerComboBoxActionPerformed
    
    
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JButton AddMarkerButton;
   private javax.swing.JButton BackupAllButton;
   private javax.swing.JButton BackupButton;
   private javax.swing.JComboBox BodyComboBox;
   private javax.swing.JLabel BodySelectLabel;
   private javax.swing.JButton DeleteMarkerButton;
   private javax.swing.JComboBox MarkerComboBox;
   private javax.swing.JPanel MarkerEditorPanel;
   private javax.swing.JScrollPane MarkerEditorScrollPane;
   private javax.swing.JLabel MarkerNameLabel;
   private javax.swing.JTextField MarkerNameTextField;
   private javax.swing.JLabel MarkerSelectLabel;
   private javax.swing.JLabel ModelNameLabel;
   private javax.swing.JPanel OffsetPanel;
   private javax.swing.JButton RestoreAllButton;
   private javax.swing.JButton RestoreButton;
   private javax.swing.JLabel XLabel;
   private javax.swing.JTextField XTextField;
   private javax.swing.JLabel YLabel;
   private javax.swing.JTextField YTextField;
   private javax.swing.JLabel ZLabel;
   private javax.swing.JTextField ZTextField;
   // End of variables declaration//GEN-END:variables

   public void setupComponent(AbstractMarker newMarker) {
      SingleModelGuiElements guiElem = null;
      MarkerSet markerSet = null;

      if (currentModel != null) {
         markerSet = currentModel.getDynamicsEngine().getMarkerSet();
         if (newMarker == null && markerSet.getSize() > 0)
            newMarker = markerSet.get(0);
      }

      // Set the current marker to the newly selected one (should only be null
      // if the model is null or if the model has no markers).
      currentMarker = newMarker;

      if (currentModel == null) {
         ModelNameLabel.setText("Model: No models");
         MarkerNameLabel.setEnabled(false);
         MarkerNameTextField.setText("");
         MarkerNameTextField.setEnabled(false);
         MarkerSelectLabel.setEnabled(false);
         MarkerComboBox.setEnabled(false);
         BodySelectLabel.setEnabled(false);
         BodyComboBox.setEnabled(false);
         AddMarkerButton.setEnabled(false);
         DeleteMarkerButton.setEnabled(false);
         XLabel.setEnabled(false);
         XTextField.setEnabled(false);
         YLabel.setEnabled(false);
         YTextField.setEnabled(false);
         ZLabel.setEnabled(false);
         ZTextField.setEnabled(false);
      } else {
         guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
         ModelNameLabel.setText("Model: " + currentModel.getName());
         if (markerSet.getSize() > 0) {
            MarkerComboBox.setEnabled(true);
            MarkerComboBox.setModel(new javax.swing.DefaultComboBoxModel(guiElem.getMarkerNames()));
         } else {
            MarkerComboBox.setEnabled(false);
         }
         BodyComboBox.setModel(new javax.swing.DefaultComboBoxModel(guiElem.getBodyNames()));
         AddMarkerButton.setEnabled(true);
      }
      
      if (currentMarker == null) {
         MarkerNameLabel.setEnabled(false);
         MarkerNameTextField.setText("");
         MarkerNameTextField.setEnabled(false);
         MarkerSelectLabel.setEnabled(false);
         MarkerComboBox.setEnabled(false);
         BodySelectLabel.setEnabled(false);
         BodyComboBox.setEnabled(false);
         DeleteMarkerButton.setEnabled(false);
         XLabel.setEnabled(false);
         XTextField.setEnabled(false);
         YLabel.setEnabled(false);
         YTextField.setEnabled(false);
         ZLabel.setEnabled(false);
         ZTextField.setEnabled(false);
      } else {
         MarkerNameLabel.setEnabled(true);
         MarkerNameTextField.setEnabled(true);
         MarkerSelectLabel.setEnabled(true);
         MarkerComboBox.setEnabled(true);
         MarkerComboBox.setSelectedIndex(findElement(guiElem.getMarkerNames(), currentMarker.getName()));
         BodySelectLabel.setEnabled(true);
         BodyComboBox.setEnabled(true);
         DeleteMarkerButton.setEnabled(true);
         XLabel.setEnabled(true);
         XTextField.setEnabled(true);
         YLabel.setEnabled(true);
         YTextField.setEnabled(true);
         ZLabel.setEnabled(true);
         ZTextField.setEnabled(true);
      }

      updateBackupRestoreButtons();

      if (currentModel != null && currentMarker != null)
      {
         MarkerNameTextField.setText(currentMarker.getName());
         BodyComboBox.setSelectedIndex(findElement(guiElem.getBodyNames(), currentMarker.getBody().getName()));
         updateOffsetFields();
      }

      Dimension d = new Dimension(505, 260);
      MarkerEditorPanel.setPreferredSize(d);
      
      this.revalidate();
      this.repaint();
   }

   private void updateOffsetFields() {
      double[] offset = new double[3];
      currentMarker.getOffset(offset);
      XTextField.setText(positionFormat.format(offset[0]));
      YTextField.setText(positionFormat.format(offset[1]));
      ZTextField.setText(positionFormat.format(offset[2]));
   }

   private void updateBackupRestoreButtons() {
      if (currentMarker != null) {
         MarkerState state = pendingChanges.get(currentMarker);
         if (RestoreButton.isEnabled() && state == MarkerState.UNMODIFIED)
            RestoreButton.setEnabled(false);
         else if (!RestoreButton.isEnabled() &&
                  (state == MarkerState.MODIFIED || state == MarkerState.DELETED || state == MarkerState.ADDED))
            RestoreButton.setEnabled(true);
         if (BackupButton.isEnabled() && state == MarkerState.UNMODIFIED)
            BackupButton.setEnabled(false);
         else if (!BackupButton.isEnabled() &&
                  (state == MarkerState.MODIFIED || state == MarkerState.DELETED || state == MarkerState.ADDED))
            BackupButton.setEnabled(true);
      } else {
         BackupButton.setEnabled(false);
         RestoreButton.setEnabled(false);
      }

      boolean anyPendingChanges = false;
      Enumeration<AbstractMarker> markers = pendingChanges.keys();
      while(markers.hasMoreElements()) {
         AbstractMarker next = markers.nextElement();
         MarkerState state = pendingChanges.get(next);
         if (state != MarkerState.UNMODIFIED) {
            anyPendingChanges = true;
            break;
         }
      }
      if (RestoreAllButton.isEnabled() != anyPendingChanges)
         RestoreAllButton.setEnabled(anyPendingChanges);
      if (BackupAllButton.isEnabled() != anyPendingChanges)
         BackupAllButton.setEnabled(anyPendingChanges);
   }

   private void setPendingChanges(MarkerState state, AbstractMarker marker, boolean update) {
      // If the marker's current state is ADDED, then it was added after the last backup.
      // So do not allow it to be changed to MODIFIED or DELETED. It can be changed
      // to UNMODIFIED by backing up.
      MarkerState currentState = pendingChanges.get(marker);
      if (currentState == MarkerState.ADDED && state != MarkerState.UNMODIFIED)
         return;

      pendingChanges.put(marker, state);

      if (update)
         updateBackupRestoreButtons();

      // Mark the model as dirty as well.
      if (state != MarkerState.UNMODIFIED && currentModel != null) {
         SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
         guiElem.setUnsavedChangesFlag(true);
      }
   }
   
   private void setAllPendingChanges(MarkerState state) {
      boolean needsRepainting = false;
      Enumeration<AbstractMarker> markers = pendingChanges.keys();
      while(markers.hasMoreElements()) {
         AbstractMarker next = markers.nextElement();
         pendingChanges.put(next, state);
      }

      updateBackupRestoreButtons();

      // Mark the model as dirty as well.
      if (state != MarkerState.UNMODIFIED && currentModel != null) {
         SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
         guiElem.setUnsavedChangesFlag(true);
      }
   }

   private void backupMarker() {
      setPendingChanges(MarkerState.UNMODIFIED, currentMarker, true);
      AbstractMarker savedMarker = AbstractMarker.safeDownCast(currentMarker.copy());
      savedMarkers.put(currentMarker, savedMarker);
      //printInfo("backupMarker");
   }

   /* This is called when the user clicks on the "Backup All" button.
    * It backs up only the markers that have been modified since they
    * were last backed up.
    */
   private void backupAllMarkers() {
      // Should never be null, but just in case...
       if (currentModel == null)
          return;

      //printInfo("backupAllMarkers start");
      // Loop through the pendingChanges table:
      //    1. for MarkerState.DELETED, delete the backup and the pendingChanges entry
      //    2. for MarkerState.ADDED, make a backup
      //    3. for MarkerState.MODIFIED, copy the marker to the backup marker
      Enumeration<AbstractMarker> markers = pendingChanges.keys();
      while (markers.hasMoreElements()) {
         AbstractMarker marker = markers.nextElement();
         MarkerState state = pendingChanges.get(marker);
         if (state == MarkerState.DELETED) {
            savedMarkers.remove(marker);
            pendingChanges.remove(marker);
         } else if (state == MarkerState.ADDED) {
            AbstractMarker savedMarker = AbstractMarker.safeDownCast(marker.copy());
            savedMarkers.put(marker, savedMarker);
         } else if (state == MarkerState.MODIFIED) {
            AbstractMarker savedMarker = savedMarkers.get(marker);
            savedMarker.copy(marker);
         }
      }

      setAllPendingChanges(MarkerState.UNMODIFIED);
      //printInfo("backupAllMarkers end");
   }

   /* This is called when the current model is closed or switched. It deletes
    * all backed up markers, and then if there is a current model, it makes a
    * new set of backups for that model.
    */
   private void backupEveryMarker() {
      // Delete any existing marker backups, and clear the savedMarkers hash table.
      Iterator<AbstractMarker> markerIter = savedMarkers.values().iterator();
      while(markerIter.hasNext())
         AbstractMarker.deleteMarker(markerIter.next());
      savedMarkers.clear();

      pendingChanges.clear();

      // Make a backup of each actuator in the current model and add it to the savedMarkers hash table.
      if (currentModel != null) {
         MarkerSet markers = currentModel.getDynamicsEngine().getMarkerSet();
         for (int i=0; i<markers.getSize(); i++) {
            AbstractMarker savedMarker = AbstractMarker.safeDownCast(markers.get(i).copy());
            savedMarkers.put(markers.get(i), savedMarker);
            pendingChanges.put(markers.get(i), MarkerState.UNMODIFIED);
         }
      }
   }

   private void restoreMarker() {
      // Should never be null, but just in case...
      if (currentMarker == null || currentModel == null)
         return;
      //printInfo("restoreMarker start");
      AbstractMarker savedMarker = savedMarkers.get(currentMarker);
      // If savedMarker is null, then this marker was added by the user and not backed up yet. So delete it.
      // The pendingChanges entry for this marker should also be MarkerState.ADDED, but there's no need to check it.
      if (savedMarker == null) {
         deleteMarker(currentMarker, true);
         // If adding this marker was the only change to the marker set, then you need to
         // disable the backup all and restore all buttons.
         updateBackupRestoreButtons();
         return;
      }

      SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(currentModel);

      // If the name has changed, update the marker list in ViewDB and fire an event.
      if (currentMarker.getName().equals(savedMarker.getName()) == false) {
         ViewDB.getInstance().getModelGuiElements(currentModel).updateMarkerNames();
         Vector<OpenSimObject> objs = new Vector<OpenSimObject>(1);
         objs.add(currentMarker);
         ObjectsRenamedEvent evnt = new ObjectsRenamedEvent(this, currentModel, objs);
         OpenSimDB.getInstance().setChanged();
         OpenSimDB.getInstance().notifyObservers(evnt);
      }

      // Copy the elements of the saved marker into the current marker.
      currentMarker.copy(savedMarker);
      vis.updateMarkerGeometry(currentMarker);

      setPendingChanges(MarkerState.UNMODIFIED, currentMarker, false);
      setupComponent(currentMarker);
      ViewDB.getInstance().repaintAll();
      //printInfo("restoreMarker end");
   }

   private void restoreAllMarkers() {
      // Should never be null, but just in case...
       if (currentModel == null)
          return;

      boolean updateEditor = false;
      SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(currentModel);

      //printInfo("restoreAllMarkers start");

      // Loop through the pendingChanges table:
      //    1. delete all markers that are MarkerState.ADDED
      //    2. restore all markers that are MarkerState.MODIFIED or MarkerState.DELETED
      Enumeration<AbstractMarker> markers = pendingChanges.keys();
      Vector<OpenSimObject> renamedObjects = new Vector<OpenSimObject>(1);
      Vector<OpenSimObject> deletedObjects = new Vector<OpenSimObject>(1);
      Vector<OpenSimObject> addedObjects = new Vector<OpenSimObject>(1);
      while (markers.hasMoreElements()) {
         AbstractMarker marker = markers.nextElement();
         MarkerState state = pendingChanges.get(marker);
         if (state == MarkerState.DELETED) {
            double[] offset = new double[3];
            AbstractMarker savedMarker = savedMarkers.get(marker);
            MarkerSet markerset = currentModel.getDynamicsEngine().getMarkerSet();
            savedMarker.getOffset(offset);
            AbstractBody b = savedMarker.getBody();
            String n = savedMarker.getName();
            AbstractMarker restoredMarker = markerset.addMarker(savedMarker.getName(), offset, savedMarker.getBody());
            addedObjects.add(restoredMarker);
            pendingChanges.remove(marker);
            //wedpendingChanges.put(restoredMarker, MarkerState.UNMODIFIED);
            savedMarkers.remove(marker);
            savedMarkers.put(restoredMarker, savedMarker);
         } else if (state == MarkerState.ADDED) {
            deleteMarker(marker, false);
            deletedObjects.add(marker);
         } else if (state == MarkerState.MODIFIED) {
            AbstractMarker savedMarker = savedMarkers.get(marker);
            if (marker.getName().equals(savedMarker.getName()) == false) {
              renamedObjects.add(marker);
            }
            // Copy the elements of the saved marker into the [regular] marker.
            marker.copy(savedMarker);
            vis.updateMarkerGeometry(marker);
         }
      }

      // Update the marker name list in the ViewDB.
      ViewDB.getInstance().getModelGuiElements(currentModel).updateMarkerNames();

      if (renamedObjects.size() > 0) {
         ObjectsRenamedEvent evnt = new ObjectsRenamedEvent(this, currentModel, renamedObjects);
         OpenSimDB.getInstance().setChanged();
         OpenSimDB.getInstance().notifyObservers(evnt);
      }

      if (deletedObjects.size() > 0) {
         ObjectsDeletedEvent evnt = new ObjectsDeletedEvent(this, currentModel, deletedObjects);
         OpenSimDB.getInstance().setChanged();
         OpenSimDB.getInstance().notifyObservers(evnt);
      }

      if (addedObjects.size() > 0) {
         ObjectsAddedEvent evnt = new ObjectsAddedEvent(this, currentModel, addedObjects);
         OpenSimDB.getInstance().setChanged();
         OpenSimDB.getInstance().notifyObservers(evnt);
      }

      setAllPendingChanges(MarkerState.UNMODIFIED);

      ViewDB.getInstance().repaintAll();
      //printInfo("restoreAllMarkers end");
   }

   private String makeUniqueMarkerName(MarkerSet markerset) {
      String baseName = "NewMarker";
      String newMarkerName = baseName;
      AbstractMarker existingMarker = null;

      for (int i=0; i<markerset.getSize() + savedMarkers.size(); i++) {
         newMarkerName = baseName + "_" + i;
         existingMarker = markerset.get(newMarkerName);
         if (existingMarker != null) // name is being used by a current marker
            continue;
         boolean matchesSavedMarker = false;
         Enumeration<AbstractMarker> saved = savedMarkers.keys();
         while (saved.hasMoreElements()) {
            AbstractMarker marker = saved.nextElement();
            AbstractMarker savedMarker = savedMarkers.get(marker);
            if (newMarkerName.equals(savedMarker.getName())) {
               // name is being used by a saved marker
               matchesSavedMarker = true;
               break;
            }
         }
         if (matchesSavedMarker == false)
            break;
      }

      return newMarkerName;
   }

   private void printInfo(String label) {
      System.out.println(label);
      Enumeration<AbstractMarker> markers = pendingChanges.keys();
      while (markers.hasMoreElements()) {
         AbstractMarker marker = markers.nextElement();
         MarkerState state = pendingChanges.get(marker);
         System.out.println("pc: marker = " + AbstractMarker.getCPtr(marker) + ", state = " + state);
      }
      Enumeration<AbstractMarker> saved = savedMarkers.keys();
      while (saved.hasMoreElements()) {
         AbstractMarker marker = saved.nextElement();
         AbstractMarker sm = savedMarkers.get(marker);
         System.out.println("sm: marker = " + AbstractMarker.getCPtr(marker) + ", saved = " + AbstractMarker.getCPtr(sm));
      }
   }

   public void addMarker() {
      if (currentModel == null)
         return;

      double[] offset = {0.11, 0.22, 0.33};
      MarkerSet markerset = currentModel.getDynamicsEngine().getMarkerSet();
      AbstractBody body = currentModel.getDynamicsEngine().getBodySet().get(0);
      if (body == null)
         return;
      String newMarkerName = makeUniqueMarkerName(markerset);
      AbstractMarker marker = markerset.addMarker(newMarkerName, offset, body);
      //System.out.println("added marker " + AbstractMarker.getCPtr(marker));
      if (marker == null)
         return;

      currentMarker = null;

      // Update the marker name list in the ViewDB.
      ViewDB.getInstance().getModelGuiElements(currentModel).updateMarkerNames();

      Vector<OpenSimObject> objs = new Vector<OpenSimObject>(1);
      objs.add(marker);
      ObjectsAddedEvent evnt = new ObjectsAddedEvent(this, currentModel, objs);
      OpenSimDB.getInstance().setChanged();
      OpenSimDB.getInstance().notifyObservers(evnt);

      // update() will handle the ObjectsAddedEvent, but it will not set the
      // marker editor to be working on the new marker. So do it here.
      //setupComponent(marker);
   }

   public void deleteMarker(AbstractMarker marker, boolean sendEvent) {
      if (currentModel == null)
         return;

      // Remove the marker from the model's marker set.
      MarkerSet markerset = currentModel.getDynamicsEngine().getMarkerSet();
      markerset.remove(marker);

      // Update the marker name list in the ViewDB.
      ViewDB.getInstance().getModelGuiElements(currentModel).updateMarkerNames();

      if (sendEvent) {
         // Generate an event so everyone can update, including the marker editor.
         Vector<OpenSimObject> objs = new Vector<OpenSimObject>(1);
         objs.add(marker);
         ObjectsDeletedEvent evnt = new ObjectsDeletedEvent(this, currentModel, objs);
         OpenSimDB.getInstance().setChanged();
         OpenSimDB.getInstance().notifyObservers(evnt);
      }
   }

   /* Delete an array of markers. Only markers that are in the current model are
    * deleted.
    */
   public void deleteMarkers(ArrayList<AbstractMarker> markers, boolean sendEvent) {
      if (currentModel == null)
         return;

      int numMarkersDeleted = 0;
      MarkerSet markerset = currentModel.getDynamicsEngine().getMarkerSet();
      Vector<OpenSimObject> objs = new Vector<OpenSimObject>(0);

      for (int i=0; i<markers.size(); i++) {
         AbstractMarker marker = markers.get(i);
         Model model = marker.getBody().getDynamicsEngine().getModel();
         if (Model.getCPtr(model) == Model.getCPtr(currentModel)) {
            markerset.remove(marker);
            if (sendEvent)
               objs.add(marker);
            numMarkersDeleted++;
         }
      }

      if (numMarkersDeleted == 0)
         return;

      // Update the marker name list in the ViewDB.
      ViewDB.getInstance().getModelGuiElements(currentModel).updateMarkerNames();

      if (sendEvent) {
         // Generate an event so everyone can update, including the marker editor.
         ObjectsDeletedEvent evnt = new ObjectsDeletedEvent(this, currentModel, objs);
         OpenSimDB.getInstance().setChanged();
         OpenSimDB.getInstance().notifyObservers(evnt);
      }
   }

   private void handleAddEvent(ObjectsAddedEvent evt) {
      //printInfo("handleAddEvent start");
      boolean refreshNames = false;
      AbstractMarker marker = null;
      Vector<OpenSimObject> objs = evt.getObjects();
      for (int i=0; i<objs.size(); i++) {
         if (objs.get(i) instanceof AbstractMarker) {
            marker = (AbstractMarker)objs.get(i);
            pendingChanges.put(marker, MarkerState.ADDED);
            refreshNames = true;
         }
      }
      if (currentMarker == null && marker != null)
         setupComponent(marker);
      if (refreshNames)
         updateMarkerComboBox(null);
      //printInfo("handleAddEvent end");
   }

   // Create a new marker whose reference does not equal any marker
   // reference currently in pendingChanges or savedMarkers.
   private AbstractMarker createPlaceHolderMarker() {
      Marker placeHolder = null;
      while (true) {
         boolean foundOne = true;
         placeHolder = new Marker();
         Enumeration<AbstractMarker> markers = pendingChanges.keys();
         while (markers.hasMoreElements()) {
            AbstractMarker marker = markers.nextElement();
            if (AbstractMarker.getCPtr(marker) == AbstractMarker.getCPtr(placeHolder)) {
               foundOne = false;
               break;
            }
         }
         if (foundOne) {
            Enumeration<AbstractMarker> saved = savedMarkers.keys();
            while (saved.hasMoreElements()) {
               AbstractMarker marker = saved.nextElement();
               if (AbstractMarker.getCPtr(marker) == AbstractMarker.getCPtr(placeHolder)) {
                  foundOne = false;
                  break;
               }
            }
         }
         if (foundOne)
            break;
      }
      return placeHolder;
   }

   private void handleDeleteEvent(ObjectsDeletedEvent evt) {
      //printInfo("handleDeleteEvent start");
      boolean refreshNames = false, setupEditor = false;
      Vector<OpenSimObject> objs = evt.getObjects();
      for (int i=0; i<objs.size(); i++) {
         if (objs.get(i) instanceof AbstractMarker) {
            AbstractMarker marker = (AbstractMarker)objs.get(i);
            // If the marker is MarkerState.ADDED, then it was added after the last
            // backup, so remove all traces of it from the marker editor. If it is not,
            // then keep it in pendingChanges but set it to MarkerState.DELETED.
            // To make sure that the address of this deleted marker is not re-used
            // later by a new marker, create a new place-holder marker and replace
            // the deleted marker's reference with the place holder. The memory
            // associated with the place holder will be freed when it is removed
            // from both the pendingChanges and savedMarkers hash tables.
            if (pendingChanges.get(marker) == MarkerState.ADDED)
               pendingChanges.remove(marker);
            else {
               AbstractMarker placeHolder = createPlaceHolderMarker();
               AbstractMarker savedMarker = savedMarkers.get(marker);
               //System.out.println("placeHolder = " + AbstractMarker.getCPtr(placeHolder));
               pendingChanges.remove(marker);
               savedMarkers.remove(marker);
               pendingChanges.put(placeHolder, MarkerState.DELETED);
               savedMarkers.put(placeHolder, savedMarker);
            }
            refreshNames = true;
            if (currentMarker != null && AbstractMarker.getCPtr(currentMarker) == AbstractMarker.getCPtr(marker))
                setupEditor = true;
         }
      }
      if (setupEditor)
         setupComponent(null);
      else if (refreshNames) {
         updateMarkerComboBox(null);
      }
      //printInfo("handleDeleteEvent end");
   }

   private void updateMarkerLineDisplay(SelectedObject selectedObject, boolean state) {
      OpenSimObject obj = selectedObject.getOpenSimObject();
      AbstractMarker marker = AbstractMarker.safeDownCast(obj);
      if (marker != null) {
         Model model = marker.getBody().getDynamicsEngine().getModel();
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
         vis.setMarkerLineVisible(marker, state);
      }
   }
   
   private void dragMarkers(DragObjectsEvent ev) {
      ArrayList<SelectedObject> selectedObjects = ViewDB.getInstance().getSelectedObjects();
      AbstractMarker m = null;
      boolean currentMarkerMoved = false;
      for (int i = 0; i < selectedObjects.size(); i++) {
         OpenSimObject obj = selectedObjects.get(i).getOpenSimObject();
         m = AbstractMarker.safeDownCast(obj);
         if (m != null) {
            AbstractDynamicsEngine engine = currentModel.getDynamicsEngine();
            AbstractBody body = m.getBody();
            AbstractBody ground = engine.getGroundBody();
            double dragVectorBody[] = new double[3];
            double offset[] = new double[3];
            engine.transform(ground, ev.getDragVector(), body, dragVectorBody);
            //System.out.println("drag: " + ev.getDragVector()[0] + " " + ev.getDragVector()[1] + " " + ev.getDragVector()[2]);
            m.getOffset(offset);
            for (int j=0; j<3; j++)
               offset[j] += dragVectorBody[j];
            m.setOffset(offset);
            setPendingChanges(MarkerState.MODIFIED, m, false);
            // Check to see if the muscle editor's current muscle was moved, so you can update the window later.
            if (AbstractMarker.getCPtr(m) == AbstractMarker.getCPtr(currentMarker)) {
               currentMarkerMoved = true;
            }
            // Update the marker geometry.
            SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(currentModel);
            vis.updateMarkerGeometry(m);
         }
      }
      // If m is not null, then at least one selected object is a marker
      // (that was just dragged). So redraw the model.
      if (m != null) {
         SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
         guiElem.setUnsavedChangesFlag(true);
         // If the current muscle moved, update the necessary panels.
         if (currentMarkerMoved) {
            updateOffsetFields();
         }
         updateBackupRestoreButtons();
         ViewDB.getInstance().renderAll();
      }
   }

   private boolean validName(String markerName) {
      //printInfo("validName");
      if (currentModel != null && currentMarker != null) {
         if (markerName.length() < 1) {
            MarkerNameTextField.setText(currentMarker.getName());
            return false;
         }
         AbstractMarker existingMarker = currentModel.getDynamicsEngine().getMarkerSet().get(markerName);
         if (existingMarker != null && AbstractMarker.getCPtr(existingMarker) != AbstractMarker.getCPtr(currentMarker)) {
            MarkerNameTextField.setText(currentMarker.getName());
            Object[] options = {"OK"};
            String message = "The name \"" + markerName + "\" is already being used. Please choose a different marker name.";
            int answer = JOptionPane.showOptionDialog(this,
                         message,
                         "Marker Editor",
                         JOptionPane.OK_OPTION,
                         JOptionPane.WARNING_MESSAGE,
                         null,
                         options,
                         options[0]);
            return false;
         } else {
            // If the new name is the same as one of a backed-up marker (which could be
            // restored at some time in the future), do not allow the new name.
            Enumeration<AbstractMarker> saved = savedMarkers.keys();
            while (saved.hasMoreElements()) {
               AbstractMarker marker = saved.nextElement();
               AbstractMarker savedMarker = savedMarkers.get(marker);
               if (markerName.equals(savedMarker.getName())) {
                  Object[] options = {"OK"};
                  String message = "The name \"" + markerName + "\" is already being used by a backup copy of a marker. Please choose a different marker name.";
                  int answer = JOptionPane.showOptionDialog(this,
                               message,
                               "Marker Editor",
                               JOptionPane.OK_OPTION,
                               JOptionPane.WARNING_MESSAGE,
                               null,
                               options,
                               options[0]);
                  return false;
               }
            }
            return true;
         }
      }

      return false;
   }

   // Called from update(), this function handles changes to the list of marker names
   // for the current model. If 'marker' is null, then a marker was added or deleted.
   // If it is not null, then the name of 'marker' was changed.
   private void updateMarkerComboBox(AbstractMarker marker) {
      SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(currentModel);
      String [] markerNames = guiElem.getMarkerNames();
      MarkerComboBox.setModel(new javax.swing.DefaultComboBoxModel(markerNames));
      if (currentMarker != null) {
         MarkerComboBox.setSelectedIndex(findElement(markerNames, currentMarker.getName()));
         if (marker != null && currentMarker.equals(marker))
            MarkerNameTextField.setText(currentMarker.getName());
      }
      if (marker != null)
         setPendingChanges(MarkerState.MODIFIED, marker, true);
   }

   public void open() {
      AbstractMarker newMarker = null;
      Node[] selected = ExplorerTopComponent.findInstance().getExplorerManager().getSelectedNodes();
      if (selected.length > 0 && selected[0] instanceof OneMarkerNode) {
         OneMarkerNode markerNode = (OneMarkerNode) selected[0];
         newMarker = AbstractMarker.safeDownCast(markerNode.getOpenSimObject());
         if (newMarker != null && AbstractMarker.getCPtr(newMarker) != AbstractMarker.getCPtr(currentMarker)) {
            Model newModel = newMarker.getBody().getDynamicsEngine().getModel();
            if (Model.getCPtr(newModel) != Model.getCPtr(currentModel)) {
               Object[] options = {"OK"};
               int answer = JOptionPane.showOptionDialog(this,
                       "You can only edit markers that are in the current model.",
                       "Marker Editor",
                       JOptionPane.DEFAULT_OPTION,
                       JOptionPane.WARNING_MESSAGE,
                       null,
                       options,
                       options[0]);
            } else {
               currentMarker = newMarker;
               setPendingChanges(MarkerState.UNMODIFIED, currentMarker, false);
               setupComponent(currentMarker);
            }
         }
      } else {
         setAllPendingChanges(MarkerState.UNMODIFIED);
         setupComponent(null);
      }
      super.open();
      this.requestActive();
   }

   public void update(Observable o, Object arg) {
      if (o instanceof ViewDB) {
         if (arg instanceof ObjectSelectedEvent) {
            ObjectSelectedEvent ev = (ObjectSelectedEvent)arg;
            updateMarkerLineDisplay(ev.getSelectedObject(), ev.getState());
         } else if (arg instanceof ClearSelectedObjectsEvent) {
            if (currentModel != null) {
               MarkerSet markers = currentModel.getDynamicsEngine().getMarkerSet();
               SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(currentModel);
               for (int i=0; i<markers.getSize(); i++)
                  vis.setMarkerLineVisible(markers.get(i), false);
            }
         } else if (arg instanceof DragObjectsEvent) {
            dragMarkers((DragObjectsEvent)arg);
         }
      } else if (o instanceof OpenSimDB) {
         // if current model is being switched due to open/close or change current then
         // update tool window
         if (arg instanceof ModelEvent) {
            final ModelEvent evt = (ModelEvent)arg;
            if (evt.getOperation() == ModelEvent.Operation.Close && OpenSimDB.getInstance().getCurrentModel() == null) {
               currentModel = null;
               currentMarker = null;
               backupEveryMarker();
               setAllPendingChanges(MarkerState.UNMODIFIED);
               setupComponent(null);
            }
            // Do we need to handle close separately or should we be called with SetCurrent of null model?
         } else if (arg instanceof ObjectSetCurrentEvent) {
            ObjectSetCurrentEvent evt = (ObjectSetCurrentEvent)arg;
            Vector<OpenSimObject> objs = evt.getObjects();
            // If any of the event objects is a model not equal to the current model, this means there is a new
            // current model. So clear out the panel.
            for (int i=0; i<objs.size(); i++) {
               if (objs.get(i) instanceof Model) {
                  if (currentModel == null || !currentModel.equals(objs.get(i))) {
                     currentModel = (Model)objs.get(i);
                     currentMarker = null;
                     backupEveryMarker();
                     setAllPendingChanges(MarkerState.UNMODIFIED);
                     setupComponent(null);
                     break;
                  }
               }
            }
         } else if (arg instanceof ObjectsAddedEvent) {
            if (currentModel != null) {
               handleAddEvent((ObjectsAddedEvent)arg);
            }
         } else if (arg instanceof ObjectsDeletedEvent) {
            if (currentModel != null) {
               handleDeleteEvent((ObjectsDeletedEvent)arg);
            }
         } else if (arg instanceof ObjectsChangedEvent) {
         } else if (arg instanceof ObjectsRenamedEvent) {
            ObjectsRenamedEvent evt = (ObjectsRenamedEvent)arg;
            Vector<OpenSimObject> objs = evt.getObjects();
            for (int i=0; i<objs.size(); i++) {
               if (objs.get(i) instanceof Model) {
                  if (currentModel != null && currentModel.equals(objs.get(i)))
                     ModelNameLabel.setText("Model: " + currentModel.getName());
               } else if (objs.get(i) instanceof AbstractMarker) {
                  AbstractMarker marker = (AbstractMarker)objs.get(i);
                  if (currentModel != null && currentModel.equals(marker.getBody().getDynamicsEngine().getModel()))
                     updateMarkerComboBox(marker);
               }
            }
         }
      }
   }

   private int findElement(String[] nameList, String name) {
      int i;
      for (i = 0; i < nameList.length; i++)
         if (nameList[i].equals(name))
            return i;
      return -1;
   }

    /**
     * Gets default instance. Do not use directly: reserved for *.settings files only,
     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.
     * To obtain the singleton instance, use {@link findInstance}.
     */
    public static synchronized MarkerEditorTopComponent getDefault() {
       if (instance == null) {
          instance = new MarkerEditorTopComponent();
       }
       return instance;
    }
    
    /**
     * Obtain the MarkerEditorTopComponent instance. Never call {@link #getDefault} directly!
     */
    public static synchronized MarkerEditorTopComponent findInstance() {
       TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
       if (win == null) {
          ErrorManager.getDefault().log(ErrorManager.WARNING, "Cannot find MarkerEditor component. It will not be located properly in the window system.");
          return getDefault();
       }
       if (win instanceof MarkerEditorTopComponent) {
          return (MarkerEditorTopComponent)win;
       }
       ErrorManager.getDefault().log(ErrorManager.WARNING, "There seem to be multiple components with the '" + PREFERRED_ID + "' ID. That is a potential source of errors and unexpected behavior.");
       return getDefault();
    }
    
    public int getPersistenceType() {
       return TopComponent.PERSISTENCE_ALWAYS;
    }
    
    public void componentOpened() {
       // TODO add custom code on component opening
    }
    
    public void componentClosed() {
       // TODO add custom code on component closing
    }
    
    /** replaces this in object stream */
    public Object writeReplace() {
       return new ResolvableHelper();
    }
    
    protected String preferredID() {
       return PREFERRED_ID;
    }
    
    final static class ResolvableHelper implements Serializable {
       private static final long serialVersionUID = 1L;
       public Object readResolve() {
          return MarkerEditorTopComponent.getDefault();
       }
    }
}

