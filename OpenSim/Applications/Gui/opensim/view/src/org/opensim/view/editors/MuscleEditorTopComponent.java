package org.opensim.view.editors;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.IOException;
import java.io.Serializable;
import java.util.Observable;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.SwingConstants;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Observer;
import org.openide.ErrorManager;
import org.openide.nodes.Node;
import org.openide.util.NbBundle;
import org.openide.windows.Mode;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;
import org.opensim.modeling.AbstractActuator;
import org.opensim.modeling.AbstractBody;
import org.opensim.modeling.AbstractCoordinate;
import org.opensim.modeling.AbstractDynamicsEngine;
import org.opensim.modeling.Model;
import org.opensim.modeling.AbstractWrapObject;
import org.opensim.modeling.ArrayPtrsPropertyGroup;
import org.opensim.modeling.CoordinateSet;
import org.opensim.modeling.MuscleWrap;
import org.opensim.modeling.PropertyGroup;
import org.opensim.modeling.MusclePointSet;
import org.opensim.modeling.MuscleViaPoint;
import org.opensim.modeling.WrapEllipsoid;
import org.opensim.modeling.BodySet;
import org.opensim.modeling.Function;
import org.opensim.modeling.OpenSimObject;
import org.opensim.modeling.Property;
import org.opensim.modeling.PropertySet;
import org.opensim.modeling.SetMuscleWrap;
import org.opensim.modeling.ArrayMusclePoint;
import org.opensim.modeling.SetWrapObject;
import org.opensim.modeling.AbstractMuscle;
import org.opensim.modeling.MusclePoint;
import org.opensim.modeling.VisibleProperties.DisplayPreference;
import org.opensim.view.ClearSelectedObjectsEvent;
import org.opensim.view.DragObjectsEvent;
import org.opensim.view.ExplorerTopComponent;
import org.opensim.view.ModelEvent;
import org.opensim.view.NameChangedEvent;
import org.opensim.view.ObjectSelectedEvent;
import org.opensim.view.SingleModelGuiElements;
import org.opensim.view.SingleModelVisuals;
import org.opensim.view.nodes.OneActuatorNode;
import org.opensim.view.pub.OpenSimDB;
import org.opensim.view.pub.ViewDB;
import org.opensim.view.SelectedObject;

/**
 * Top component which displays the Muscle Editor window.
 */
final public class MuscleEditorTopComponent extends TopComponent implements Observer {
   
   private static MuscleEditorTopComponent instance;
   private AbstractActuator act = null; // the actuator that is currently shown in the Muscle Editor window
   private AbstractActuator actSaved = null; // the state that gets restored when "reset" is pressed
   private boolean pendingChanges = false;
   private static final String[] wrapMethodNames = {"hybrid", "midpoint", "axial"};
   private javax.swing.JScrollPane AttachmentsTab = null;
   private javax.swing.JScrollPane WrapTab = null;
   private javax.swing.JScrollPane CurrentPathTab = null;
   private String selectedTabName = null;
   private javax.swing.JCheckBox attachmentSelectBox[] = null; // array of checkboxes for selecting attachment points
   private String[] wrapObjectNames = null;
   
   /** path to the icon used by the component and its open action */
//    static final String ICON_PATH = "SET/PATH/TO/ICON/HERE";
   
   private static final String PREFERRED_ID = "MuscleEditorTopComponent";
   private static String s_mode="leftSlidingSide";
   
   private MuscleEditorTopComponent() {
      initComponents();
      ViewDB.getInstance().addObserver(this);
      setName(NbBundle.getMessage(MuscleEditorTopComponent.class, "CTL_MuscleEditorTopComponent"));
      setToolTipText(NbBundle.getMessage(MuscleEditorTopComponent.class, "HINT_MuscleEditorTopComponent"));
//        setIcon(Utilities.loadImage(ICON_PATH, true));
      ViewDB.getInstance().addObserver(this);
      OpenSimDB.getInstance().addObserver(this);
   }

   private void setPendingChanges(boolean state, boolean repaint) {
      pendingChanges = state;
      if (ResetButton.isEnabled() != state) {
         ResetButton.setEnabled(state);
         if (repaint == true)
            ViewDB.getInstance().repaintAll();
      }
   }

   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
   private void initComponents() {
      MuscleEditorScrollPane = new javax.swing.JScrollPane();
      MuscleEditorPanel = new javax.swing.JPanel();
      MuscleTypeComboBox = new javax.swing.JComboBox();
      ApplyButton = new javax.swing.JButton();
      ResetButton = new javax.swing.JButton();
      MuscleNameTextField = new javax.swing.JTextField();
      ParametersTabbedPanel = new javax.swing.JTabbedPane();
      MuscleNameLabel = new javax.swing.JLabel();
      MuscleTypeLabel = new javax.swing.JLabel();
      ModelNameLabel = new javax.swing.JLabel();

      MuscleEditorScrollPane.setBorder(null);
      MuscleEditorPanel.setMinimumSize(new java.awt.Dimension(5, 5));
      MuscleEditorPanel.setPreferredSize(new java.awt.Dimension(5, 5));

      org.openide.awt.Mnemonics.setLocalizedText(ApplyButton, "save");
      ApplyButton.setToolTipText("save changes to this muscle");
      ApplyButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            ApplyButtonActionPerformed(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(ResetButton, "reset");
      ResetButton.setToolTipText("undo changes to last saved version");
      ResetButton.setMaximumSize(new java.awt.Dimension(63, 25));
      ResetButton.setMinimumSize(new java.awt.Dimension(63, 25));
      ResetButton.setPreferredSize(new java.awt.Dimension(63, 25));
      ResetButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            ResetButtonActionPerformed(evt);
         }
      });

      MuscleNameTextField.setText("<muscle name>");
      MuscleNameTextField.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            MuscleNameTextFieldActionPerformed(evt);
         }
      });
      MuscleNameTextField.addFocusListener(new java.awt.event.FocusAdapter() {
         public void focusLost(java.awt.event.FocusEvent evt) {
            MuscleNameTextFieldFocusLost(evt);
         }
      });

      org.openide.awt.Mnemonics.setLocalizedText(MuscleNameLabel, "name:");

      MuscleTypeLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
      org.openide.awt.Mnemonics.setLocalizedText(MuscleTypeLabel, "type:");

      org.openide.awt.Mnemonics.setLocalizedText(ModelNameLabel, "model: <name>\n");

      org.jdesktop.layout.GroupLayout MuscleEditorPanelLayout = new org.jdesktop.layout.GroupLayout(MuscleEditorPanel);
      MuscleEditorPanel.setLayout(MuscleEditorPanelLayout);
      MuscleEditorPanelLayout.setHorizontalGroup(
         MuscleEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(MuscleEditorPanelLayout.createSequentialGroup()
            .add(118, 118, 118)
            .add(ResetButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 195, Short.MAX_VALUE)
            .add(ApplyButton)
            .add(159, 159, 159))
         .add(MuscleEditorPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(MuscleEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(ParametersTabbedPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 570, Short.MAX_VALUE)
               .add(ModelNameLabel)
               .add(MuscleEditorPanelLayout.createSequentialGroup()
                  .add(MuscleNameLabel)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(MuscleNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 125, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .add(65, 65, 65)
                  .add(MuscleTypeLabel)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                  .add(MuscleTypeComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                  .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)))
            .addContainerGap())
      );
      MuscleEditorPanelLayout.setVerticalGroup(
         MuscleEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(MuscleEditorPanelLayout.createSequentialGroup()
            .addContainerGap()
            .add(ModelNameLabel)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(MuscleEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(MuscleNameLabel)
               .add(MuscleTypeLabel)
               .add(MuscleTypeComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(MuscleNameTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(ParametersTabbedPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 246, Short.MAX_VALUE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(MuscleEditorPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
               .add(ResetButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
               .add(ApplyButton))
            .addContainerGap())
      );
      MuscleEditorScrollPane.setViewportView(MuscleEditorPanel);

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(MuscleEditorScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 594, Short.MAX_VALUE)
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(MuscleEditorScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 358, Short.MAX_VALUE)
      );
   }// </editor-fold>//GEN-END:initComponents
   
   private void MuscleNameTextFieldFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_MuscleNameTextFieldFocusLost
      act.setName(MuscleNameTextField.getText());
      setPendingChanges(true, false);
      OpenSimDB.getInstance().setChanged();
      NameChangedEvent evnt = new NameChangedEvent(act);
      OpenSimDB.getInstance().notifyObservers(evnt);
   }//GEN-LAST:event_MuscleNameTextFieldFocusLost

   private void MuscleNameTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MuscleNameTextFieldActionPerformed
      act.setName(MuscleNameTextField.getText());
      setPendingChanges(true, false);
      OpenSimDB.getInstance().setChanged();
      NameChangedEvent evnt = new NameChangedEvent(act);
      OpenSimDB.getInstance().notifyObservers(evnt);
   }//GEN-LAST:event_MuscleNameTextFieldActionPerformed
   
   private void ResetButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ResetButtonActionPerformed
      resetActuator();
   }//GEN-LAST:event_ResetButtonActionPerformed
   
   private void ApplyButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ApplyButtonActionPerformed
      saveActuator();
   }//GEN-LAST:event_ApplyButtonActionPerformed

   private void saveActuator() {
      act.setName(MuscleNameTextField.getText());
      setPendingChanges(false, false);
      OpenSimDB.getInstance().setChanged();
      NameChangedEvent evnt = new NameChangedEvent(act);
      OpenSimDB.getInstance().notifyObservers(evnt);
      actSaved = AbstractActuator.safeDownCast(act.copy());
      actSaved.setName(act.getName()); // TODO: what about other properties of parent classes?
   }

   /** resetActuator
    *  Because the type of the actuator may have changed, you have to remove the current
    *  one (act) and replace it with the saved one (actSaved).
    */
   private void resetActuator() {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      Model model = asm.getModel();
      SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);

      // Save the display preference of the old muscle.
      DisplayPreference dp = act.getDisplayer().getVisibleProperties().getDisplayPreference();
      vis.removeActuatorGeometry(act);
      model.getActuatorSet().replaceActuator(act, actSaved);
      act = actSaved;
      // Set the display preference of the new muscle to the same as the old.
      act.getDisplayer().getVisibleProperties().setDisplayPreference(dp);
      vis.addActuatorGeometry(act, true);

      setPendingChanges(false, false);
      OpenSimDB.getInstance().setChanged();
      NameChangedEvent evnt = new NameChangedEvent(act); // TODO: what about other changes to the muscle?
      OpenSimDB.getInstance().notifyObservers(evnt);
      setupComponent(act);
      ViewDB.getInstance().repaintAll();
   }

   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JButton ApplyButton;
   private javax.swing.JLabel ModelNameLabel;
   private javax.swing.JPanel MuscleEditorPanel;
   private javax.swing.JScrollPane MuscleEditorScrollPane;
   private javax.swing.JLabel MuscleNameLabel;
   private javax.swing.JTextField MuscleNameTextField;
   private javax.swing.JComboBox MuscleTypeComboBox;
   private javax.swing.JLabel MuscleTypeLabel;
   private javax.swing.JTabbedPane ParametersTabbedPanel;
   private javax.swing.JButton ResetButton;
   // End of variables declaration//GEN-END:variables
   
   /**
    * Gets default instance. Do not use directly: reserved for *.settings files only,
    * i.e. deserialization routines; otherwise you could get a non-deserialized instance.
    * To obtain the singleton instance, use {@link findInstance}.
    */
   public static synchronized MuscleEditorTopComponent getDefault() {
      if (instance == null) {
         instance = new MuscleEditorTopComponent();
      }
      return instance;
   }
   
   /**
    * Obtain the MuscleEditorTopComponent instance. Never call {@link #getDefault} directly!
    */
   public static synchronized MuscleEditorTopComponent findInstance() {
      TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
      if (win == null) {
         ErrorManager.getDefault().log(ErrorManager.WARNING, "Cannot find MuscleEditor component. It will not be located properly in the window system.");
         return getDefault();
      }
      if (win instanceof MuscleEditorTopComponent) {
         return (MuscleEditorTopComponent)win;
      }
      ErrorManager.getDefault().log(ErrorManager.WARNING, "There seem to be multiple components with the '" + PREFERRED_ID + "' ID. That is a potential source of errors and unexpected behavior.");
      return getDefault();
   }
   
   public int getPersistenceType() {
      return TopComponent.PERSISTENCE_ALWAYS;
   }
   
   public void AttachmentPointEntered(javax.swing.JTextField field, int attachmentNum, int coordNum) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      MusclePointSet musclePoints = asm.getAttachmentSet();
      double oldValue = musclePoints.get(attachmentNum).getAttachment().getitem(coordNum);
      double newValue = Double.parseDouble(field.getText());
      NumberFormat nf = NumberFormat.getInstance();
      nf.setMaximumFractionDigits(5); // TODO
      nf.setMinimumFractionDigits(5); // TODO
      // format the number and write it back into the text field
      field.setText(nf.format(newValue));
      // update the model if the number has changed
      if (oldValue != newValue) {
         musclePoints.get(attachmentNum).setAttachment(coordNum, newValue);
         setPendingChanges(true, false);
         // tell the ViewDB to redraw the model
         Model model = asm.getModel();
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
         vis.updateActuatorGeometry(asm, true);
         ViewDB.getInstance().repaintAll();
         // update the current path panel
         setupCurrentPathPanel(asm);
      }
   }
   
   public void AttachmentBodyChosen(javax.swing.JComboBox bodyComboBox, int attachmentNum) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      MusclePointSet musclePoints = asm.getAttachmentSet();
      AbstractBody oldBody = musclePoints.get(attachmentNum).getBody();
      Model model = asm.getModel();
      BodySet bodies = model.getDynamicsEngine().getBodySet();
      AbstractBody newBody = bodies.get(bodyComboBox.getSelectedIndex());
      if (AbstractBody.getCPtr(newBody) != AbstractBody.getCPtr(oldBody)) {
         musclePoints.get(attachmentNum).setBody(newBody);
         setPendingChanges(true, false);
         // tell the ViewDB to redraw the model
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
         vis.updateActuatorGeometry(asm, true);
         ViewDB.getInstance().repaintAll();
         // update the current path panel
         setupCurrentPathPanel(asm);
      }
   }

   public void AttachmentSelected(javax.swing.JCheckBox attachmentSelBox, int attachmentNum) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      MusclePointSet musclePoints = asm.getAttachmentSet();
      MusclePoint point = musclePoints.get(attachmentNum);
      ViewDB.getInstance().toggleAddSelectedObject(point);
   }

   public void ViaCoordinateChosen(javax.swing.JComboBox coordComboBox, int attachmentNum) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      MusclePointSet musclePoints = asm.getAttachmentSet();
      MuscleViaPoint via = MuscleViaPoint.safeDownCast(musclePoints.get(attachmentNum));
      AbstractCoordinate oldCoord = via.getCoordinate();
      Model model = asm.getModel();
      CoordinateSet coords = model.getDynamicsEngine().getCoordinateSet();
      AbstractCoordinate newCoord = coords.get(coordComboBox.getSelectedIndex());
      if (AbstractCoordinate.getCPtr(newCoord) != AbstractCoordinate.getCPtr(oldCoord)) {
         via.setCoordinate(newCoord);
         // make sure the range min and range max are valid for this new coordinate
         double rangeMin = via.getRange().getitem(0);
         double rangeMax = via.getRange().getitem(1);
         boolean needsUpdating = false;
         if (rangeMin > newCoord.getRangeMax() || rangeMax < newCoord.getRangeMin()) {
            // If there is no overlap between the old range and the new range, use new range
            via.setRangeMin(newCoord.getRangeMin());
            via.setRangeMax(newCoord.getRangeMax());
            needsUpdating = true;
         } else {
            // Adjust the min and max to fit in the new range
            if (rangeMin < newCoord.getRangeMin()) {
               via.setRangeMin(newCoord.getRangeMin());
               needsUpdating = true;
            }
            if (rangeMax > newCoord.getRangeMax()) {
               via.setRangeMax(newCoord.getRangeMax());
               needsUpdating = true;
            }
         }
         if (needsUpdating) {
            setPendingChanges(true, false);
            setupAttachmentPanel(asm);
         }
         ParametersTabbedPanel.setSelectedComponent(AttachmentsTab);
         // tell the ViewDB to redraw the model
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
         vis.updateActuatorGeometry(asm, true);
         ViewDB.getInstance().repaintAll();
         // update the current path panel
         setupCurrentPathPanel(asm);
      }
   }

   public void RangeMinEntered(javax.swing.JTextField field, int attachmentNum) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      MusclePointSet musclePoints = asm.getAttachmentSet();
      MuscleViaPoint via = MuscleViaPoint.safeDownCast(musclePoints.get(attachmentNum));
      double oldValue = via.getRange().getitem(0);
      double smallestAllowed = via.getCoordinate().getRangeMin();
      double biggestAllowed = via.getRange().getitem(1);
      double newValue = Double.parseDouble(field.getText());
      NumberFormat nf = NumberFormat.getInstance();
      nf.setMaximumFractionDigits(5); // TODO
      nf.setMinimumFractionDigits(5); // TODO
      if (newValue > biggestAllowed) {
         // user entered min that is greater than max, ignore it
         field.setText(nf.format(oldValue));
      } else {
         // if the new value is less than the coordinate's min, use coordinate's min
         if (newValue < smallestAllowed)
            newValue = smallestAllowed;
         // format the number and write it back into the text field
         field.setText(nf.format(newValue));
         // update the model if the number has changed
         if (newValue != oldValue) {
            via.setRangeMin(newValue);
            setPendingChanges(true, false);
            // tell the ViewDB to redraw the model
            Model model = asm.getModel();
            SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
            vis.updateActuatorGeometry(asm, true);
            ViewDB.getInstance().repaintAll();
            // update the current path panel
            setupCurrentPathPanel(asm);
         }
      }
   }

   public void RangeMaxEntered(javax.swing.JTextField field, int attachmentNum) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      MusclePointSet musclePoints = asm.getAttachmentSet();
      MuscleViaPoint via = MuscleViaPoint.safeDownCast(musclePoints.get(attachmentNum));
      double oldValue = via.getRange().getitem(1);
      double smallestAllowed = via.getRange().getitem(0);
      double biggestAllowed = via.getCoordinate().getRangeMax();
      double newValue = Double.parseDouble(field.getText());
      NumberFormat nf = NumberFormat.getInstance();
      nf.setMaximumFractionDigits(5); // TODO
      nf.setMinimumFractionDigits(5); // TODO
      if (newValue < smallestAllowed) {
         // user entered max that is less than min, ignore it
         field.setText(nf.format(oldValue));
      } else {
         // if the new value is greater than the coordinate's max, use coordinate's max
         if (newValue > biggestAllowed)
            newValue = biggestAllowed;
         // format the number and write it back into the text field
         field.setText(nf.format(newValue));
         // update the model if the number has changed
         if (newValue != oldValue) {
            via.setRangeMax(newValue);
            setPendingChanges(true, false);
            // tell the ViewDB to redraw the model
            Model model = asm.getModel();
            SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
            vis.updateActuatorGeometry(asm, true);
            ViewDB.getInstance().repaintAll();
            // update the current path panel
            setupCurrentPathPanel(asm);
         }
      }
   }

   public void setWrapStartRange(javax.swing.JComboBox wrapStartComboBox, int wrapNum) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      MuscleWrap mw = asm.getWrapSet().get(wrapNum);
      int oldStartPt = mw.getStartPoint();
      int newStartPt = wrapStartComboBox.getSelectedIndex();
      if (newStartPt < 1)
         newStartPt = -1;
      if (newStartPt != oldStartPt) {
         mw.setStartPoint(newStartPt);
         setPendingChanges(true, false);
         Model model = asm.getModel();
         // tell the ViewDB to redraw the model
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
         vis.updateActuatorGeometry(asm, true);
         ViewDB.getInstance().repaintAll();
         // update the current path panel
         setupCurrentPathPanel(asm);
      }
   }

   public void setWrapEndRange(javax.swing.JComboBox wrapEndComboBox, int wrapNum) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      MuscleWrap mw = asm.getWrapSet().get(wrapNum);
      int oldEndPt = mw.getEndPoint();
      int newEndPt = wrapEndComboBox.getSelectedIndex();
      if (newEndPt == wrapEndComboBox.getItemCount()-1)
         newEndPt = -1;
      else
         newEndPt++;
      if (newEndPt != oldEndPt) {
         mw.setEndPoint(newEndPt);
         setPendingChanges(true, false);
         Model model = asm.getModel();
         // tell the ViewDB to redraw the model
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
         vis.updateActuatorGeometry(asm, true);
         ViewDB.getInstance().repaintAll();
         // update the current path panel
         setupCurrentPathPanel(asm);
      }
   }

   public void addMuscleWrap(int menuChoice) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      AbstractWrapObject awo = asm.getModel().getDynamicsEngine().getWrapObject(wrapObjectNames[menuChoice]);
      asm.addMuscleWrap(awo);
      setPendingChanges(true, false);
      setupComponent(act);
      Model model = asm.getModel();
      SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
      vis.updateActuatorGeometry(asm, true);
      ViewDB.getInstance().repaintAll();
   }

   public void moveUpMuscleWrap(int num) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      asm.moveUpMuscleWrap(num);
      setPendingChanges(true, false);
      setupComponent(act);
      Model model = asm.getModel();
      SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
      vis.updateActuatorGeometry(asm, true);
      ViewDB.getInstance().repaintAll();
   }

   public void moveDownMuscleWrap(int num) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      asm.moveDownMuscleWrap(num);
      setPendingChanges(true, false);
      setupComponent(act);
      Model model = asm.getModel();
      SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
      vis.updateActuatorGeometry(asm, true);
      ViewDB.getInstance().repaintAll();
   }

   public void deleteMuscleWrap(int num) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      asm.deleteMuscleWrap(num);
      setPendingChanges(true, false);
      setupComponent(act);
      Model model = asm.getModel();
      SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
      vis.updateActuatorGeometry(asm, true);
      ViewDB.getInstance().repaintAll();
   }

   public void setWrapMethod(javax.swing.JComboBox wrapMethodComboBox, int num) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      MuscleWrap mw = asm.getWrapSet().get(num);
      int methodInt = wrapMethodComboBox.getSelectedIndex();
      //TODO: there must be a better way to relate selected index to WrapMethod enum
      if (methodInt == 0)
         mw.setMethod(MuscleWrap.WrapMethod.hybrid);
      else if (methodInt == 1)
         mw.setMethod(MuscleWrap.WrapMethod.midpoint);
      else if (methodInt == 2)
         mw.setMethod(MuscleWrap.WrapMethod.axial);
      setPendingChanges(true, false);
      setupComponent(act);
      Model model = asm.getModel();
      SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
      vis.updateActuatorGeometry(asm, true);
      ViewDB.getInstance().repaintAll();
   }

   private void MuscleTypeComboBoxActionPerformed(javax.swing.JComboBox muscleTypeComboBox) {
      //Property.PropertyType newType = (Property.PropertyType)muscleTypeComboBox.getSelectedIndex();
      int newType = muscleTypeComboBox.getSelectedIndex();
      Model model = act.getModel();
      SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(model);
      String newTypeName = guiElem.getActuatorClassNames()[newType];
      String oldTypeName = act.getType();
      if (newTypeName.equals(oldTypeName) == false) {
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
         // Store the display preference of the muscle before it is deleted.
         DisplayPreference dp = act.getDisplayer().getVisibleProperties().getDisplayPreference();
         vis.removeActuatorGeometry(act);
         act = model.getActuatorSet().changeActuatorType(act, newTypeName);
         // Set the display preference of the new muscle to the same as the old.
         act.getDisplayer().getVisibleProperties().setDisplayPreference(dp);
         setPendingChanges(true, false);
         setupComponent(act);
         // tell the ViewDB to redraw the model
         vis.addActuatorGeometry(act, true);
         ViewDB.getInstance().repaintAll();
      }
   }                                                  

   public void DoublePropertyEntered(javax.swing.JTextField field, int propertyNum) {
      Property prop = null;
      try {
         prop = act.getPropertySet().get(propertyNum);
      } catch (IOException ex) {
         ex.printStackTrace();
      }
      if (prop != null) {
         double oldValue = prop.getValueDbl();
         double newValue = Double.parseDouble(field.getText());
         if (newValue != oldValue) {
            prop.setValue(newValue);
            setPendingChanges(true, false);
            // TODO generate an event for this??
         }
      }
   }
   
   public void IntPropertyEntered(javax.swing.JTextField field, int propertyNum) {
      Property prop = null;
      try {
         prop = act.getPropertySet().get(propertyNum);
      } catch (IOException ex) {
         ex.printStackTrace();
      }
      if (prop != null) {
         int oldValue = prop.getValueInt();
         int newValue = Integer.parseInt(field.getText());
         if (newValue != oldValue) {
            prop.setValue(newValue);
            setPendingChanges(true, false);
            // TODO generate an event for this??
         }
      }
   }

   public void addAttachmentPerformed(int menuChoice) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      MusclePointSet musclePoints = asm.getAttachmentSet();
      int index = menuChoice;
      if (index > musclePoints.getSize() - 1)
         index = musclePoints.getSize() - 1;
      MusclePoint closestPoint = musclePoints.get(index);
      asm.addAttachmentPoint(menuChoice, closestPoint.getBody());
      setPendingChanges(true, false);
      setupComponent(act);
      Model model = asm.getModel();
      SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
      vis.updateActuatorGeometry(asm, true);
      ViewDB.getInstance().repaintAll();
   }

   public void deleteAttachmentPerformed(int menuChoice) {
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      boolean result = asm.deleteAttachmentPoint(menuChoice);
      if (result == false) {
         Object[] options = {"OK"};
         int answer = JOptionPane.showOptionDialog(this,
               "A muscle must contain at least 2 fixed attachment points.",
               "Muscle Editor",
               JOptionPane.OK_OPTION,
               JOptionPane.WARNING_MESSAGE,
               null,
               options,
               options[0]);
      } else {
         setPendingChanges(true, false);
         setupComponent(act);
         Model model = asm.getModel();
         SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(model);
         vis.updateActuatorGeometry(asm, true);
         ViewDB.getInstance().repaintAll();
      }
   }

   public void componentOpened() {
      /*
      Node[] selected = ExplorerTopComponent.findInstance().getExplorerManager().getSelectedNodes();
      OneActuatorNode muscleNode = (OneActuatorNode) selected[0];
      act = (AbstractActuator)muscleNode.getOpensimObject();
      actSaved = AbstractActuator.safeDownCast(act.copy());
      AttachmentsTab = null;
      WrapTab = null;
      CurrentPathTab = null;
      selectedTabName = null;
      setupComponent(act);
       **/
   }
   
   public void setupCurrentPathPanel(AbstractMuscle asm) {
      if (CurrentPathTab != null)
         ParametersTabbedPanel.remove(CurrentPathTab);
      CurrentPathTab = new javax.swing.JScrollPane();
      javax.swing.JPanel CurrentPathPanel = new javax.swing.JPanel();
      CurrentPathPanel.setLayout(null);
      CurrentPathPanel.setBackground(new java.awt.Color(200, 200, 255));
      CurrentPathTab.setViewportView(CurrentPathPanel);
      CurrentPathTab.setName("current path");
      ParametersTabbedPanel.insertTab("current path", null, CurrentPathTab, "current path of muscle", ParametersTabbedPanel.getTabCount());
      
      // Put the points in the current path in the CurrentPath tab
      ArrayMusclePoint asmp = asm.getCurrentPath();
      NumberFormat nf = NumberFormat.getInstance();
      nf.setMaximumFractionDigits(5); // TODO
      nf.setMinimumFractionDigits(5); // TODO
      int X = 30;
      int Y = 40;
      
      // Set up the muscle-independent labels
      javax.swing.JLabel currentPathXLabel = new javax.swing.JLabel();
      currentPathXLabel.setText("X");
      currentPathXLabel.setBounds(X + 20, Y - 30, 8, 16);
      javax.swing.JLabel currentPathYLabel = new javax.swing.JLabel();
      currentPathYLabel.setText("Y");
      currentPathYLabel.setBounds(X + 80, Y - 30, 8, 16);
      javax.swing.JLabel currentPathZLabel = new javax.swing.JLabel();
      currentPathZLabel.setText("Z");
      currentPathZLabel.setBounds(X + 140, Y - 30, 8, 16);
      javax.swing.JLabel currentPathBodyLabel = new javax.swing.JLabel();
      currentPathBodyLabel.setText("body");
      currentPathBodyLabel.setBounds(X + 210, Y - 30, 30, 16);
      javax.swing.JLabel currentPathSelLabel = new javax.swing.JLabel();
      currentPathSelLabel.setText("type");
      currentPathSelLabel.setBounds(X + 290, Y - 30, 30, 16);
      CurrentPathPanel.add(currentPathXLabel);
      CurrentPathPanel.add(currentPathYLabel);
      CurrentPathPanel.add(currentPathZLabel);
      CurrentPathPanel.add(currentPathBodyLabel);
      CurrentPathPanel.add(currentPathSelLabel);

      for (int i = 0; i < asmp.getSize(); i++) {
         boolean isWrapPoint = false;
         if (asmp.get(i).getWrapObject() != null)
            isWrapPoint = true;
         javax.swing.JLabel indexLabel = new javax.swing.JLabel();
         javax.swing.JLabel xField = new javax.swing.JLabel();
         javax.swing.JLabel yField = new javax.swing.JLabel();
         javax.swing.JLabel zField = new javax.swing.JLabel();
         javax.swing.JLabel bodyLabel = new javax.swing.JLabel();
         javax.swing.JLabel typeLabel = new javax.swing.JLabel();
         indexLabel.setText(String.valueOf(i+1) + ".");
         xField.setText(nf.format(asmp.get(i).getAttachment().getitem(0)));
         yField.setText(nf.format(asmp.get(i).getAttachment().getitem(1)));
         zField.setText(nf.format(asmp.get(i).getAttachment().getitem(2)));
         bodyLabel.setText(asmp.get(i).getBodyName());
         if (isWrapPoint)
            typeLabel.setText("wrap" + " (" + asmp.get(i).getWrapObject().getName() + ")");
         else {
            if (MuscleViaPoint.safeDownCast(asmp.get(i)) == null)
               typeLabel.setText("fixed");
            else
               typeLabel.setText("via");
         }
         int height = Y + i * 22;
         int width = 60;
         indexLabel.setBounds(X - 20, height, 20, 21);
         xField.setBounds(X, height, width, 21);
         yField.setBounds(X + width + 1, height, width, 21);
         zField.setBounds(X + 2*width + 2, height, width, 21);
         bodyLabel.setBounds(X + 3*width + 10, height, 90, 21);
         typeLabel.setBounds(X + 3*width + 110, height, 120, 21);
         CurrentPathPanel.add(indexLabel);
         CurrentPathPanel.add(xField);
         CurrentPathPanel.add(yField);
         CurrentPathPanel.add(zField);
         CurrentPathPanel.add(bodyLabel);
         CurrentPathPanel.add(typeLabel);
      }
      Dimension d = new Dimension(400, Y + asmp.getSize() * 22);
      CurrentPathPanel.setPreferredSize(d);
   }
   
   public void setupWrapPanel(AbstractMuscle asm) {
      if (WrapTab != null)
         ParametersTabbedPanel.remove(WrapTab);
      javax.swing.JScrollPane WrapTab = new javax.swing.JScrollPane();
      javax.swing.JPanel WrapPanel = new javax.swing.JPanel();
      WrapPanel.setLayout(null);
      WrapPanel.setBackground(new java.awt.Color(200, 200, 255));
      WrapTab.setViewportView(WrapPanel);
      WrapTab.setName("wrapping");
      ParametersTabbedPanel.insertTab("wrapping", null, WrapTab, "wrapping parameters", ParametersTabbedPanel.getTabCount());
      
      // Set up the Wrap Panel
      int i, j, k, wCount = 0;
      int numAttachments = asm.getAttachmentSet().getSize();
      int X = 30;
      int Y = 40;
      BodySet bodies = asm.getModel().getDynamicsEngine().getBodySet();
      
      SetMuscleWrap smw = asm.getWrapSet();
      String[] startPointNames = new String[numAttachments + 1];
      startPointNames[0] = new String("start");
      String[] endPointNames = new String[numAttachments + 1];
      endPointNames[numAttachments] = new String("end");
      for (i = 0; i < numAttachments; i++) {
         startPointNames[i+1] = String.valueOf(i+1);
         endPointNames[i] = String.valueOf(i+1);
      }

      // Count the number of wrap objects not currently assigned to this muscle.
      int numWrapObjects = 0;
      for (i = 0; i < bodies.getSize(); i++) {
         numWrapObjects += bodies.get(i).getWrapObjectSet().getSize();
      }
      numWrapObjects -= smw.getSize();

      // Create an array of names of all of the model's wrap objects
      // that are not currently assigned to this muscle. These will be
      // used to make a comboBox that appears when the user clicks the
      // "add" button.
      wrapObjectNames = new String[numWrapObjects];
      for (i = 0; i < bodies.getSize(); i++) {
         SetWrapObject wrapObjects = bodies.get(i).getWrapObjectSet();
         for (j = 0; j < wrapObjects.getSize(); j++) {
            for (k = 0; k < smw.getSize(); k++) {
               if (AbstractWrapObject.getCPtr(wrapObjects.get(j)) == AbstractWrapObject.getCPtr(smw.get(k).getWrapObject()))
                  break;
            }
            if (k == smw.getSize())
               wrapObjectNames[wCount++] = new String(wrapObjects.get(j).getName());
         }
      }
      
      // Set up the muscle-independent labels
      javax.swing.JLabel wrapObjectLabel = new javax.swing.JLabel();
      wrapObjectLabel.setText("object");
      wrapObjectLabel.setBounds(70, 10, 50, 16);
      WrapPanel.add(wrapObjectLabel);
      javax.swing.JLabel wrapMethodLabel = new javax.swing.JLabel();
      wrapMethodLabel.setText("method");
      wrapMethodLabel.setBounds(170, 10, 50, 16);
      WrapPanel.add(wrapMethodLabel);
      javax.swing.JLabel wrapStartLabel = new javax.swing.JLabel();
      wrapStartLabel.setText("start");
      wrapStartLabel.setBounds(260, 10, 40, 16);
      WrapPanel.add(wrapStartLabel);
      javax.swing.JLabel wrapEndLabel = new javax.swing.JLabel();
      wrapEndLabel.setText("end");
      wrapEndLabel.setBounds(320, 10, 30, 16);
      WrapPanel.add(wrapEndLabel);
      javax.swing.JLabel editLabel = new javax.swing.JLabel();
      editLabel.setText("edit");
      editLabel.setBounds(385, 10, 40, 16);
      WrapPanel.add(editLabel);

      for (i = 0; i < smw.getSize(); i++) {
         final int num = i;
         boolean isEllipsoid = false;
         AbstractWrapObject awo = smw.get(i).getWrapObject();
         WrapEllipsoid we = WrapEllipsoid.safeDownCast(awo);
         if (we != null)
            isEllipsoid = true;
         javax.swing.JLabel indexLabel = new javax.swing.JLabel();
         javax.swing.JComboBox methodComboBox = null;
         if (isEllipsoid == true)
            methodComboBox = new javax.swing.JComboBox();
         javax.swing.JComboBox startComboBox = new javax.swing.JComboBox();
         javax.swing.JComboBox endComboBox = new javax.swing.JComboBox();
         indexLabel.setText(String.valueOf(i+1) + ". " + awo.getName());
         if (isEllipsoid == true) {
            methodComboBox.setModel(new javax.swing.DefaultComboBoxModel(wrapMethodNames));
            methodComboBox.setSelectedIndex(findElement(wrapMethodNames, smw.get(i).getMethodName()));
            methodComboBox.addActionListener(new java.awt.event.ActionListener() {
               public void actionPerformed(java.awt.event.ActionEvent evt) {
                  setWrapMethod(((javax.swing.JComboBox)evt.getSource()), num);
               }
            });
         }
         
         startComboBox.setModel(new javax.swing.DefaultComboBoxModel(startPointNames));
         int start = smw.get(i).getStartPoint();
         if (start < 0)
            startComboBox.setSelectedIndex(0);
         else
            startComboBox.setSelectedIndex(findElement(startPointNames, String.valueOf(start)));
         startComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               setWrapStartRange(((javax.swing.JComboBox)evt.getSource()), num);
            }
         });

         endComboBox.setModel(new javax.swing.DefaultComboBoxModel(endPointNames));
         int end = smw.get(i).getEndPoint();
         if (end < 0)
            endComboBox.setSelectedIndex(endComboBox.getItemCount()-1);
         else
            endComboBox.setSelectedIndex(findElement(endPointNames, String.valueOf(end)));
         endComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               setWrapEndRange(((javax.swing.JComboBox)evt.getSource()), num);
            }
         });

         indexLabel.setBounds(X - 20, Y + i * 22, 200, 21);
         if (isEllipsoid == true)
            methodComboBox.setBounds(X + 130, Y + i * 22, 80, 21);
         startComboBox.setBounds(X + 220, Y + i * 22, 50, 21);
         endComboBox.setBounds(X + 280, Y + i * 22, 50, 21);
         WrapPanel.add(indexLabel);
         if (isEllipsoid == true)
            WrapPanel.add(methodComboBox);
         WrapPanel.add(startComboBox);
         WrapPanel.add(endComboBox);

         javax.swing.JButton upButton = new javax.swing.JButton();
         upButton.setIcon(new javax.swing.ImageIcon("upArrow.gif"));
         upButton.setBounds(X + 340, Y + 3 + i * 22, 15, 15);
         if (i > 0)
            upButton.setEnabled(true);
         else
            upButton.setEnabled(false);
         upButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               moveUpMuscleWrap(num);
            }
         });
         WrapPanel.add(upButton);

         javax.swing.JButton downButton = new javax.swing.JButton();
         downButton.setIcon(new javax.swing.ImageIcon("downArrow.gif"));
         downButton.setBounds(X + 360, Y + 3 + i * 22, 15, 15);
         if (smw.getSize() > 1 && i < smw.getSize() - 1)
            downButton.setEnabled(true);
         else
            downButton.setEnabled(false);
         downButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               moveDownMuscleWrap(num);
            }
         });
         WrapPanel.add(downButton);

         //C:\\SimTK\\OpenSim\\Applications\\Gui\\opensim\\view\\src\\org\\opensim\\view\\editors\\
         javax.swing.JButton deleteButton = new javax.swing.JButton();
         deleteButton.setIcon(new javax.swing.ImageIcon("close.gif"));
         deleteButton.setBounds(X + 380, Y + 3 + i * 22, 15, 15);
         deleteButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               deleteMuscleWrap(num);
            }
         });
         WrapPanel.add(deleteButton);
      }

      // The add menu
      final javax.swing.JPopupMenu addMenu = new javax.swing.JPopupMenu();
      for (i = 0; i < numWrapObjects; i++) {
         javax.swing.JMenuItem menuItem = new JMenuItem(wrapObjectNames[i]);
         final int index = i;
         menuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               addMuscleWrap(index);
            }
         });
         addMenu.add(menuItem);
      }

      // Add the "add" button
      javax.swing.JButton addButton = new javax.swing.JButton();
      addButton.setText("add");
      addButton.setToolTipText("add a wrap object to this muscle");
      addButton.setBounds(X + 100, Y + 20 + smw.getSize() * 22, 70, 21);
      WrapPanel.add(addButton);
      
      class PopupListener extends MouseAdapter {
         public void mousePressed(MouseEvent e) {
            //maybeShowPopup(e);
            addMenu.show(e.getComponent(),
                    e.getX(), e.getY());
         }
         
         public void mouseReleased(MouseEvent e) {
            maybeShowPopup(e);
         }
         
         private void maybeShowPopup(MouseEvent e) {
            if (e.isPopupTrigger()) {
               addMenu.show(e.getComponent(),
                       e.getX(), e.getY());
            }
         }
      }
      
      MouseListener popupListener = new PopupListener();
      addButton.addMouseListener(popupListener);
      
      Dimension d = new Dimension(350, Y + 20 + smw.getSize() * 22);
      WrapPanel.setPreferredSize(d);
   }
   
   public void setupAttachmentPanel(AbstractMuscle asm) {
      if (AttachmentsTab != null)
         ParametersTabbedPanel.remove(AttachmentsTab);
      AttachmentsTab = new javax.swing.JScrollPane();
      javax.swing.JPanel AttachmentsPanel = new javax.swing.JPanel();
      AttachmentsPanel.setLayout(null);
      AttachmentsPanel.setBackground(new java.awt.Color(200, 200, 255));
      AttachmentsTab.setViewportView(AttachmentsPanel);
      AttachmentsTab.setName("attachments");
      ParametersTabbedPanel.insertTab("attachments", null, AttachmentsTab, "attachment points", 0);
      
      // Put the attachment points in the attachments tab
      MusclePointSet musclePoints = asm.getAttachmentSet();
      int i, aCount = 0;
      int X = 30;
      int Y = 40;
      NumberFormat nf = NumberFormat.getInstance();
      nf.setMaximumFractionDigits(5); // TODO
      nf.setMinimumFractionDigits(5); // TODO
      
      // Set up the muscle-independent labels
      boolean anyViaPoints = false;
      javax.swing.JLabel attachmentXLabel = new javax.swing.JLabel();
      attachmentXLabel.setText("X");
      attachmentXLabel.setBounds(X + 20, Y - 30, 8, 16);
      javax.swing.JLabel attachmentYLabel = new javax.swing.JLabel();
      attachmentYLabel.setText("Y");
      attachmentYLabel.setBounds(X + 80, Y - 30, 8, 16);
      javax.swing.JLabel attachmentZLabel = new javax.swing.JLabel();
      attachmentZLabel.setText("Z");
      attachmentZLabel.setBounds(X + 140, Y - 30, 8, 16);
      javax.swing.JLabel attachmentBodyLabel = new javax.swing.JLabel();
      attachmentBodyLabel.setText("body");
      attachmentBodyLabel.setBounds(X + 210, Y - 30, 30, 16);
      javax.swing.JLabel attachmentSelLabel = new javax.swing.JLabel();
      attachmentSelLabel.setText("sel");
      attachmentSelLabel.setBounds(X + 290, Y - 30, 25, 16);
      javax.swing.JLabel coordLabel = new javax.swing.JLabel();
      coordLabel.setText("coordinate");
      coordLabel.setBounds(X + 360, Y - 30, 60, 16);
      javax.swing.JLabel rangeMinLabel = new javax.swing.JLabel();
      rangeMinLabel.setText("min");
      rangeMinLabel.setBounds(X + 480, Y - 30, 60, 16);
      javax.swing.JLabel rangeMaxLabel = new javax.swing.JLabel();
      rangeMaxLabel.setText("max");
      rangeMaxLabel.setBounds(X + 542, Y - 30, 60, 16);
      AttachmentsPanel.add(attachmentXLabel);
      AttachmentsPanel.add(attachmentYLabel);
      AttachmentsPanel.add(attachmentZLabel);
      AttachmentsPanel.add(attachmentBodyLabel);
      AttachmentsPanel.add(attachmentSelLabel);
      AttachmentsPanel.add(coordLabel);
      AttachmentsPanel.add(rangeMinLabel);
      AttachmentsPanel.add(rangeMaxLabel);
      
      attachmentSelectBox = new javax.swing.JCheckBox[musclePoints.getSize()];
      
      for (i = 0; i < musclePoints.getSize(); i++) {
         MuscleViaPoint via = MuscleViaPoint.safeDownCast(musclePoints.get(i));
         javax.swing.JLabel indexLabel = null;
         indexLabel = new javax.swing.JLabel();
         indexLabel.setText(String.valueOf(aCount+1) + ".");
         
         javax.swing.JTextField xField = new javax.swing.JTextField();
         javax.swing.JTextField yField = new javax.swing.JTextField();
         javax.swing.JTextField zField = new javax.swing.JTextField();
         javax.swing.JComboBox comboBox = new javax.swing.JComboBox();
         attachmentSelectBox[i] = new javax.swing.JCheckBox();
         javax.swing.JComboBox coordComboBox = null;
         javax.swing.JTextField rangeMinField = null;
         javax.swing.JTextField rangeMaxField = null;
         if (via != null) {
            anyViaPoints = true;
            coordComboBox = new javax.swing.JComboBox();
            rangeMinField = new javax.swing.JTextField();
            rangeMaxField = new javax.swing.JTextField();
         }
         
         int height = Y + i * 22;
         int width = 60;

         final int num = i;
         
         SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(asm.getModel());
         String[] bodyNames = guiElem.getBodyNames();
         comboBox.setModel(new javax.swing.DefaultComboBoxModel(bodyNames));
         comboBox.setSelectedIndex(findElement(bodyNames, musclePoints.get(i).getBodyName()));
         if (via != null) {
            String[] coordinateNames = guiElem.getCoordinateNames();
            coordComboBox.setModel(new javax.swing.DefaultComboBoxModel(coordinateNames));
            coordComboBox.setSelectedIndex(findElement(coordinateNames, via.getCoordinateName()));
            rangeMinField.setText(nf.format(via.getRange().getitem(0)));
            rangeMaxField.setText(nf.format(via.getRange().getitem(1)));
            coordComboBox.setBounds(X + 3*width + 140, height, 130, 21);
            rangeMinField.setBounds(X + 3*width + 280, height, 60, 21);
            rangeMaxField.setBounds(X + 3*width + 345, height, 60, 21);
            coordComboBox.addActionListener(new java.awt.event.ActionListener() {
               public void actionPerformed(java.awt.event.ActionEvent evt) {
                  ViaCoordinateChosen(((javax.swing.JComboBox)evt.getSource()), num);
               }
            });
            rangeMinField.addActionListener(new java.awt.event.ActionListener() {
               public void actionPerformed(java.awt.event.ActionEvent evt) {
                  RangeMinEntered(((javax.swing.JTextField)evt.getSource()), num);
               }
            });
            rangeMinField.addFocusListener(new java.awt.event.FocusAdapter() {
               public void focusLost(java.awt.event.FocusEvent evt) {
                  RangeMinEntered(((javax.swing.JTextField)evt.getSource()), num);
               }
            });
            rangeMaxField.addActionListener(new java.awt.event.ActionListener() {
               public void actionPerformed(java.awt.event.ActionEvent evt) {
                  RangeMaxEntered(((javax.swing.JTextField)evt.getSource()), num);
               }
            });
            rangeMaxField.addFocusListener(new java.awt.event.FocusAdapter() {
               public void focusLost(java.awt.event.FocusEvent evt) {
                  RangeMaxEntered(((javax.swing.JTextField)evt.getSource()), num);
               }
            });
         }
         
         indexLabel.setBounds(X - 20, height, 20, 21);
         xField.setBounds(X, height, width, 21);
         yField.setBounds(X + width + 1, height, width, 21);
         zField.setBounds(X + 2*width + 2, height, width, 21);
         comboBox.setBounds(X + 3*width + 10, height, 90, 21);
         attachmentSelectBox[i].setBounds(X + 3*width + 110, height, 21, 21);
         xField.setText(nf.format(musclePoints.get(i).getAttachment().getitem(0)));
         yField.setText(nf.format(musclePoints.get(i).getAttachment().getitem(1)));
         zField.setText(nf.format(musclePoints.get(i).getAttachment().getitem(2)));
         AttachmentsPanel.add(indexLabel);
         aCount++;
         
         xField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               AttachmentPointEntered(((javax.swing.JTextField)evt.getSource()), num, 0);
            }
         });
         xField.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
               AttachmentPointEntered(((javax.swing.JTextField)evt.getSource()), num, 0);
            }
         });
         yField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               AttachmentPointEntered(((javax.swing.JTextField)evt.getSource()), num, 1);
            }
         });
         yField.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
               AttachmentPointEntered(((javax.swing.JTextField)evt.getSource()), num, 1);
            }
         });
         zField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               AttachmentPointEntered(((javax.swing.JTextField)evt.getSource()), num, 2);
            }
         });
         zField.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
               AttachmentPointEntered(((javax.swing.JTextField)evt.getSource()), num, 2);
            }
         });
         comboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               AttachmentBodyChosen(((javax.swing.JComboBox)evt.getSource()), num);
            }
         });
         attachmentSelectBox[i].addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               AttachmentSelected(((javax.swing.JCheckBox)evt.getSource()), num);
            }
         });
         AttachmentsPanel.add(xField);
         AttachmentsPanel.add(yField);
         AttachmentsPanel.add(zField);
         AttachmentsPanel.add(comboBox);
         AttachmentsPanel.add(attachmentSelectBox[i]);
         if (via != null) {
            AttachmentsPanel.add(coordComboBox);
            AttachmentsPanel.add(rangeMinField);
            AttachmentsPanel.add(rangeMaxField);
         }
      }
      
      // The add menu
      final javax.swing.JPopupMenu addMenu = new javax.swing.JPopupMenu();
      javax.swing.JMenuItem firstMenuItem = new JMenuItem("before 1");
      firstMenuItem.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            addAttachmentPerformed(0);
         }
      });
      addMenu.add(firstMenuItem);
      for (i = 0; i < musclePoints.getSize() - 1; i++) {
         javax.swing.JMenuItem menuItem = new JMenuItem("between "+String.valueOf(i+1)+" and "+String.valueOf(i+2));
         final int index = i + 1;
         menuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               addAttachmentPerformed(index);
            }
         });
         addMenu.add(menuItem);
      }
      javax.swing.JMenuItem lastMenuItem = new JMenuItem("after "+String.valueOf(musclePoints.getSize()));
      final int index = musclePoints.getSize();
      lastMenuItem.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            addAttachmentPerformed(index);
         }
      });
      addMenu.add(lastMenuItem);
      
      // Add the "add" button
      javax.swing.JButton addButton = new javax.swing.JButton();
      addButton.setText("add");
      addButton.setToolTipText("add an attachment point");
      addButton.setBounds(X + 100, Y + 20 + musclePoints.getSize() * 22, 70, 21);
      AttachmentsPanel.add(addButton);
      
      class PopupListener extends MouseAdapter {
         public void mousePressed(MouseEvent e) {
            //maybeShowPopup(e);
            addMenu.show(e.getComponent(),
                    e.getX(), e.getY());
         }
         
         public void mouseReleased(MouseEvent e) {
            maybeShowPopup(e);
         }
         
         private void maybeShowPopup(MouseEvent e) {
            if (e.isPopupTrigger()) {
               addMenu.show(e.getComponent(),
                       e.getX(), e.getY());
            }
         }
      }
      
      MouseListener popupListener = new PopupListener();
      addButton.addMouseListener(popupListener);
      
      // the "delete" menu
      final javax.swing.JPopupMenu deleteMenu = new javax.swing.JPopupMenu();
      for (i = 0; i < musclePoints.getSize(); i++) {
         javax.swing.JMenuItem menuItem = new JMenuItem(String.valueOf(i+1));
         final int deleteIndex = i;
         menuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
               deleteAttachmentPerformed(deleteIndex);
            }
         });
         deleteMenu.add(menuItem);
      }
      
      // Add the "delete" button
      javax.swing.JButton deleteButton = new javax.swing.JButton();
      deleteButton.setText("delete");
      deleteButton.setToolTipText("delete an attachment point");
      deleteButton.setBounds(X + 200, Y + 20 + musclePoints.getSize() * 22, 70, 21);
      AttachmentsPanel.add(deleteButton);
      
      class PopupListenerDelete extends MouseAdapter {
         public void mousePressed(MouseEvent e) {
            //maybeShowPopup(e);
            deleteMenu.show(e.getComponent(),
                    e.getX(), e.getY());
         }
         
         public void mouseReleased(MouseEvent e) {
            maybeShowPopup(e);
         }
         
         private void maybeShowPopup(MouseEvent e) {
            if (e.isPopupTrigger()) {
               deleteMenu.show(e.getComponent(),
                       e.getX(), e.getY());
            }
         }
      }
      
      MouseListener popupListenerDelete = new PopupListenerDelete();
      deleteButton.addMouseListener(popupListenerDelete);
      
      Dimension d = new Dimension(350, Y + 45 + musclePoints.getSize() * 22);
      if (anyViaPoints)
         d.width = 630;
      AttachmentsPanel.setPreferredSize(d);

      // Update the checked/unchecked state of the selected checkboxes
      ArrayList<SelectedObject> selectedObjects = ViewDB.getInstance().getSelectedObjects();
      for (i = 0; i < selectedObjects.size(); i++)
         updateAttachmentSelections(selectedObjects.get(i), true);
   }
   
   public void setupComponent(AbstractActuator act) {
      // Remove all previous GUI components and their panels.
      // If the type of actuator changed since the last time
      // the panels were set up, there could be different
      // numbers and types of components and panels.
      // But before they are removed, store the name of the
      // currently selected tab (if any) so that you can try
      // to restore this selection (e.g., after the "reset"
      // button is pressed.
      if (act != null) {
         Component comp = ParametersTabbedPanel.getSelectedComponent();
         if (comp != null)
            selectedTabName = comp.getName();
         else
            selectedTabName = null;
      }
      ParametersTabbedPanel.removeAll();
      AttachmentsTab = null;
      WrapTab = null;
      CurrentPathTab = null;

      Model currentModel = OpenSimDB.getInstance().getCurrentModel();
      if (currentModel != null) {
         ModelNameLabel.setText("Model: " + currentModel.getName());
      } else {
         ModelNameLabel.setText("Model: No current model");
         MuscleNameTextField.setText("");
         MuscleNameTextField.setEnabled(false);
         MuscleTypeComboBox.setEnabled(false);
         ApplyButton.setEnabled(false);
         ResetButton.setEnabled(false);
         return;
      }

      if (act == null) {
         return;
      } else {
         MuscleNameTextField.setEnabled(true);
         MuscleTypeComboBox.setEnabled(true);
         ApplyButton.setEnabled(true);
      }

      SingleModelGuiElements guiElem = ViewDB.getInstance().getModelGuiElements(act.getModel());
      MuscleTypeComboBox.setModel(new javax.swing.DefaultComboBoxModel(guiElem.getActuatorClassNames()));
      MuscleTypeComboBox.setSelectedIndex(findElement(guiElem.getActuatorClassNames(), act.getType()));
      MuscleTypeComboBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            MuscleTypeComboBoxActionPerformed(MuscleTypeComboBox);
         }
      });

      // Add the attachment panel first so it will always have index=0
      AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
      if (asm != null)
         setupAttachmentPanel(asm);
      
      int i, j;
      NumberFormat nf = NumberFormat.getInstance();
      nf.setMaximumFractionDigits(5); // TODO
      nf.setMinimumFractionDigits(5); // TODO
      MuscleNameTextField.setText(act.getName());
      PropertySet ps = act.getPropertySet();
      
      // Create the panels to hold the properties.
      ArrayPtrsPropertyGroup groups = ps.getGroups();
      int numGroups = groups.getSize();
      javax.swing.JScrollPane propTab[] = new javax.swing.JScrollPane[numGroups + 1];
      javax.swing.JPanel propPanel[] = new javax.swing.JPanel[numGroups + 1];
      int tabPropertyCount[] = new int[numGroups + 1];
      for (i = 0; i < numGroups; i++) {
         PropertyGroup pg = groups.get(i);
         propTab[i] = new javax.swing.JScrollPane();
         propPanel[i] = new javax.swing.JPanel();
         propPanel[i].setLayout(null);
         propPanel[i].setBackground(new java.awt.Color(200, 200, 255));
         propTab[i].setViewportView(propPanel[i]);
         propTab[i].setName(pg.getName());
         ParametersTabbedPanel.addTab(pg.getName(), null, propTab[i], pg.getName()+" parameters");
         tabPropertyCount[i] = 0;
      }
      // Create the "other" panel to hold properties that are not in a group.
      propTab[numGroups] = new javax.swing.JScrollPane();
      propPanel[numGroups] = new javax.swing.JPanel();
      propPanel[numGroups].setLayout(null);
      propPanel[numGroups].setBackground(new java.awt.Color(200, 200, 255));
      propTab[numGroups].setViewportView(propPanel[numGroups]);
      propTab[numGroups].setName("other");
      ParametersTabbedPanel.addTab("other", null, propTab[numGroups], "other parameters");
      tabPropertyCount[numGroups] = 0;
      
      // Loop through the properties, adding each one to the appropriate panel.
      for (i = 0; i < ps.getSize(); i++) {
         Property p;
         try {
            p = ps.get(i);
            int groupNum = ps.getGroupIndexContaining(p);
            if (groupNum < 0)
               groupNum = numGroups; // this is the index of the "other" panel
            if (p.getType() == org.opensim.modeling.Property.PropertyType.Dbl ||
                    p.getType() == org.opensim.modeling.Property.PropertyType.Int) {
               javax.swing.JLabel propLabel = new javax.swing.JLabel();
               propLabel.setText(p.getName());
               propLabel.setHorizontalAlignment(SwingConstants.RIGHT);
               propLabel.setBounds(20, 22 + tabPropertyCount[groupNum] * 22, 180, 16);
               propLabel.setToolTipText(p.getComment());
               javax.swing.JTextField propField = new javax.swing.JTextField();
               propField.setBounds(210, 20 + tabPropertyCount[groupNum] * 22, 120, 21);
               propField.setText(p.toString());
               propField.setToolTipText(p.getComment());
               propPanel[groupNum].add(propLabel);
               propPanel[groupNum].add(propField);
               tabPropertyCount[groupNum]++;
               final int num = i;
               if (p.getType() == org.opensim.modeling.Property.PropertyType.Dbl) {
                  propField.addActionListener(new java.awt.event.ActionListener() {
                     public void actionPerformed(java.awt.event.ActionEvent evt) {
                        DoublePropertyEntered(((javax.swing.JTextField)evt.getSource()), num);
                     }
                  });
                  propField.addFocusListener(new java.awt.event.FocusAdapter() {
                     public void focusLost(java.awt.event.FocusEvent evt) {
                        DoublePropertyEntered(((javax.swing.JTextField)evt.getSource()), num);
                     }
                  });
               } else if (p.getType() == org.opensim.modeling.Property.PropertyType.Int) {
                  propField.addActionListener(new java.awt.event.ActionListener() {
                     public void actionPerformed(java.awt.event.ActionEvent evt) {
                        IntPropertyEntered(((javax.swing.JTextField)evt.getSource()), num);
                     }
                  });
                  propField.addFocusListener(new java.awt.event.FocusAdapter() {
                     public void focusLost(java.awt.event.FocusEvent evt) {
                        IntPropertyEntered(((javax.swing.JTextField)evt.getSource()), num);
                     }
                  });
               }
            } else if (p.getType() == org.opensim.modeling.Property.PropertyType.ObjPtr) {
               OpenSimObject obj = p.getValueObjPtr();
               Function func = Function.safeDownCast(obj);
               if (func != null) {
                  javax.swing.JLabel propLabel = new javax.swing.JLabel();
                  propLabel.setText(p.getName());
                  propLabel.setHorizontalAlignment(SwingConstants.RIGHT);
                  propLabel.setBounds(20, 22 + tabPropertyCount[groupNum] * 22, 200, 16);
                  propLabel.setToolTipText(p.getComment());
                  javax.swing.JButton propButton = new javax.swing.JButton();
                  propButton.setBounds(230, 20 + tabPropertyCount[groupNum] * 22, 60, 21);
                  propButton.setText("edit");
                  propPanel[groupNum].add(propLabel);
                  propPanel[groupNum].add(propButton);
                  tabPropertyCount[groupNum]++;
               }
            }
         } catch (IOException ex) {
            ex.printStackTrace();
         }
      }
      
      // Set the preferred sizes of the property tabs.
      // If any of them have no properties, remove them
      // from the window.
      for (i = 0; i <= numGroups; i++) {
         if (tabPropertyCount[i] == 0) {
            ParametersTabbedPanel.remove(propTab[i]);
         } else {
            Dimension d = new Dimension(350, 30 + tabPropertyCount[i] * 22);
            propPanel[i].setPreferredSize(d);
         }
      }
      
      // Add the wrap and current panels last
      if (asm != null) {
         setupWrapPanel(asm);
         setupCurrentPathPanel(asm);
      }

      // Gray out the reset button if there are no pending changes
      ResetButton.setEnabled(pendingChanges);

      // Set the selected tab in the ParametersTabbedPanel to the
      // one whose name matches selectedTabName.
      Component[] components = ParametersTabbedPanel.getComponents();
      if (selectedTabName == null) {
         ParametersTabbedPanel.setSelectedComponent(components[0]);
      } else {
         for (i = 0; i < components.length; i++) {
            if (components[i].getName().equals(selectedTabName)) {
               ParametersTabbedPanel.setSelectedComponent(components[i]);
               break;
            }
         }
      }
      
      //Dimension windowSize = MuscleEditorScrollPane.getParent().getSize();
      Dimension d = new Dimension(495, 358);
      MuscleEditorPanel.setPreferredSize(d);
      
      this.revalidate();
      this.repaint();
   }
   
   public void componentClosed() {
      // TODO add custom code on component closing
   }
   
   /** replaces this in object stream */
   public Object writeReplace() {
      return new ResolvableHelper();
   }
   
   protected String preferredID() {
      return PREFERRED_ID;
   }
   
   private int findElement(String[] nameList, String name) {
      int i;
      for (i = 0; i < nameList.length; i++)
         if (nameList[i].equals(name))
            return i;
      return -1;
   }
   
   public void open() {
      Mode mode=WindowManager.getDefault().findMode(s_mode);
      //boolean docked = mode.dockInto(this);
      Node[] selected = ExplorerTopComponent.findInstance().getExplorerManager().getSelectedNodes();
      OneActuatorNode muscleNode = (OneActuatorNode) selected[0];
      AbstractActuator newAct = AbstractActuator.safeDownCast(muscleNode.getOpenSimObject());
      if (newAct != null && newAct != act) {
         boolean switchMuscles = false;
         if (pendingChanges == false) {
            switchMuscles = true;
         } else {
            Object[] options = {"Yes", "No", "Cancel"};
            int answer = JOptionPane.showOptionDialog(this,
               "Do you want to save the changes you made to " + act.getName() + "?",
               "Muscle Editor",
               JOptionPane.YES_NO_CANCEL_OPTION,
               JOptionPane.WARNING_MESSAGE,
               null,
               options,
               options[2]);
            if (answer == 0) {
               saveActuator();
               switchMuscles = true;
            } else if (answer == 1) {
               resetActuator();
               switchMuscles = true;
            } else if (answer == 2) {
               switchMuscles = false;
            }
         }
         if (switchMuscles == true) {
            act = newAct;
            actSaved = AbstractActuator.safeDownCast(act.copy());
            AttachmentsTab = null;
            WrapTab = null;
            CurrentPathTab = null;
            selectedTabName = null;
            setupComponent(act);
         }
      }
      super.open();
      this.requestActive();
   }
   
   // Observable is ViewDB
   public void update(Observable o, Object arg) {
      if (o instanceof ViewDB) {
         if (arg instanceof ObjectSelectedEvent) {
            ObjectSelectedEvent ev = (ObjectSelectedEvent)arg;
            updateAttachmentSelections(ev.getSelectedObject(), ev.getState());
         } else if (arg instanceof ClearSelectedObjectsEvent) {
            if (act != null) {
               AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
               if (asm != null) {
                  MusclePointSet musclePoints = asm.getAttachmentSet();
                  for (int i = 0; i < musclePoints.getSize(); i++) {
                     attachmentSelectBox[i].setSelected(false);
                  }
                  this.repaint();
               }
            }
         } else if (arg instanceof DragObjectsEvent) {
            dragMusclePoints((DragObjectsEvent)arg);
         }
      } else if (o instanceof OpenSimDB) {
         // if current model is being switched due to open/close or change current then
         // update tool window
         if (arg instanceof ModelEvent) {
            final ModelEvent evt = (ModelEvent)arg;
            if (evt.getOperation() == ModelEvent.Operation.SetCurrent ||
               (evt.getOperation() == ModelEvent.Operation.Close &&
               OpenSimDB.getInstance().getCurrentModel() == null)) {
               setupComponent(null);
            }
            // Do we need to handle close separately or should we be called with SetCurrent of null model?
         }
      }
   }
   
   private void updateAttachmentSelections(SelectedObject selectedObject, boolean state) {
      OpenSimObject obj = selectedObject.getOpenSimObject();
      if (act != null) {
         AbstractMuscle asm = AbstractMuscle.safeDownCast(act);
         if (asm != null) {
            MusclePointSet musclePoints = asm.getAttachmentSet();
            for (int i = 0; i < musclePoints.getSize(); i++) {
               if (OpenSimObject.getCPtr(obj) == MusclePoint.getCPtr(musclePoints.get(i))) {
                  attachmentSelectBox[i].setSelected(state);
                  this.repaint();
                  break;
               }
            }
         }
      }
   }

   private void dragMusclePoints(DragObjectsEvent ev) {
      ArrayList<SelectedObject> selectedObjects = ViewDB.getInstance().getSelectedObjects();
      AbstractMuscle m = null;
      for (int i = 0; i < selectedObjects.size(); i++) {
         OpenSimObject obj = selectedObjects.get(i).getOpenSimObject();
         MusclePoint mp = MusclePoint.safeDownCast(obj);
         if (mp != null) {
            AbstractDynamicsEngine engine = mp.getMuscle().getModel().getDynamicsEngine();
            AbstractBody body = mp.getBody();
            AbstractBody ground = engine.getGroundBody();
            double dragVectorBody[] = new double[3];
            engine.transform(ground, ev.getDragVector(), body, dragVectorBody);
            //System.out.println("drag: " + ev.getDragVector()[0] + " " + ev.getDragVector()[1] + " " + ev.getDragVector()[2]);
            mp.setAttachment(0, mp.getAttachment().getitem(0) + dragVectorBody[0]);
            mp.setAttachment(1, mp.getAttachment().getitem(1) + dragVectorBody[1]);
            mp.setAttachment(2, mp.getAttachment().getitem(2) + dragVectorBody[2]);
            // tell the ViewDB to redraw the model
            m = mp.getMuscle();
            SingleModelVisuals vis = ViewDB.getInstance().getModelVisuals(m.getModel());
            vis.updateActuatorGeometry(m, true);
            ViewDB.getInstance().repaintAll();
            // update the panels
            //setupComponent(m);
         }
      }
      // If m is not null, then at least one selected object is a muscle point
      // (that was just dragged). So redraw the model.
      if (m != null) {
         setPendingChanges(true, false);
         ViewDB.getInstance().repaintAll();
      }
   }

   final static class ResolvableHelper implements Serializable {
      private static final long serialVersionUID = 1L;
      public Object readResolve() {
         return MuscleEditorTopComponent.getDefault();
      }
   }
   
}
