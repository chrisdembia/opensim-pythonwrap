/*******************************************************************************

   SDUFUNCS.C

   Authors: Peter Loan
            Krystyne Blaikie

   Copyright (c) 1996-2004 MusculoGraphics, a division of Motion Analysis Corp.
   All rights reserved.

   Description: This file contains the main routine for a dynamics
		simulation, and several other utility functions that are
		independent of the musculoskeletal model in the simulation.
		This file is generated by SIMM when you choose the
		"project files" option in the "Save Dynamics" dialog box.
		You will probably want to generate it once and then customize
		it to your specific simulation.

*******************************************************************************/
#include "sdfast.h"
#include <cassert>
#include <OpenSim/Common/SimmMacros.h>
#include <OpenSim/DynamicsEngines/SdfastEngine/SdfastEngine.h>
#include <iostream>

#define STRLEN(p) (strlen(p)+1)

#define SDFAST_DLL_API __declspec(dllexport)

using namespace OpenSim;
using namespace std;

// This is a back-pointer to the engine that has linked to these sdfast functions.  It can be used for callbacks.
SdfastEngine *engine = NULL;

extern "C" {
#include "universal.h"

// function prototype
void sdstab(double velin,double posin);

/*************** STATIC GLOBAL VARIABLES (for this file only) *****************/
dpModelStruct sdm;

/**************** GLOBAL VARIABLES (used in only a few files) *****************/

/*************** EXTERNED VARIABLES (declared in another file) ****************/

/*************** PROTOTYPES for STATIC FUNCTIONS (for this file only) *********/

SDFAST_DLL_API void setSdfastEngineInstance(SdfastEngine *aEngine)
{
	//std::cout << "Setting sdfast engine to " << aEngine << std::endl;
	engine = aEngine;
}	


int sduforce(double t, double q[], double u[])
{
	// THIS IS NOT CALLED IN OUR PIPELINE
	assert(false);
   return 1;
}

/* Apply prescribed motions to fixed and prescribed gencoords */
int sdumotion(double t, double q[], double u[])
{
   set_fixed_gencoords();

	set_prescribed_gencoords(t, q, u, 0);

   return 1;
}


/* calculate position errors for constrained gencoords */
void sduperr(double t, double q[], double errors[])
{
   int i;
   double q_ind_value, q_dep_value, q_value, u_ind_value = 0.0, a_ind_value = 0.0;

   /* constrained gencoords */
   for (i=0; i<sdm.nq; i++)
   {
      if (sdm.q[i].type == dpConstrainedQ)
      {
         q_ind_value = q[sdm.q[i].q_ind];
         q_dep_value = q[i];
         q_value = interpolate_spline(q_ind_value, sdm.q[i].constraint_func,
            zeroth, u_ind_value, a_ind_value);
         errors[sdm.q[i].constraint_num] = q_dep_value - q_value;
      }
   }

#if 0
   /* constraint objects */
   if (sdm.enforce_constraints == 1)
   {
      for (i = 0; i < sdm.num_constraint_objects; i++)
      {
         dpConstraintObject *co = &sdm.constraint_object[i];
         if (co->active == dpNo)
            continue;
         for (int j = 0; j < co->numPoints; j++)
         {
            int constraint_num = co->points[j].constraint_num;
            errors[constraint_num] = calculate_constraint_position_error(co, PERR, j);
         }
      }
   }
#endif
}


/* calculate velocity errors for constrained gencoords */
void sduverr(double t, double q[], double u[], double errors[])
{
   int i, q_ind;
   double q_ind_value, u_ind_value, u_dep_value, a_ind_value = 0.0, v_value;

   /* constrained gencoords */
   for (i=0; i<sdm.nq; i++)
   {
      if (sdm.q[i].type == dpConstrainedQ)
      {
         q_ind = sdm.q[i].q_ind;
         q_ind_value = q[q_ind];
         u_ind_value = u[q_ind];
         u_dep_value = u[i];
         v_value = interpolate_spline(q_ind_value, sdm.q[i].constraint_func,
            first, u_ind_value, a_ind_value);
         errors[sdm.q[i].constraint_num] = u_dep_value - v_value;
      }
   }

#if 0
   /* constraint objects */
   if (sdm.enforce_constraints == 1)
   {
      for (i = 0; i < sdm.num_constraint_objects; i++)
      {
         dpConstraintObject *co = &sdm.constraint_object[i];
         if (co->active == dpNo)
            continue;

         for (int j = 0; j < co->numPoints; j++)
         {
            int constraint_num = co->points[j].constraint_num;
            errors[constraint_num] = calculate_constraint_velocity_error(co, j);
         }
      }
   }
#endif
}



/* calculate acceleration errors for constrained gencoords */
void sduaerr(double t, double q[], double u[], double udot[], double errors[])
{
   int i, q_ind;
   double q_ind_value, u_ind_value, a_ind_value, a_dep_value;
   double a_value;

   /* constrained gencoords */
   for (i=0; i<sdm.nq; i++)
   {
      if (sdm.q[i].type == dpConstrainedQ)
      {
	      q_ind = sdm.q[i].q_ind;
	      q_ind_value = q[q_ind];
	      u_ind_value = u[q_ind];
	      a_ind_value = udot[q_ind];
	      a_dep_value = udot[i];
         a_value = interpolate_spline(q_ind_value, sdm.q[i].constraint_func, second,
            u_ind_value, a_ind_value);
         errors[sdm.q[i].constraint_num] = a_dep_value - a_value;
      }
   }

#if 0
   /* constraint objects */
   if (sdm.enforce_constraints == 1)
   {
      for (i = 0; i < sdm.num_constraint_objects; i++)
      {
         dpConstraintObject *co = &sdm.constraint_object[i];
         if (co->active == dpNo)
            continue;

         for (int j = 0; j < co->numPoints; j++)
         {
            int constraint_num = co->points[j].constraint_num;
            errors[constraint_num] = calculate_constraint_acceleration_error(co, j);
         }
      }
   }
#endif
}


/* calculate and apply constraint forces for constrained gencoords */
void sduconsfrc(double t, double q[], double u[], double mults[])
{
   int i, q_ind;
   double q_ind_value, torque, u_ind_value = 1.0, a_ind_value = 0.0, int_spline;
 
   for (i=0; i<sdm.nq; i++)
   {
      if (sdm.q[i].type == dpConstrainedQ)
      {
         q_ind = sdm.q[i].q_ind;
         q_ind_value = q[q_ind];

	      sdhinget(sdm.q[i].joint, sdm.q[i].axis, mults[sdm.q[i].constraint_num]);

         int_spline = interpolate_spline(q_ind_value, sdm.q[i].constraint_func,
            first, u_ind_value, a_ind_value);
         torque = -mults[sdm.q[i].constraint_num] * int_spline;

         sdhinget(sdm.q[q_ind].joint,sdm.q[q_ind].axis,torque);
      }
   }

#if 0
   /* constraint objects */
   for (i = 0; i < sdm.num_constraint_objects; i++)
   {
      dpConstraintObject *co = &sdm.constraint_object[i];
      if (co->active == dpNo)
         continue;

      for (int j = 0; j < co->numPoints; j++)
      {
         int constraint_num = co->points[j].constraint_num;
         apply_constraint_forces(co, mults[constraint_num], j);
      }
   }
#endif

   check_for_sderror("SDUCONSFRC");
}

/************* Initialization Routines **************/


/* SET_FIXED_GENCOORDS: This routine prescribes the position, velocity, and
 * acceleration of the fixed gencoords in the model. Fixed gencorods are
 * used to implement joints in SD/FAST that should be fixed, but cannot be
 * modeled that way. Instead, a fixed joint is modeled as a pin joint whose
 * motion is prescribed to be zero.
 */
void set_fixed_gencoords()
{
   int i;

   /* for all fixed gencoords:
    *   pos = initial value
    *   vel = 0.0
    *   acc = 0.0
    */
   for (i = 0; i < sdm.nq; i++)
   {
      if (sdm.q[i].type == dpFixedQ)
      {
         sdprespos(sdm.q[i].joint, sdm.q[i].axis, sdm.q[i].initial_value);
         sdpresvel(sdm.q[i].joint, sdm.q[i].axis, 0.0);
         sdpresacc(sdm.q[i].joint, sdm.q[i].axis, 0.0);
      }
   }
}

/* SET_PRESCRIBED_GENCOORDS: This routine prescribes the position, velocity, and
 * acceleration of the prescribed gencoords in the model, using data from the kinetics
 * file. Position data must be explicitly specified (though it can be splined or not).
 * Velocity can either be specified explicitly, or calculated from position (if position
 * data is splined). Acceleration can be specified explicitly or calculated from position
 * or velocity.
 */
void set_prescribed_gencoords(double time, double q[], double u[], MotionData* data)
{
   int i;
   double Q, U, A;

   /* set the position, velocity, and acceleration for all prescribed gencoords */
   for (i = 0; i < sdm.nq; i++)
   {
      if (sdm.q[i].type == dpPrescribedQ)
      {
         if (data && data->q_data[i])
         {
            Q = interpolate_spline(time, data->q_data[i], zeroth, 0.0, 0.0);

            if (data->u_data[i])
               U = interpolate_spline(time, data->u_data[i], zeroth, 1.0, 0.0);
            else if (data->q_data[i]->type != dpStepFunction)
               U = interpolate_spline(time, data->q_data[i], first, 1.0, 0.0);
            else
               U = 0.0;

            if (data->udot_data[i])
               A = interpolate_spline(time, data->udot_data[i], zeroth, 1.0, 0.0);
            else if (data->u_data[i] && data->u_data[i]->type != dpStepFunction)
               A = interpolate_spline(time, data->u_data[i], first, 1.0, 0.0);
            else if (data->q_data[i]->type != dpStepFunction)
               A = interpolate_spline(time, data->q_data[i], second, 1.0, 0.0);
            else
               A = 0.0;

            sdprespos(sdm.q[i].joint, sdm.q[i].axis, Q);
            sdpresvel(sdm.q[i].joint, sdm.q[i].axis, U);
            sdpresacc(sdm.q[i].joint, sdm.q[i].axis, A);
         }
         else
         {
            /* If the Q is prescribed but there is no data for it in the kinetics
             * file, then prescribe it to remain fixed at its initial value. This
             * is the mechanism used to handle Qs which are locked in SIMM.
             */
            sdprespos(sdm.q[i].joint, sdm.q[i].axis, sdm.q[i].initial_value);
            sdpresvel(sdm.q[i].joint, sdm.q[i].axis, 0.0);
            sdpresacc(sdm.q[i].joint, sdm.q[i].axis, 0.0);
         }
      }
   }

   check_for_sderror("SDUMOTION");
}

/* CALC_SPLINE_COEEFICIENTS: this routine takes an array of x and y values,
 * and computes the coefficients of natural splines which interpolate the data.
 * The code is translated from a Fortran version printed in "Computer
 * Methods for Mathematical Computations" by Forsythe, Malcolm, and
 * Moler, pp 77-8. To better handle splines which have two or more control points
 * with the same X values, checks were added to make sure that the code never
 * divides by zero.
 */
void calc_spline_coefficients(dpSplineFunction* f)
{
   int nm1, nm2, i, j;
   double t;

   if (f->numpoints < 2)
   {
      f->type = dpStepFunction;
      return;
   }

   if (f->numpoints == 2)
   {
      t = MAX(TINY_NUMBER,f->x[1]-f->x[0]);
      f->b[0] = f->b[1] = (f->y[1]-f->y[0])/t;
      f->c[0] = f->c[1] = 0.0;
      f->d[0] = f->d[1] = 0.0;
      return;
   }

   nm1 = f->numpoints - 1;
   nm2 = f->numpoints - 2;

   /* Set up tridiagonal system:
    * b = diagonal, d = offdiagonal, c = right-hand side
    */

   f->d[0] = MAX(TINY_NUMBER,f->x[1] - f->x[0]);
   f->c[1] = (f->y[1]-f->y[0])/f->d[0];
   for (i=1; i<nm1; i++)
   {
      f->d[i] = MAX(TINY_NUMBER,f->x[i+1] - f->x[i]);
      f->b[i] = 2.0*(f->d[i-1]+f->d[i]);
      f->c[i+1] = (f->y[i+1]-f->y[i])/f->d[i];
      f->c[i] = f->c[i+1] - f->c[i];
   }

   /* End conditions. Third derivatives at x[0] and x[n-1]
    * are obtained from divided differences.
    */

   f->b[0] = -f->d[0];
   f->b[nm1] = -f->d[nm2];
   f->c[0] = 0.0;
   f->c[nm1] = 0.0;

   if (f->numpoints > 3)
   {
      double d1, d2, d3, d20, d30, d31;

      d31 = MAX(TINY_NUMBER,f->x[3] - f->x[1]);
      d20 = MAX(TINY_NUMBER,f->x[2] - f->x[0]);
      d1 = MAX(TINY_NUMBER,f->x[nm1]-f->x[f->numpoints-3]);
      d2 = MAX(TINY_NUMBER,f->x[nm2]-f->x[f->numpoints-4]);
      d30 = MAX(TINY_NUMBER,f->x[3] - f->x[0]);
      d3 = MAX(TINY_NUMBER,f->x[nm1]-f->x[f->numpoints-4]);
      f->c[0] = f->c[2]/d31 - f->c[1]/d20;
      f->c[nm1] = f->c[nm2]/d1 - f->c[f->numpoints-3]/d2;
      f->c[0] = f->c[0]*f->d[0]*f->d[0]/d30;
      f->c[nm1] = -f->c[nm1]*f->d[nm2]*f->d[nm2]/d3;
   }

   /* Forward elimination */

   for (i=1; i<f->numpoints; i++)
   {
      t = f->d[i-1]/f->b[i-1];
      f->b[i] -= t*f->d[i-1];
      f->c[i] -= t*f->c[i-1];
   }

   /* Back substitution */

   f->c[nm1] /= f->b[nm1];
   for (j=0; j<nm1; j++)
   {
      i = nm2 - j;
      f->c[i] = (f->c[i]-f->d[i]*f->c[i+1])/f->b[i];
   }

   /* compute polynomial coefficients */

   f->b[nm1] = (f->y[nm1]-f->y[nm2])/f->d[nm2] +
               f->d[nm2]*(f->c[nm2]+2.0*f->c[nm1]);
   for (i=0; i<nm1; i++)
   {
      f->b[i] = (f->y[i+1]-f->y[i])/f->d[i] - f->d[i]*(f->c[i+1]+2.0*f->c[i]);
      f->d[i] = (f->c[i+1]-f->c[i])/f->d[i];
      f->c[i] *= 3.0;
   }
   f->c[nm1] *= 3.0;
   f->d[nm1] = f->d[nm2];
}

/* INTERPOLATE_SPLINE: given a spline function and an x-value, this routine
 * finds the corresponding y-value by interpolating the spline. It
 * can return the zeroth, first, or second derivative of the spline
 * at that x-value. Interpolation can be done with one of three methods:
 * step_function (zero-order hold), natural_cubic (3rd order spline), and
 * gcv_spline (5th order B-spline).
 */
double interpolate_spline(double abscissa, dpSplineFunction* func, Derivative deriv,
                          double velocity, double acceleration)
{
   int i, j, k, n;
   double dx;

   if (func == NULL)
      printf("interpolate_spline: attempted to access NULL function.");

   if (func->type == dpStepFunction)
   {
      for (i = func->numpoints - 1; i >= 0; i--)
      {
         if (abscissa >= func->x[i] - TINY_TIME)
            return func->y[i];
      }

      /* If the abscissa is less than x[0], return y[0]. */
      return func->y[0];
   }
	else if (func->type == dpLinear)
	{
		if (abscissa < func->x[0])
		{
			return func->y[0] - (abscissa - func->x[0]) * func->b[0];
		}
		else
		{
			for (i = func->numpoints - 1; i >= 0; i--)
			{
				if (abscissa >= func->x[i] - TINY_TIME)
					return func->y[i] + (abscissa - func->x[i]) * func->b[i];
			}
		}
	}
   else if (func->type == dpGCVSpline)
   {
      int l = 1;
      int order = 5; //5th order for quintic spline
      int half_order = (order + 1) / 2; // GCVSPL works with the half order
      double work[20]; // size of work array must be >= order

      return splder((int*)&deriv, &half_order, &func->numpoints, &abscissa, 
                    func->x, func->c, &l, work);
   }

   /* The rest of this function is for type = dpNaturalCubic. */

   n = func->numpoints;

   /* Check if the abscissa is out of range of the function. If it is,
    * then use the slope of the function at the appropriate end point to
    * extrapolate. You do this rather than printing an error because the
    * assumption is that this will only occur in relatively harmless
    * situations (like a motion file that contains an out-of-range gencoord
    * value). The rest of the SIMM code has many checks to clamp a gencoord
    * value within its range of motion, so if you make it to this function
    * and the gencoord is still out of range, deal with it quietly.
    */

   if (abscissa < func->x[0] - TINY_TIME)
   {
      if (deriv == zeroth)
         return func->y[0] + (abscissa - func->x[0])*func->b[0];
      if (deriv == first)
         return func->b[0]*velocity;
      if (deriv == second)
         return func->b[0]*acceleration;
   }
   else if (abscissa > func->x[n-1] + TINY_TIME)
   {
      if (deriv == zeroth)
         return func->y[n-1] + (abscissa - func->x[n-1])*func->b[n-1];
      if (deriv == first)
         return func->b[n-1]*velocity;
      if (deriv == second)
         return func->b[n-2]*acceleration;
   }

   /* Check to see if the abscissa is close to one of the end points
    * (the binary search method doesn't work well if you are at one of the
    * end points.
    */
   if (EQUAL_WITHIN_TOLERANCE(abscissa, func->x[0], TINY_TIME))
   {
      if (deriv == zeroth)
         return func->y[0];
      if (deriv == first)
         return func->b[0]*velocity;
      if (deriv == second)
         return func->b[0]*acceleration + 2.0*func->c[0]*velocity*velocity;
   }
   else if (EQUAL_WITHIN_TOLERANCE(abscissa, func->x[n-1], TINY_TIME))
   {
      if (deriv == zeroth)
         return func->y[n-1];
      if (deriv == first)
         return func->b[n-1]*velocity;
      if (deriv == second)
         return func->b[n-1]*acceleration + 2.0*func->c[n-1]*velocity*velocity;
   }

   if (n < 3)
   {
      /* If there are only 2 function points, then set k to zero
       * (you've already checked to see if the abscissa is out of
       * range or equal to one of the endpoints).
       */
      k = 0;
   }
   else
   {
      /* Do a binary search to find which two points the abscissa is between. */
      i = 0;
      j = n;
      while (1)
      {
         k = (i+j)/2;
         if (abscissa < func->x[k])
            j = k;
         else if (abscissa > func->x[k+1])
            i = k;
         else
            break;
      }
   }

   dx = abscissa - func->x[k];

   if (deriv == zeroth)
      return func->y[k] + dx*(func->b[k] + dx*(func->c[k] + dx*func->d[k]));

   if (deriv == first)
      return (func->b[k] + dx*(2.0*func->c[k] + 3.0*dx*func->d[k]))*velocity;

   if (deriv == second)
      return (func->b[k] + dx*(2.0*func->c[k] + 3.0*dx*func->d[k]))*acceleration +
	      (2.0*func->c[k] + 6.0*dx*func->d[k])*velocity*velocity;

   return ERROR_DOUBLE;
}

/* COMPUTE_CONSTRAINED_COORDS: given an array of the generalized coordinates
 * and speeds (y), this routine computes values of any constrained coordinates
 * and speeds and over-writes the values that are in y.  The array y is
 * assumed to contain all the generalized coordinates in the same order as the
 * model followed by all the speeds, again, in the same order as the model.
 * The rotational coordinates and speeds are expected to be in radians and
 * radians/sec.
 */
SDFAST_DLL_API void compute_constrained_coords(double *y) {
	int i;
	double q_ind_value, u_ind_value;
	for (i=0;i<sdm.nq;i++) {
		if (sdm.q[i].type == dpConstrainedQ) {
			// Coordinate
			q_ind_value = y[sdm.q[i].q_ind];
			y[i] = interpolate_spline(q_ind_value,sdm.q[i].constraint_func,zeroth,0.0,0.0);
			// Speed
			u_ind_value = y[sdm.nq+sdm.q[i].q_ind];
			y[i+sdm.nq] = interpolate_spline(q_ind_value,sdm.q[i].constraint_func,first,u_ind_value,0.0);
	    }
   }
}

/* Display any posted SD/FAST error messages with the name of the function
 * in which they occurred. Clear the errors. */
int check_for_sderror(char caller[])
{
   int routine, err;

   sderror(&routine, &err);

   switch (err)
   {
      case 0:
         break;
      case 19:
         printf("%s: trying to set a non-? parameter.", caller);
         break;
      default:
         printf("%s:", caller);
         sdprinterr(stdout);
         break;
   }
   sdclearerr();

   return err;
}

SDFAST_DLL_API void init_sdm()
{
	int info[50];

   sdinfo(info);
   sdm.num_body_segments = info[1] + 1;    /* include ground */
   sdm.nq = info[2] + info[7];
   sdm.nu = info[2];
   sdm.num_closed_loops = info[4];
   sdm.num_joints = info[1] + info[4]; /* nbod + nloop */
   sdm.num_constraints = info[3];
   sdm.num_user_constraints = info[10];
	sdm.neq = sdm.nq + sdm.nu; // not used in the new code, so don't bother adding num_muscle_states

   init_qs();
   init_joints();
   init_wrap_objects();
   init_constraint_objects();
   init_q_restraint_functions();

	const double BAUMGARTE_STAB = 20.0;
	sdstab(2.0*BAUMGARTE_STAB,BAUMGARTE_STAB*BAUMGARTE_STAB);
}

/* initialize the joint records.
 */
void init_joints(void)
{
   int info[50], slider[6], i, j;
   int axis, num_axes, q;
   double pin[3];
   
   sdm.joint = (dpJointStruct*)simm_malloc(sdm.num_joints*sizeof(dpJointStruct));
   for (i = 0; i < sdm.num_joints; i++)
   {
      sdjnt(i, info, slider);
      
      sdm.joint[i].inboard_body = info[2];
      sdm.joint[i].outboard_body = info[3];
      sdm.joint[i].first_q = info[7];
      sdm.joint[i].dof = info[4];
      sdm.joint[i].quat = info[8];
      sdm.joint[i].loop_joint = dpNo;
      for (j = 0; j < 6; j++)
      {
         if (slider[j] == 0)
            sdm.joint[i].dof_type[j] = dpRotational;
         else if (slider[j] == 1)
            sdm.joint[i].dof_type[j] = dpTranslational;
         else
            sdm.joint[i].dof_type[j] = dpNoDof;
      }
      switch(info[0])
      {
         case(1):
            sdm.joint[i].jnt_type = dpPin;
            break;
         case(2):
            sdm.joint[i].jnt_type = dpUniversal;
            break;
         case(3):
            sdm.joint[i].jnt_type = dpGimbal;
            break;
         case(4):
            sdm.joint[i].jnt_type = dpBall;
            break;
         case(5):
            sdm.joint[i].jnt_type = dpSlider;
            break;
         case(6):
            sdm.joint[i].jnt_type = dpFree;
            break;
         case(7):
            sdm.joint[i].jnt_type = dpCylindrical;
            break;
         case(8):
            sdm.joint[i].jnt_type = dpPlanar;
            break;
         case(9):
            sdm.joint[i].jnt_type = dpWeld;
            sdm.joint[i].loop_joint = dpYes;
            break;
         case(10):
            sdm.joint[i].jnt_type = dpBushing;
            break;
         case(11):
            sdm.joint[i].jnt_type = dpBearing;
            break;
         case(20):
            sdm.joint[i].jnt_type = dpReversePlanar;
            break;
         case(21):
            sdm.joint[i].jnt_type = dpReverseFree;
            break;
         case(22):
            sdm.joint[i].jnt_type = dpReverseBushing;
            break;
         case(23):
            sdm.joint[i].jnt_type = dpReverseBearing;
            break;
         default:
            sdm.joint[i].jnt_type = dpUnknownJoint;
            break;
      }
      
      num_axes = sdm.joint[i].dof;
      for (j = 0; j < num_axes; j++)
      {
         if (j < 3)
				axis = j;
         else
				axis = j - 3;
         q = sdm.joint[i].first_q + j;
         sdgetpin(i, axis, pin);
         sdvcopy(pin, sdm.joint[i].axes[j]);
      }
      for (j = 0; j < 3; j++)
         sdm.joint[i].force[j] = sdm.joint[i].torque[j] = 0.0;		
   }

}

/* APPLY_JOINT_RESTRAINT_TORQUES: This routine uses the user-defined restraint torque
 * functions to apply torques to the degrees of freedom in order to keep them from
 * going out of the desirable ranges of motion. The new method of specifying restraint
 * torques uses one function (restraint_func) which covers the complete range of motion
 * as well as off both ends. If this function is defined, use it, otherwise use the
 * old method (min_restraint_func and max_restraint_func).
 *   If you want to include damping in the restraint torques, then uncomment the
 * appropriate lines in the function, and set the dampingFactor to the desired value.
 */
void apply_joint_restraint_torques(double q[], double u[])
{
   int i;
   double state_value, difference, torque; //, dampingFactor = 1.0;

   for (i = 0; i < sdm.nq; i++)
   {
      if (sdm.q[i].type == dpUnconstrainedQ || sdm.q[i].type == dpPrescribedQ)
      {
         state_value = q[i];
         if ((sdm.q[i].restraint_func != NULL) && (sdm.q[i].function_active == dpYes))
         {
            torque = interpolate_spline(state_value, sdm.q[i].restraint_func,zeroth, 1.0, 1.0);
            /* Because the torque in this case is applied for all gencoord values
             * (though it's usually zero within the range of motion), you only want
             * to include the damping term when the torque is not zero.
             */
            //if (NOT_EQUAL_WITHIN_ERROR(torque, 0.0))
               //torque -= dampingFactor * dstate[i];
            sdhinget(sdm.q[i].joint, sdm.q[i].axis, torque);
         }
         else if (state_value < sdm.q[i].range_start && sdm.q[i].min_restraint_func != NULL)
         {
            difference = sdm.q[i].range_start - state_value;
            torque = interpolate_spline(difference, sdm.q[i].min_restraint_func, zeroth, 1.0, 1.0);
            //torque -= dampingFactor * dstate[i];
            sdhinget(sdm.q[i].joint, sdm.q[i].axis, torque);
         }
         else if (state_value > sdm.q[i].range_end && sdm.q[i].max_restraint_func != NULL)
         {
            difference = state_value - sdm.q[i].range_end;
            torque = -interpolate_spline(difference, sdm.q[i].max_restraint_func, zeroth, 1.0, 1.0);
            //torque -= dampingFactor * dstate[i];
            sdhinget(sdm.q[i].joint, sdm.q[i].axis, torque);
         }
      }
   }
}

/* MALLOC_FUNCTION: this routine mallocs space for a spline function. */
ReturnCode malloc_function(dpSplineFunction* func, int numpoints)
{
   if (func == NULL)
      return code_bad;

   func->coefficient_array_size = 0;
   func->defined = dpNo;

   if ((func->x = (double*)simm_calloc(numpoints, sizeof(double))) == NULL)
      return code_bad;
   if ((func->y = (double*)simm_calloc(numpoints, sizeof(double))) == NULL)
      return code_bad;
   if ((func->b = (double*)simm_calloc(numpoints, sizeof(double))) == NULL)
      return code_bad;
   if ((func->c = (double*)simm_calloc(numpoints, sizeof(double))) == NULL)
      return code_bad;
   if ((func->d = (double*)simm_calloc(numpoints, sizeof(double))) == NULL)
      return code_bad;

   func->coefficient_array_size = numpoints;
   func->type = dpNaturalCubic;
   func->defined = dpYes;

   return code_fine;
}

/* MSTRCPY: this routine is like strcpy(), but it first mallocs space for
 * the copy of the string.
 */
ReturnCode mstrcpy(char* dest_str[], char original_str[])
{

   if ((*dest_str = 
   	(char*)simm_malloc((unsigned int)STRLEN(original_str)*sizeof(char))) == NULL)
      return (code_bad);

   (void)strcpy(*dest_str,original_str);
   return (code_fine);
}

/* SIMM_MALLOC: this is a wrapper routine for malloc. It checks the size
 * you want to malloc, then calls malloc. If there is an error, it prints
 * an error message then returns NULL.
 */

void* simm_malloc(unsigned mem_size)
{
   void* ptr;

   /* To make sure you don't try to malloc 0 bytes (which is a problem
    * with some compilers because malloc returns NULL when you try it).
    * This is not the most elegant solution, but it works in the case
    * in which simm_malloc() is accidentally called with size 0.
    */
   if (mem_size <= 0)
      mem_size = sizeof(int);

   ptr = malloc(mem_size);

   //if (ptr == NULL)
      //sim_message(exit_program, "Ran out of memory. Unable to malloc %d bytes.", (int)mem_size);

   return ptr;
}

/* SIMM_CALLOC: this is a wrapper routine for calloc. It checks the size
 * you want to calloc, then calls calloc. If there is an error, it prints
 * an error message then returns NULL.
 */

void* simm_calloc(unsigned num_elements, unsigned elem_size)
{
   void* ptr;

   /* To make sure you don't try to malloc 0 bytes (which is a problem
    * with some compilers because malloc returns NULL when you try it).
    * This is not the most elegant solution, but it works in the case
    * in which simm_calloc() is accidentally called with size or num_elements 0.
    */
   if (num_elements*elem_size <= 0)
   {
      num_elements = 1;
      elem_size = sizeof(int);
   }

   ptr = calloc(num_elements,elem_size);

   //if (ptr == NULL)
      //sim_message(exit_program, "Ran out of memory. Unable to calloc %d bytes.", (int)(num_elements*elem_size));

   return ptr;
}
}
