// DecompHardUTWalkNoComp.cpp
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	AUTHOR: Frank C. Anderson, Saryn R. Goldberg
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/* 
 * This routine is different from DecompHardUTWalkNoComp in that it does not apply 
 * forces due to any of the actuators, gravity, centripetal, or coriolis force.
 * The only forces that are decomposed are those that are applied via force,
 * torque, or generalized force appliers that are set before the decomposition
 * routine is called.  These forces are not decomposed individually - it is their
 * net contribution to the ground reaction force that is determined.
 */


//=============================================================================
// INCLUDES
//=============================================================================
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <float.h>
#include <OpenSim/Tools/rdTools.h>
#include <OpenSim/Simulation/Model/Model.h>
#include <OpenSim/Simulation/Model/Springs.h>
#include <OpenSim/Models/UTWalking8/rdUTWalking8.h>
#include <OpenSim/SQP/rdSQP.h>
#include <OpenSim/Tools/PointConstraint.h>
#include <OpenSim/Simulation/Model/DerivCallbackSet.h>
#include "DecompTargetNoComp.h"
#include "DecompHardUTWalkNoComp.h"




using namespace OpenSim;
using namespace std;


//=============================================================================
// CONSTANTS
//=============================================================================


//=============================================================================
// CONSTANTS
//=============================================================================



//=============================================================================
// CONSTRUCTOR(S) AND DESTRUCTOR
//=============================================================================
//_____________________________________________________________________________
/**
 * Destructor.
 */
DecompHardUTWalkNoComp::~DecompHardUTWalkNoComp()
{
	if(_x!=NULL) { delete[] _x;  _x=NULL; }
	if(_yCopy!=NULL) { delete[] _yCopy;  _yCopy=NULL; }
	if(_yTmp!=NULL) { delete[] _yTmp;  _yTmp=NULL; }
	if(_xsSprMap!=NULL) { delete[] _xsSprMap;  _xsSprMap=NULL; }
	if(_xsXYZMap!=NULL) { delete[] _xsXYZMap;  _xsXYZMap=NULL; }
	if(_prescribedSpringPositionStorage!=NULL) 
		{delete[] _prescribedSpringPositionStorage; _prescribedSpringPositionStorage=NULL; }
	if(_prescribedSpringVelocityStorage!=NULL) 
		{delete[] _prescribedSpringVelocityStorage; _prescribedSpringVelocityStorage=NULL; }
	if(_prescribedSpringForceStorage!=NULL) 
		{delete[] _prescribedSpringForceStorage; _prescribedSpringForceStorage=NULL; }
}
//_____________________________________________________________________________
/**
 * Construct a hard-constraint decomposition analysis based on an
 * rdUTWalking8 model.
 */
DecompHardUTWalkNoComp::DecompHardUTWalkNoComp(rdUTWalking8 *aModel) :
	DecompNoComp(aModel)
{
	setNull();

	// LOCAL WORK ARRAYS
	_yCopy = new double[_model->getNumStates()];
	_yTmp = new double[_model->getNumStates()];
	_x = new double[_model->getNumControls()];

	// MAPPING ARRAYS
	int ns = _model->getNumContacts();
	_xsSprMap = new int[3*ns];
	_xsXYZMap = new int[3*ns];

	// PERFORMANCE CRITERION WEIGHTS
	_wXS = 1.0e-2;
	_wAcc = 1.0;

	// BODY CONSTRAINTS
	clearBodyConstraints();
}


//=============================================================================
// CONSTRUCTION
//=============================================================================
//_____________________________________________________________________________
/**
 * Set NULL values for all member variables.
 */
void DecompHardUTWalkNoComp::
setNull()
{
	_c = 0;
	_nxs = 0;
	_xsSprMap = NULL,
	_xsXYZMap = NULL;
	_wXS = 1.0;
	_wAcc = 1.0;
	_point[0] = _point[1] = _point[2] = 0.0;
	_yCopy = NULL;
	_yTmp = NULL;
	_x = NULL;
	_prescribedContact = false;
	_prescribedSpringPositionStorage = NULL;
	_prescribedSpringVelocityStorage = NULL;
	_prescribedSpringForceStorage = NULL;

}


//=============================================================================
// GET AND SET
//=============================================================================
//_____________________________________________________________________________
/**
 * Get the contact point for a specified contact element.
 *
 * @param aIndex Index to the model contact element.
 * @return Pointer to the contact point.  The contact point is a local
 * variable member, so there is no danger of the pointer becoming
 * invalid.
 */
double* DecompHardUTWalkNoComp::
getContactPoint(int aIndex)
{
	_model->getContactPointB(aIndex,_point);
	return(_point);
}
//_____________________________________________________________________________
/**
 * Set whether the contact will be prescribed and set the storages that should be
 * used to read in the required values.
 *
 * @param aPrescribedContact flag indicates whether contact will be prescribed
 * @param aPrescribedSpringPositionStorage contains the prescribed spring postions
 * @param aPrescribedSpringVelocityStorage contains the prescribed spring velocities
 * @param aPrescribedSpringForceStorage contains the prescribed spring forces
 */
void DecompHardUTWalkNoComp::
setPrescribedContact(bool aTrueFalse, 
		Storage *aPrescribedSpringPositionStorage,
		Storage *aPrescribedSpringVelocityStorage,
		Storage *aPrescribedSpringForceStorage)
{
	_prescribedContact = aTrueFalse;
	_prescribedSpringPositionStorage = aPrescribedSpringPositionStorage;
	_prescribedSpringVelocityStorage = aPrescribedSpringVelocityStorage;
	_prescribedSpringForceStorage = aPrescribedSpringForceStorage;

}
//_____________________________________________________________________________
/**
 * Get whether the contact will be prescribed.
 *
 * @return aPrescribedContact flag
 * @see setPrescribedContact()
 */
bool DecompHardUTWalkNoComp::
getPrescribedContact() const
{
	return(_prescribedContact);
}
//_____________________________________________________________________________
/**
 * Get the prescribed spring postions storage.
 *
 * @return Prescribed spring postions storage.
 */
Storage* DecompHardUTWalkNoComp::
getPrescribedSpringPositionStorage()
{
	return(_prescribedSpringPositionStorage);
}
//_____________________________________________________________________________
/**
 * Get the prescribed spring velocity storage.
 *
 * @return Prescribed spring velocity storage.
 */
Storage* DecompHardUTWalkNoComp::
getPrescribedSpringVelocityStorage()
{
	return(_prescribedSpringVelocityStorage);
}
//_____________________________________________________________________________
/**
 * Get the prescribed spring forces storage.
 *
 * @return Prescribed spring forces storage.
 */
Storage* DecompHardUTWalkNoComp::
getPrescribedSpringForceStorage()
{
	return(_prescribedSpringForceStorage);
}


//=============================================================================
// DECOMPOSITION METHODS
//=============================================================================
//_____________________________________________________________________________
/**
 * Decompose the ground reaction force by assuming hard constraints.
 */
void DecompHardUTWalkNoComp::
compute(double *aXPrev,double *aYPrev,int step,double dt,double t,
		  double *xt,double *y)
{
	printf("\n\ntime = %lf\n",t);

	// CAST MODEL
	rdUTWalking8 *model = (rdUTWalking8*)_model;

	// INDEX TO ACTIVATIONS
	int iatv = _model->getNumCoordinates() + _model->getNumSpeeds() + _model->getNumControls();

	// SET CONFIGURATION
	model->set(t,xt,y);

	// GROUND SPRINGS
	int np = model->getNumContacts();
	int s,n,I;
	double svel[rdUTWalking8_NS][3];
	double spos[rdUTWalking8_NS][3];
	double sfrc[rdUTWalking8_NS][3];
	double *sposPrescribed = new double[6*rdUTWalking8_NS];
	double *svelPrescribed = new double[6*rdUTWalking8_NS];
	double *sfrcPrescribed = new double[6*rdUTWalking8_NS];
	if(_prescribedContact){
		_prescribedSpringPositionStorage->getDataAtTime(t*_model->getTimeNormConstant(),6*rdUTWalking8_NS,sposPrescribed);
		_prescribedSpringVelocityStorage->getDataAtTime(t*_model->getTimeNormConstant(),6*rdUTWalking8_NS,svelPrescribed);
		_prescribedSpringForceStorage->getDataAtTime(t*_model->getTimeNormConstant(),6*rdUTWalking8_NS,sfrcPrescribed);
		for(s=0;s<rdUTWalking8_NS;s++){
			for(n=3;n<6;n++){
				I = Mtx::ComputeIndex(s,6,n);
				spos[s][n-3] = sposPrescribed[I];
				svel[s][n-3] = svelPrescribed[I];
				sfrc[s][n-3] = sfrcPrescribed[I];
			}
		}
	}else{
		model->computeSpringPointKinematics(svel,spos);
		model->computeGroundForces(svel,spos,sfrc);
	}
	model->updateGroundZeros(svel,spos,sfrc);
	model->limitGroundForces(sfrc);

	// VARIABLE DECLARATIONS
	int i,j;
	double xs[3*rdUTWalking8_NS];
	double fs[rdUTWalking8_NS][3];
	double g[3];
	model->getGravity(g);

	// COMPUTE THE NOMINAL SPRING ACCELERATIONS
	double dqdt[rdUTWalking8_NQ],dudt[rdUTWalking8_NU];
	double sacc[rdUTWalking8_NS][3],saccOpt[rdUTWalking8_NS][3];
	// ----------------------------------
	// SET
	_model->set(t,xt,y);
	_model->getDerivCallbackSet()->set(t,xt,y);

	// ACTUATION
	_model->computeActuation();
	_model->getDerivCallbackSet()->computeActuation(t,xt,y);
	_model->applyActuatorForces();
	_model->getDerivCallbackSet()->applyActuation(t,xt,y);

	// CONTACT
	_model->computeContact();
	_model->getDerivCallbackSet()->computeContact(t,xt,y);
	_model->applyContactForces();
	_model->getDerivCallbackSet()->applyContact(t,xt,y);

	// ACCELERATIONS
	int nq = _model->getNumCoordinates();
	_model->computeAccelerations(dqdt,dudt);
	// ----------------------------------
	for(i=0;i<np;i++) {
		model->getAcceleration(model->getContactBodyB(i),getContactPoint(i),
			sacc[i]);
	}

	// DETERMINE THE CONTROLS
	determineControls(sfrc);
	if(_nxs<=0) {
		printf("\n\nNo springs in contact!\n\n");
		return;
	}

	// DETERMINE THE CONSTRAINTS
	determineConstraints();

	// CREATE THE OPTIMIZATION OBJECTS
	DecompTargetNoComp *decompTarget =
		new DecompTargetNoComp(_nxs,getNumberConstraints(),this);
	rdFSQP *sqp = new rdFSQP(decompTarget);
	sqp->setMaxIterations(200);
	sqp->setNonlinearEqualityConstraintTolerance(1.0e-4);
	sqp->setConvergenceCriterion(1.0e-2);
	sqp->setPrintLevel(1);

	// SOLVE OPTIMIZATION PROBLEM ONLY ONCE

	// SET INITIAL GUESS
	for(i=0;i<_nxs;i++) xs[i] = 1.0;

	sqp->computeOptimalControls(xs,xs);

	// RECORD CONTACT POINT ACCELERATIONS
	if(_recordContactPointAccelerations){
		suComputeContactPointAccelerations(xs, _c, saccOpt);
		_cpaStore[_c]->append(t*model->getTimeNormConstant(),3*np,&saccOpt[0][0]);
	}

	// RESET CONSTRAINT VALUES
	clearBodyConstraintValues();

	// RESET GRAVITY
	model->setGravity(g);

	// SET SPRING FORCES
	setSpringForces(xs,fs);
	for(i=0;i<np;i++) for(j=0;j<3;j++) _f[_c][i][j] = fs[i][j];

	// FILL STORAGE ARRAY
	_fStore[_c]->append(t*model->getTimeNormConstant(),3*np,&_f[_c][0][0]);

	// CLEANUP
	if(decompTarget!=NULL) { delete decompTarget; decompTarget=NULL; }
	if(sqp!=NULL) { delete sqp; sqp=NULL; }
}
//_____________________________________________________________________________
/**
 * Determine the controls for the decomposition.
 */
void DecompHardUTWalkNoComp::
determineControls(double sfrc[][3])
{
	int i;

	// RESET MAPPINGS
	int np = _model->getNumContacts();
	_nxs = 0;
	for(i=0;i<3*np;i++) {
		_xsSprMap[i] = -1;
		_xsXYZMap[i] = -1;
	}

	// SET CONTACT ESTABLISHED
	if(!getUsePresetContactEstablishedSettings()) {
		for(i=0;i<np;i++) {
			if(fabs(sfrc[i][1])<getContactThreshold()) {
				_contactEstablished[i] = false;
			} else {
				_contactEstablished[i] = true;
			}
		}
	}

	// SET CONTROLS MAP
	for(i=0;i<np;i++) {
		if(getContactEstablished(i)) {
			_xsSprMap[_nxs] = i;
			_xsSprMap[_nxs+1] = i;
			_xsSprMap[_nxs+2] = i;
			_xsXYZMap[_nxs] = 0;
			_xsXYZMap[_nxs+1] = 1;
			_xsXYZMap[_nxs+2] = 2;
			_nxs += 3;
		}
	}

	// PRINT
//	printf("\n\nControl Maps:\n");
	for(i=0;i<3*np;i++) {
//		printf("%d: %d %d\n",i,_xsSprMap[i],_xsXYZMap[i]);
	}
//	printf("\n");
}
//_____________________________________________________________________________
/**
 * Determine the constraints for the decomposition.
 */
void DecompHardUTWalkNoComp::
determineConstraints()
{
	int i,ibc,ipc;
	double x[] = {1.0,0.0,0.0};
	double y[] = {0.0,1.0,0.0};
	double z[] = {0.0,0.0,1.0};
	double p[3];
	PointConstraint *pc[3];
	int rHindInContact=0;
	int lHindInContact=0;

	// CAST MODEL
	rdUTWalking8 *model = (rdUTWalking8*)_model;

	// CLEAR ANY PREVIOUS CONSTRAINTS
	clearBodyConstraints();

	// RIGHT HINDFOOT
	ibc = 0;
	for(ipc=0,i=0;i<4;i++) {

		if(!_contactEstablished[i]) continue;

		// pc0
		if(ipc==0) {
			_bc[ibc].setID(model->getContactBodyB(i));
			pc[ipc] = _bc[ibc].getPC(ipc);
			pc[ipc]->setID(i);
			model->getPosition(model->getContactBodyB(i),getContactPoint(i),p);
			pc[ipc]->setPoint(p);
			pc[ipc]->setC0(x);
			pc[ipc]->setC1(y);
			pc[ipc]->setC2(z);
			ipc++;

		// pc1
		} else if(ipc==1) {
			pc[ipc] = _bc[ibc].getPC(ipc);
			pc[ipc]->setID(i);
			model->getPosition(model->getContactBodyB(i),getContactPoint(i),p);
			pc[ipc]->setPoint(p);
			_bc[ibc].constructConstraintsForPoint1();
			ipc++;

		// pc2
		} else if(ipc==2) {
			pc[ipc] = _bc[ibc].getPC(ipc);
			pc[ipc]->setID(i);
			model->getPosition(model->getContactBodyB(i),getContactPoint(i),p);
			pc[ipc]->setPoint(p);
			_bc[ibc].constructConstraintsForPoint2();
			ipc++;

		// NO MORE THAN 3 ON A BODY
		} else {
			printf("Enough constraints on body.\n");
		}

	}
	rHindInContact = ipc;
	if(ipc>0) ibc++;

	// RIGHT TOES
	for(ipc=0,i=4;i<5;i++) {

		if(!_contactEstablished[i]) continue;

		_bc[ibc].setID(model->getContactBodyB(i));
		pc[0] = _bc[ibc].getPC(ipc);
		pc[0]->setID(i);
		model->getPosition(model->getContactBodyB(i),getContactPoint(i),p);
		pc[ipc]->setPoint(p);

		// THREE CONSTRAINT DIRECTIONS BECAUSE HINDFOOT IS NOT IN CONTACT
		// Actually, when only one contact point on the hindfoot is in contact, the toe
		// actually has three degrees of freedom because of the metatarsal joint.
		// Therefore, it must be constrained in three directions.
		if(rHindInContact<=1) {
			pc[0]->setC0(x);
			pc[0]->setC1(y);
			pc[0]->setC2(z);

		// ONE CONSTRAINT DIRECTION ORTHOGONAL TO JOINT BECAUSE
		// HINDFOOT IS IN CONTACT
		} else {
			double p2[3],p3[3],p4[3],c0[3];
			model->getPosition(model->getContactBodyB(2),getContactPoint(2),p2);
			model->getPosition(model->getContactBodyB(3),getContactPoint(3),p3);
			model->getPosition(model->getContactBodyB(4),getContactPoint(4),p4);
			double r23[3],r34[3];
			Mtx::Subtract(1,3,p3,p2,r23);
			Mtx::Subtract(1,3,p4,p3,r34);
			Mtx::CrossProduct(r23,r34,c0);
			pc[0]->zeroConstraints();
			pc[0]->setC0(c0);
			pc[0]->normalizeConstraints();
		}
		ipc++;
	}
	if(ipc>0) ibc++;

	// LEFT HINDFOOT
	for(ipc=0,i=5;i<9;i++) {

		if(!_contactEstablished[i]) continue;

		// pc0
		if(ipc==0) {
			_bc[ibc].setID(model->getContactBodyB(i));
			pc[ipc] = _bc[ibc].getPC(ipc);
			pc[ipc]->setID(i);
			model->getPosition(model->getContactBodyB(i),getContactPoint(i),p);
			pc[ipc]->setPoint(p);
			pc[ipc]->setC0(x);
			pc[ipc]->setC1(y);
			pc[ipc]->setC2(z);
			ipc++;

		// pc1
		} else if(ipc==1) {
			pc[ipc] = _bc[ibc].getPC(ipc);
			pc[ipc]->setID(i);
			model->getPosition(model->getContactBodyB(i),getContactPoint(i),p);
			pc[ipc]->setPoint(p);
			_bc[ibc].constructConstraintsForPoint1();
			ipc++;

		// pc2
		} else if(ipc==2) {
			pc[ipc] = _bc[ibc].getPC(ipc);
			pc[ipc]->setID(i);
			model->getPosition(model->getContactBodyB(i),getContactPoint(i),p);
			pc[ipc]->setPoint(p);
			_bc[ibc].constructConstraintsForPoint2();
			ipc++;

		// NO MORE THAN 3 ON A BODY
		} else {
			printf("Enough constraints on body.\n");
		}
	}
	lHindInContact = ipc;
	if(ipc>0) ibc++;

	// LEFT TOES
	for(ipc=0,i=9;i<10;i++) {

		if(!_contactEstablished[i]) continue;

		_bc[ibc].setID(model->getContactBodyB(i));
		pc[0] = _bc[ibc].getPC(ipc);
		pc[0]->setID(i);
		model->getPosition(model->getContactBodyB(i),getContactPoint(i),p);
		pc[ipc]->setPoint(p);

		// THREE CONSTRAINT DIRECTIONS BECAUSE HINDFOOT IS NOT IN CONTACT
		// Actually, when only one contact point on the hindfoot is in contact, the toe
		// actually has three degrees of freedom because of the metatarsal joint.
		// Therefore, it must be constrained in three directions.
		if(lHindInContact<=1 ) {
			pc[0]->setC0(x);
			pc[0]->setC1(y);
			pc[0]->setC2(z);

		// ONE CONSTRAINT DIRECTION ORTHOGONAL TO TO JOINT BECAUSE
		// HINDFOOT IS IN CONTACT
		} else {
			double p2[3],p3[3],p4[3],c0[3];
			model->getPosition(model->getContactBodyB(7),getContactPoint(7),p2);
			model->getPosition(model->getContactBodyB(8),getContactPoint(8),p3);
			model->getPosition(model->getContactBodyB(9),getContactPoint(9),p4);
			double r23[3],r34[3];
			Mtx::Subtract(1,3,p3,p2,r23);
			Mtx::Subtract(1,3,p4,p3,r34);
			Mtx::CrossProduct(r23,r34,c0);
			pc[0]->zeroConstraints();
			pc[0]->setC0(c0);
			pc[0]->normalizeConstraints();
		}
		ipc++;
	}
	if(ipc>0) ibc++;

//	printf("DecompHardUTWalkNoComp.determineConstraints: NC = %d\n",
//		getNumberConstraints());
}
//_____________________________________________________________________________
/**
 * Set spring force array based on decomposition controls.
 */
int DecompHardUTWalkNoComp::
getNumberConstraints()
{
	int i,nc;
	for(nc=i=0;i<4;i++) {
		nc += _bc[i].getNC();
	}
	return(nc);
}
//_____________________________________________________________________________
/**
 * Clear all body constraints.
 */
void DecompHardUTWalkNoComp::
clearBodyConstraints()
{
	int i;
	for(i=0;i<4;i++) {
		_bc[i].clear();
	}
}
//_____________________________________________________________________________
/**
 * Clear all constraint values--- set them to 0.0.
 */
void DecompHardUTWalkNoComp::
clearBodyConstraintValues()
{
	int i;
	for(i=0;i<4;i++) {
		_bc[i].clearValues();
	}
}
//_____________________________________________________________________________
/**
 * Set the relavent constraint values.
 */
void DecompHardUTWalkNoComp::
setBodyConstraintValues(int aN,int aID[],double aV[][3])
{
	int i;
	for(i=0;i<4;i++) {
		_bc[i].setValues(aN,aID,aV);
	}
}
//_____________________________________________________________________________
/**
 * Set spring force array based on decomposition controls.
 */
void DecompHardUTWalkNoComp::
setSpringForces(double *aXS,double aFS[][3])
{
	int i,j;

	// ZERO SPRING FORCES
	for(i=0;i<_model->getNumContacts();i++) {
		for(j=0;j<3;j++) aFS[i][j] = 0.0;
	}

	// STEP THROUGH CONTROLS
	for(i=0;i<_nxs;i++) {
		aFS[_xsSprMap[i]][_xsXYZMap[i]] = aXS[i];
	}
}
//_____________________________________________________________________________
/**
 * Apply appropriate component force.
 *
 * @param aC Index of the component.
 */
void DecompHardUTWalkNoComp::
applyComponentForce(int aC)
{
	int i;

	// GET A COPY OF THE STATES AND CONTROLS
	_model->getStates(_yTmp);
	_model->getControls(_x);

	// GRAVITY
	double g0[3] = { 0.0, 0.0, 0.0 };
	double g[3];
	_model->getGravity(g);

	// ZERO GRAVITY
	_model->setGravity(g0);

	// ZERO VELOCITIES
	int nq = _model->getNumCoordinates();
	int nu = _model->getNumSpeeds();
	for(i=0;i<nu;i++) _yTmp[nq+i] = 0.0;

	// SET STATES
	_model->setStates(_yTmp);

	// IMPLEMENT FORCE, TORQUE, AND GENERALIZED FORCE APPLIERS
	DerivCallbackSet *callbackSet;
	callbackSet = _model->getDerivCallbackSet();
	callbackSet->applyActuation(_model->getTime(),_x,_yTmp);
}



//==============================================================================
// OPTIMIZATION
//==============================================================================
//------------------------------------------------------------------------------
// PERFORMANCE
//------------------------------------------------------------------------------
//______________________________________________________________________________
/**
 * Compute performance given x.
 */
int DecompHardUTWalkNoComp::
suComputePerformance(double *x,double *p)
{
	int i;

	// COMPUTE PERFORMANCE
	*p = 0.0;
	for(i=0;i<_nxs;i++) {
		*p += _wXS*_wXS * x[i]*x[i];
	}

	return(0);
}
//------------------------------------------------------------------------------
// PERFORMANCE
//------------------------------------------------------------------------------
//______________________________________________________________________________
/**
 * Compute performance given x.
 */
int DecompHardUTWalkNoComp::
suComputePerformanceGradient(double *x,double *p)
{
	int i;

	// COMPUTE PERFORMANCE
	*p = 0.0;
	for(i=0;i<_nxs;i++) {
		*p += 2.0 * _wXS*_wXS * x[i];
	}

	return(0);
}
//______________________________________________________________________________
/**
 * Compute a constraint given x.
 */
int DecompHardUTWalkNoComp::
suComputeConstraint(double *x,int ic,double *c)
{
	int i,j;

	// COPY THE STATES
	_model->getStates(_yCopy);

	// APPLY COMPONENT FORCES
	applyComponentForce(_c);

	// APPLY SPRING FORCES
	int np = _model->getNumContacts();
	double fs[rdUTWalking8_NS][3];
	setSpringForces(x,fs);
	for(i=0;i<np;i++) {
		_model->applyForce(_model->getContactBodyB(i),getContactPoint(i),fs[i]);
	}

	// COMPUTE ACCELERATIONS
	double dqdt[rdUTWalking8_NQ],dudt[rdUTWalking8_NU];
	_model->computeAccelerations(dqdt,dudt);

	// EVALUATE THE CONSTRAINT
	bool evaluated = false;
	int nc,id,whichC;
	double fsAcc[3];
	for(nc=i=0;i<4;i++) {

		// LOOP ON POINT CONSTRAINTS
		for(j=0;j<3;j++) {
			nc += _bc[i].getPC(j)->getNC();
			if(nc<ic) continue;

			// GET THE ACCELERATION
			id = _bc[i].getPC(j)->getID();
			_model->getAcceleration(_model->getContactBodyB(id),
				getContactPoint(id),fsAcc);

			// WHICH CONSTRAINT DIRECTION
			whichC = _bc[i].getPC(j)->getNC() - (nc-ic) - 1;

			// EVALUATE
			if(whichC==0) {
				*c = _bc[i].getPC(j)->evaluateC0(fsAcc);
				evaluated = true;
			} else if(whichC==1) {
				*c = _bc[i].getPC(j)->evaluateC1(fsAcc);
				evaluated = true;
			} else if(whichC==2) {
				*c = _bc[i].getPC(j)->evaluateC2(fsAcc);
				evaluated = true;
			} else {
				printf("DecompHardUTWalkNoComp.suComputeConstraint: ERROR- invalid C\n");
			}

			// BREAK?
			if(evaluated) break;
		}

		// BREAK?
		if(evaluated) break;
	}

	// WEIGHT FACTOR
	*c *= _wAcc;
	//printf("%d = %lf\n",ic-1,*c);

	// RESTORE THE STATES
	_model->setStates(_yCopy);

	return(0);
}

//______________________________________________________________________________
/**
 * Compute contact point accelerations.
 */
int DecompHardUTWalkNoComp::
suComputeContactPointAccelerations(double *x,int c,double cpa[][3])
{
	int i;

	// COPY THE STATES
	_model->getStates(_yCopy);

	// APPLY COMPONENT FORCES
	applyComponentForce(c);

	// APPLY SPRING FORCES
	int np = _model->getNumContacts();
	double fs[rdUTWalking8_NS][3];
	setSpringForces(x,fs);
	for(i=0;i<np;i++) {
		_model->applyForce(_model->getContactBodyB(i),getContactPoint(i),fs[i]);
	}

	// COMPUTE ACCELERATIONS
	double dqdt[rdUTWalking8_NQ],dudt[rdUTWalking8_NU];
	_model->computeAccelerations(dqdt,dudt);

	// RECORD CONTACT POINT ACCELERATIONS
	for(i=0;i<np;i++) {
		_model->getAcceleration(_model->getContactBodyB(i),getContactPoint(i),
			cpa[i]);
	}

	// RESTORE THE STATES
	_model->setStates(_yCopy);

	return(0);
}
