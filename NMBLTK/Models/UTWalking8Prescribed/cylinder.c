#include <stdio.h>
#include <math.h>



/*============================================================================*/
/*==== DETERMINE WHETHER 2D PATH FROM P TO S WOULD COME WITHIN R OF ORIGIN ===*/
/*============================================================================*/
int path_inside_radius_(double P[2],double S[2],double R) {
	register double a,b,c;
	a=S[1]-P[1];	b=P[0]-S[0];	c=a*P[0]+b*P[1];
	return( (c*c/(a*a+b*b)) <= R*R );
}
/*============================================================================*/
/*================== DETERMINE 3D DISTANCE BETWEEN TWO POINTS ================*/
/*============================================================================*/
double distance_between_(double P[3],double S[3]) {
	return( sqrt( (P[0]-S[0])*(P[0]-S[0]) +
					  (P[1]-S[1])*(P[1]-S[1]) +
					  (P[2]-S[2])*(P[2]-S[2]) ) );
}
/*============================================================================*/




/*============================================================================*/
/*====== COMPUTE VIA PATH FOR MINIMUM DISTANCE AROUND A SINGLE CYLINDER ======*/
/*============================================================================*/
int scylinder_(R,P,q,t,S,Pq,qt,tS,L,active)
	double *R,P[3],q[3],t[3],S[3],*Pq,*qt,*tS,*L; int *active; {
	double d,rt;
	/*==================================================================*/
	d=P[0]*P[0]+P[1]*P[1];
	rt=d-*R**R;
	if(rt<0.0) return(-1);
	rt=sqrt(rt);
        d=*R/d;
        q[0]=(*R*P[0]-rt*P[1])*d;
        q[1]=(*R*P[1]+rt*P[0])*d;
	/*==================================================================*/
	d=S[0]*S[0]+S[1]*S[1];
        rt=d-*R**R;
        if(rt<0.0) return(-1);
        rt=sqrt(rt);
        d=*R/d;	
        t[0]=(*R*S[0]+rt*S[1])*d;
        t[1]=(*R*S[1]-rt*S[0])*d;
	/*==================================================================*/
	if(*R*(q[0]*t[1]-q[1]*t[0])<0.0) {/* CURL>180 DEGREE - ASSUME INACTIVE */
		q[0]=P[0];	q[1]=P[1];	q[2]=P[2];	*Pq=0.0;
		t[0]=S[0];	t[1]=S[1];	t[2]=S[2];	*tS=0.0;
		*L=*qt=distance_between_(q,t);	*active=0;	/* INACTIVE */
		return(0);
	}
	/*==================================================================*/
	*Pq=sqrt((q[0]-P[0])*(q[0]-P[0])+(q[1]-P[1])*(q[1]-P[1]));
	*tS=sqrt((t[0]-S[0])*(t[0]-S[0])+(t[1]-S[1])*(t[1]-S[1]));
	*qt=fabs(*R*acos(1.0-0.5*((q[0]-t[0])*(q[0]-t[0])+(q[1]-t[1])*(q[1]-t[1]))/(*R**R)));
	/*==================================================================*/
	q[2]=P[2]+(S[2]-P[2])*(*Pq)/(*Pq+*tS+*qt);
	t[2]=S[2]+(P[2]-S[2])*(*tS)/(*Pq+*tS+*qt);
	/*==================================================================*/
	*Pq=sqrt((*Pq)*(*Pq)+(q[2]-P[2])*(q[2]-P[2]));
	*tS=sqrt((*tS)*(*tS)+(t[2]-S[2])*(t[2]-S[2]));
	*qt=sqrt((*qt)*(*qt)+(q[2]-t[2])*(q[2]-t[2]));	*L = *Pq + *qt + *tS;
	/*==================================================================*/
	*active=1;	/* ACTIVE */
	return(0);
}
/*============================================================================*/


