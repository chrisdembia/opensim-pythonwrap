/*******************************************************************************

   MAIN.C

   Authors: Peter Loan
            Krystyne Blaikie

   Version 3.1.2, September 23, 2004

   Copyright (c) 1996-2004 MusculoGraphics, a division of Motion Analysis Corp.
   All rights reserved.

   Description: This file contains the main routine for a dynamics
		simulation, and several other utility functions that are
		independent of the musculoskeletal model in the simulation.
		This file is generated by SIMM when you choose the
		"project files" option in the "Save Dynamics" dialog box.
		You will probably want to generate it once (not every time you
      change your model) and then customize it to your specific simulation.

*******************************************************************************/
#include "universal.h"

/*************** DEFINES (for this file only) *********************************/

/* Tolerances and Integration parameters. */
#define BAUMGARTE_STAB 20.0

/*************** STATIC GLOBAL VARIABLES (for this file only) *****************/
SystemInfo si;

/**************** GLOBAL VARIABLES (used in only a few files) *****************/
dpModelStruct* sdm;
MotionData* kinetics_data = NULL;
dpSimulationParameters params;
char current_dir[CHARBUFFER];

/*************** EXTERNED VARIABLES (declared in another file) ****************/
extern char buffer[];
extern dpBoolean verbose;

/*************** PROTOTYPES for STATIC FUNCTIONS (for this file only) *********/
static void init_model(void);


main(void)
{
   int i, j, err, which, status, num_muscle_states;
   double t, step, step_size, param[1] = {-1.0};
   double *y, *dy, *work, next_t;
   double start_time, end_time;
   double ke = 0, pe = 0;
   char *muscle_file = NULL, *kinetics_file = NULL;
   char *output_motion_file = NULL;
   char *output_kinetics_file = NULL;
   char *parameters_file_name = "params.txt";
   char e_msg[5000] = "";
   FILE *out, *kin_out;
#if CONTACT_DETECTION
   int num_impacts = 0;
#endif

   sim_message(none, "\nDynamics Pipeline (3.1.2) Simulation.\n");

#if PIPELINE_TRIAL
   check_password();
#endif

   /* fill in sdm struct with model parameters */
   init_model();

   getcwd(current_dir, CHARBUFFER);
   append_if_necessary(current_dir, DIR_SEP_CHAR);

   get_muscle_file_name(parameters_file_name, &muscle_file);

   if (muscle_file)
   {
      if (read_muscle_file(sdm, muscle_file) == code_bad)
         sim_message(exit_program, "Error reading muscle file %s.", muscle_file);
   }
   else
   {
      sdm->num_muscles = 0;
      sim_message(none, "Running simulation without a muscle file.");
   }

   if (read_parameters_file(parameters_file_name, sdm, &kinetics_file,
      &output_motion_file, &output_kinetics_file) == code_bad)
   {
      sim_message(recover, "Unable to load input parameters: %s%s not found.\n", 
             current_dir, parameters_file_name);
   }

   init_joint_functions();
   init_q_restraint_functions();

   /* allocate space for contact records in sdm */
#if CONTACT_DETECTION
   init_contact_info();
#endif

   num_muscle_states = count_muscle_states(sdm);
   sdm->neq = sdm->nu + sdm->nq + num_muscle_states;

   y = (double*)simm_malloc(sdm->neq * sizeof(double));
   dy = (double*)simm_malloc(sdm->neq * sizeof(double));
   work = (double*)simm_malloc(6 * sdm->neq * sizeof(double));
	
   if (kinetics_file)
      set_up_kinetics_input(kinetics_file, &kinetics_data);

   set_initial_conditions(&t, y, dy);

   init_motion();

   sdinit();
   check_for_sderror("SDINIT");
	
   /* enable constraint stabilization */
   sdstab(2.0 * BAUMGARTE_STAB, BAUMGARTE_STAB * BAUMGARTE_STAB);

   assemble_model(t, y);

   sdstate(t, y, &y[sdm->nq]);

   init_muscle_states(sdm, y);

   sim_message(none, "\nSystem assembled (%d bodies, %d Qs, %d Us, %d muscles, %d muscle states).\n",
      sdm->num_body_segments, sdm->nq, sdm->nu, sdm->num_muscles, num_muscle_states);

   if (verbose == dpYes)
      print_body_info();
   
#if CONTACT_DETECTION
   if (verbose == dpYes)
      show_object_info();
#endif

   if (output_motion_file)
   {
      create_output_motion("sd_motion");
      open_output_motion_file(output_motion_file);
   }

   if (output_kinetics_file)
      set_up_kin_out_file(&kin_out, output_kinetics_file);

   check_for_sderror("MAIN");

   if (verbose == dpYes)
   {
      start_time = get_time_now();
      print_state(y, dy);
   }

#if CONTACT_DETECTION
   check_for_initial_penetration(y, dy);
#endif

   /**************************************************************************/
   sim_message(none, "Running simulation from time %lf to %lf (step size = %lf).\n",
               params.startTime, params.endTime, params.stepSize);

   /* Calculate derivatives so the first frame in the output kinetics file will have
    * the correct velocities and accelerations.
    */
	calc_derivatives(t, y, dy, param, &status);

   si.initial_system_energy = MINMDOUBLE;

   if (output_kinetics_file)
      write_kin_out_frame(t, y, dy, &kin_out);

   if (params.outputOptions.systemEnergy == dpYes)
      calc_system_energy(&si);

   if (params.outputOptions.jointReactionForces == dpYes || params.outputOptions.jointReactionTorques == dpYes)
      get_reaction_forces();

   if (params.outputOptions.jointTorques == dpYes)
      calc_joint_torques(t, y, dy);

   /* Moment arms should be calculated last because the function
    * calls sdstate() which resets all of the accelerations to zero.
    */
   if (params.outputOptions.muscleMomentArms == dpYes || params.outputOptions.muscleJointTorques == dpYes ||
       params.outputOptions.totalMuscleJointTorques == dpYes)
      calc_muscle_moment_arms(t, y);

   if (output_motion_file)
      store_motion_frame(t, y);

	for (t = params.startTime; t < params.endTime - TINY_TIME; )
   {
		step = step_size = params.stepSize;
		next_t = t + step_size;
      if (next_t > params.endTime)
      {
         next_t = params.endTime;
         step = step_size = next_t - t;
      }

		print_simulation_info(t, y, &si);		

      /* To make the simulation run faster, don't let the muscle excitations
		 * change during an integration interval. Thus you can compute them here
		 * and store them in the muscle structure. If you are spline-fitting
		 * your excitation data, you don't really need to do this since the
		 * muscle excitations will change smoothly (whereas with step functions
		 * they will not), and thus they will not slow down the integration.
       * Note: Starting with version 2.0.1, all muscle derivative functions in
       * derivs.c depend on the muscle excitation being set here. If you remove
       * the code below, you will need to make sure that excitations are set
       * properly in the derivative function that you use.
		 */
		for (j = 0; j < sdm->num_muscles; j++)
			sdm->muscles[j].excitation_level = calc_excitation(&sdm->muscles[j], t, y);
		
      while (t < next_t - TINY_TIME)
      {
			calc_derivatives(t, y, dy, param, &status);
			integrate(calc_derivatives, &t, y, dy, param, step_size, &step, sdm->neq,
				       INTEGRATION_TOL, work, &err, &which);

         if (err == INT_NO_ERROR)
         {
            break;
         }
#if CONTACT_DETECTION
         else if (err == INT_USER_FLAG)
         {
            if (which == IMPACT_FLAG)
            {
               handle_impacts(t, y, dy);
               num_impacts++;
               step = step_size = next_t - t;
            }
            else if (which == CONS_VIOL)
            {
               store_motion_frame(t, y);
               sim_message(abort_action, "CONSTRAINT VIOLATION at time %lf.", t);
               goto END_SIMULATION;
            }
            else if (which == BAD_STATE)
            {
               store_motion_frame(t, y);
               sim_message(abort_action, "BAD STATE at time %lf.", t);
               goto END_SIMULATION;
            }
         } 
#endif
         else if (err == INT_OVER_BUMP)
         {
            if (which >= 0 && which < sdm->nq)
               sim_message(recover, "INTEGRATOR: went over a bump (gencoord %s [position]).", sdm->q[which].name);
            else if (which >= sdm->nq && which < sdm->nq + sdm->nu)
               sim_message(recover, "INTEGRATOR: went over a bump (gencoord %s [velocity]).", sdm->q[which - sdm->nq].name);
            else
               sim_message(recover, "INTEGRATOR: went over a bump (state vector element %d).", which);
            step_size = next_t - t;
         } 
         else if (err == INT_CANT_CONTINUE)
         {
            sim_message(abort_action, "SDVINTEG: Cannot continue after time = %lf (gc %d).", t, which);
            store_motion_frame(t, y);
            goto END_SIMULATION;
         } 
         else 
         {
            if (which == CONS_VIOL)
               sim_message(abort_action, "Constraint Violation.");
            sdprinterr(stdout);
            goto END_SIMULATION;
         }
      }

      assign_muscle_states(sdm, t, y);

      if (verbose == dpYes)
         print_state(y, dy);

      if (output_kinetics_file)
         write_kin_out_frame(t, y, dy, &kin_out);

      if (params.outputOptions.systemEnergy == dpYes)
         calc_system_energy(&si);

      if (params.outputOptions.jointReactionForces == dpYes || params.outputOptions.jointReactionTorques == dpYes)
			get_reaction_forces();

      if (params.outputOptions.jointTorques == dpYes)
         calc_joint_torques(t, y, dy);

      /* Moment arms should be calculated last because the function
       * calls sdstate() which resets all of the accelerations to zero.
       */
      if (params.outputOptions.muscleMomentArms == dpYes || params.outputOptions.muscleJointTorques == dpYes ||
          params.outputOptions.totalMuscleJointTorques == dpYes)
         calc_muscle_moment_arms(t, y);

      if (output_motion_file)
         store_motion_frame(t, y);
	}

END_SIMULATION:
   sim_message(none, "*** SIMULATION ENDED ***");
   if (verbose == dpYes)
   {
      print_final_information(t, y, dy, &si);
   }

   if (output_motion_file)
   {
      close_output_motion_file();
      sim_message(none, "Motion data written to: %s.", output_motion_file);
   }

   if (output_kinetics_file)
   {
      fclose(kin_out);
      sim_message(none, "Kinetics data written to: %s.", output_kinetics_file);
   }

   free(work);
   free(y);
   free(dy);

   if (verbose == dpYes)
   {
      end_time = get_time_now();
      time_elapsed(start_time, end_time);

#if CONTACT_DETECTION
   	sim_message(none, "%d impact[s] encountered.", num_impacts); 
#endif
   }

   sim_message(none, "\nPress Enter to continue.");
   getc(stdin);

}


static void init_model(void)
{

   int i, info[50];

   params.startTime = 0.0;
   params.endTime = 1.0;
   params.stepSize = 0.01;
   params.outputOptions.contactForces = dpYes;
   params.outputOptions.jointTorques = dpNo;
   params.outputOptions.jointReactionForces = dpNo;
   params.outputOptions.jointReactionTorques = dpNo;
   params.outputOptions.massCenterPositions = dpNo;
   params.outputOptions.massCenterVelocities = dpNo;
   params.outputOptions.muscleMomentArms = dpNo;
   params.outputOptions.muscleJointTorques = dpNo;
   params.outputOptions.totalMuscleJointTorques = dpNo;
   params.outputOptions.muscleActivations = dpYes;
   params.outputOptions.muscleLengths = dpNo;
   params.outputOptions.muscleForces = dpYes;
   params.outputOptions.systemEnergy = dpNo;
   params.outputOptions.numSpringForces = 10;
   params.outputOptions.normalization = dpNoNormalization;

   sdinfo(info);
   sdm = (dpModelStruct*)simm_malloc(sizeof(dpModelStruct));
   sdm->num_body_segments = info[1] + 1;    /* include ground */
   sdm->nq = info[2] + info[7];
   sdm->nu = info[2];
   sdm->num_closed_loops = info[4];
   sdm->num_joints = info[1] + info[4]; /* nbod + nloop */
   sdm->num_constraints = info[3];
   sdm->num_user_constraints = info[10];
   sdm->num_springs = 0;
   sdm->num_spring_floors = 0;
   sdm->num_force_mattes = 0;
   sdm->spring_array_size = ARRAY_INCREMENT;
   sdm->spring_floor_array_size = ARRAY_INCREMENT;
   sdm->force_matte_array_size = ARRAY_INCREMENT;

   init_qs();
   init_segments();
   init_joints();
   init_wrap_objects();
   init_constraint_objects();

#if CONTACT_DETECTION
   makepaths();

   for (i = 0; i < sdm->num_body_segments; i++)
   {
      sdm->body_segment[i].num_objects = 0;
      make_vector(sdm->body_segment[i].impact_force, 0.0, 0.0, 0.0);
      make_vector(sdm->body_segment[i].impact_point, 0.0, 0.0, 0.0);
      make_vector(sdm->body_segment[i].contact_force, 0.0, 0.0, 0.0);
   }
#endif
}


/* SIM_MESSAGE: this function prints an error message depending on the string
 * and error status that is passed in. There is a separate version of
 * this function for the DLL version of a simulation.
 */
int sim_message(ErrorAction action, const char* format, ...)
{
   int n;
   char c;
   va_list ap;

   va_start(ap, format);
   n = vsprintf(buffer, format, ap);
   va_end(ap);

   (void)fprintf(stdout,"%s\n", buffer);

   if (action == recover)
   {
      (void)fprintf(stdout,"Do you want to continue? (y/n)<y>:  ");
      c = getc(stdin);
      if ((c == 'n') || (c == 'N'))
      {
         (void)fprintf(stdout, "Program terminated.\n");
         getc(stdin);
         exit(0);
      }
      else
      {
         (void)fprintf(stdout, "Continuing...\n");
         fflush(stdin);
      }
   }
   else if (action == abort_action)
   {
      (void)fprintf(stdout, "Aborting...\n");
   }
   else if (action == exit_program)
   {
      (void)fprintf(stdout, "Program terminated.\n");
      getc(stdin);
      exit (0);
   }

   return n;

}
