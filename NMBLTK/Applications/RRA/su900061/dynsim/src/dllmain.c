/*******************************************************************************

   DLLMAIN.C

   Authors: Peter Loan
            Krystyne Blaikie

   Version 3.1.2, September 23, 2004

   Copyright (c) 2004 MusculoGraphics, a division of Motion Analysis Corp.
   All rights reserved.

   Description: This file contains the main routine for the DLL version of
      a dynamics simulation (for running within SIMM), and several other
      utility functions that are independent of the musculoskeletal model
      in the simulation. This file is generated by SIMM when you choose the
		"project files" option in the "Save Dynamics" dialog box. You will
      probably want to generate it once (not every time you change your
      model) and then customize it to your specific simulation.

*******************************************************************************/
#include "universal.h"

/*************** DEFINES (for this file only) *********************************/

/* Tolerances and Integration parameters. */
#define BAUMGARTE_STAB 20.0

/*************** STATIC GLOBAL VARIABLES (for this file only) *****************/
char sim_version[] = "3.1.2";
SystemInfo si;
dpDataSetup dataSetup;
dpDataFrame dataFrame;
int (*dataCallbackFunc)(dpSimmModelID, dpDataType, void*) = NULL;
double t, *y, *dy, *work;
FILE *kin_out;
char* output_kinetics_file = NULL;
dpMessageStruct mess;

/**************** GLOBAL VARIABLES (used in only a few files) *****************/
dpModelStruct* sdm;
MotionData* kinetics_data = NULL;
dpSimulationParameters params;
char current_dir[CHARBUFFER];

/*************** EXTERNED VARIABLES (declared in another file) ****************/
extern char buffer[];
extern dpBoolean verbose;

/*************** PROTOTYPES for STATIC FUNCTIONS (for this file only) *********/
static void init_dll_model(void);
static void copyParameters(dpSimulationParameters* from, dpSimulationParameters* to);
static int checkModel(dpModelStruct* model);
static void copyModel(dpModelStruct* from, dpModelStruct* to);
static dpSplineFunction* getFunctionPointer(dpModelStruct* to, dpModelStruct* from, dpSplineFunction* fromPtr);
static void copySplineFunction(dpSplineFunction* from, dpSplineFunction* to);
static void copyPolyhedron(dpPolyhedronStruct* from, dpPolyhedronStruct* to);
static void copyMuscles(dpModelStruct* from, dpModelStruct* to);
static void copyDefaultMuscle(dpMuscleStruct* from, dpMuscleStruct* to, dpModelStruct* ms, dpModelStruct* dp);
static void copyMuscle(dpMuscleStruct* from, dpMuscleStruct* defFrom,
                       dpMuscleStruct* to, dpMuscleStruct* defTo,
                       dpModelStruct* ms, dpModelStruct* dp);


/* dpInitSimulation: this function is called when the "initialize" button
 * is pressed in the Dynamics Tool, before dpSetModel() is called.
 */
DLL int dpInitSimulation(dpSimulationParameters* _params)
{
   copyParameters(_params, &params);

   chdir(params.workingDir);

   memset(&dataSetup, 0, sizeof(dpDataSetup));
   memset(&dataFrame, 0, sizeof(dpDataFrame));

   return 0;
}


/* init_dll_model: this function is called by dpSetModel to finish
 * initializing the sdm structure after the basic model data has been
 * filled in.
 */
static void init_dll_model(void)
{
   int i, info[50];

   sdinfo(info);
   sdm->num_body_segments = info[1] + 1;    /* include ground */
   sdm->nq = info[2] + info[7];
   sdm->nu = info[2];
   sdm->num_closed_loops = info[4];
   sdm->num_joints = info[1] + info[4]; /* nbod + nloop */
   sdm->num_constraints = info[3];
   sdm->num_user_constraints = info[10];

   init_joints();

   /* Set the gravity vector. */
   sdgrav(sdm->gravity);

   /* Compute the coefficients for the constraint functions. */
   for (i = 0; i < sdm->num_constraint_functions; i++)
      finish_spline_func(&sdm->constraint_function[i]);

   /* Compute the coefficients for the muscle functions. */
   finish_spline_func(sdm->default_muscle.tendon_force_len_curve);
   finish_spline_func(sdm->default_muscle.active_force_len_curve);
   finish_spline_func(sdm->default_muscle.passive_force_len_curve);
   finish_spline_func(sdm->default_muscle.force_vel_curve);
   finish_spline_func(sdm->default_muscle.excitation);

   for (i = 0; i < sdm->num_muscles; i++)
   {
      if (sdm->muscles[i].tendon_force_len_curve != sdm->default_muscle.tendon_force_len_curve)
         finish_spline_func(sdm->muscles[i].tendon_force_len_curve);
      if (sdm->muscles[i].active_force_len_curve != sdm->default_muscle.active_force_len_curve)
         finish_spline_func(sdm->muscles[i].active_force_len_curve);
      if (sdm->muscles[i].passive_force_len_curve != sdm->default_muscle.passive_force_len_curve)
         finish_spline_func(sdm->muscles[i].passive_force_len_curve);
      if (sdm->muscles[i].force_vel_curve != sdm->default_muscle.force_vel_curve)
         finish_spline_func(sdm->muscles[i].force_vel_curve);
      if (sdm->muscles[i].excitation != sdm->default_muscle.excitation)
         finish_spline_func(sdm->muscles[i].excitation);
   }

#if CONTACT_DETECTION
   /* Determine how to get from one segment to another. */
   makepaths();
#endif

   /* Set the masses and mass_center to joint vectors in the SD/FAST code,
    * based on their values in the model passed in from SIMM.
    */
   for (i = 1; i < sdm->num_body_segments; i++)
   {
      sdmass(i - 1, sdm->body_segment[i].mass);
      if (check_for_sderror("SET_MASS") == 19)
      {
         sdgetmass(i - 1, &sdm->body_segment[i].mass);
      }

      sdiner(i - 1, sdm->body_segment[i].inertia);
      if (check_for_sderror("SET_INERTIA") == 19)
      {
         sdgetiner(i - 1, sdm->body_segment[i].inertia);
      }

      sdbtj(i - 1, sdm->body_segment[i].body_to_joint);
      if (check_for_sderror("SET_BODY_TO_JOINT") == 19)
      {
         sdgetbtj(i - 1, sdm->body_segment[i].body_to_joint);
      }

      sditj(i - 1, sdm->body_segment[i].inboard_to_joint);
      if (check_for_sderror("SET_INBOARD_TO_JOINT") == 19)
      {
         sdgetitj(i - 1, sdm->body_segment[i].inboard_to_joint);
      }
   }

   /* Make space for the muscle moment arms, if appropriate. */
   if (params.outputOptions.muscleMomentArms == dpYes ||
       params.outputOptions.muscleJointTorques == dpYes ||
       params.outputOptions.totalMuscleJointTorques == dpYes)
   {
      for (i = 0; i < sdm->num_muscles; i++)
      {
         sdm->muscles[i].nummomentarms = sdm->nq;
         sdm->muscles[i].momentarms = (double*)simm_malloc(sdm->muscles[i].nummomentarms * sizeof(double));
      }
   }
}


/* dpRegisterCallback: this function stores the name of a callback function in
 * a global variable. This callback is called with output data after each iteration
 * of the integrator. It is used to pass simulation results and messages back
 * into SIMM.
 */
DLL int dpRegisterCallback(int (*dataCallback)(dpSimmModelID, dpDataType, void*))
{
   dataCallbackFunc = dataCallback;
   return 0;
}


/* dpSetModel: this function is called when the "initialize" button is pressed
 * in the Dynamics Tool. It takes a dpModelStruct containing a complete description
 * of the SIMM model, and copies the information to the global variable sdm. It
 * then assembles the model, initializes the state vector and other variables,
 * then opens the appropriate output files.
 */
DLL int dpSetModel(dpModelStruct* model)
{
   int i, status, num_muscle_states;
   double param[1] = {-1.0};
   char *dllparameters_file_name = "dllparams.txt";

   /* Copy the dpModelStruct to memory that is local to the DLL. */
   sdm = (dpModelStruct*)simm_calloc(1, sizeof(dpModelStruct));
   copyModel(model, sdm);

   /* Check to make sure the model is consistent with the one built
    * into the DLL (from model.sd).
    */
   if (checkModel(sdm) < 0)
   {
      mess.id = dpFinished;
      sprintf(mess.text, "Cannot run this simulation DLL with %s.", model->name);
      dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
      return -1;
   }

   num_muscle_states = count_muscle_states(sdm);
   sdm->neq = sdm->nu + sdm->nq + num_muscle_states;

   y = (double*)simm_malloc(sdm->neq * sizeof(double));
   dy = (double*)simm_malloc(sdm->neq * sizeof(double));
   work = (double*)simm_malloc(6 * sdm->neq * sizeof(double));

   if (params.inputMotionFile)
      set_up_kinetics_input(params.inputMotionFile, &kinetics_data);

   read_dllparameters_file(dllparameters_file_name, sdm);

   init_dll_model();
   set_initial_conditions(&t, y, dy);
   init_motion();

   sdinit();
   check_for_sderror("SDINIT");
	
   /* enable constraint stabilization */
   sdstab(2.0 * BAUMGARTE_STAB, BAUMGARTE_STAB * BAUMGARTE_STAB);

   assemble_model(t, y);

   sdstate(t, y, &y[sdm->nq]);

   init_muscle_states(sdm, y);

   if (params.outputOptions.normalization != dpNoNormalization)
      params.stepSize = (params.endTime - params.startTime) / 99.0;

   if (params.outputMotionFile || dataCallbackFunc)
   {
      if (kinetics_data && kinetics_data->name)
      {
         /* If the name of the input motion ends in "_IN", remove that
          * part and replace it with "_OUT".
          */
         int len = strlen(kinetics_data->name);
         strcpy(buffer, kinetics_data->name);
         if (len >= 3 && STRINGS_ARE_EQUAL(&buffer[len - 3], "_IN"))
            strcpy(&buffer[len - 3], "_OUT");
      }
      else
      {
         strcpy(buffer, "sim_motion_OUT");
      }

      create_output_motion(buffer);
      if (params.outputMotionFile)
         open_output_motion_file(params.outputMotionFile);
   }

   if (output_kinetics_file)
      set_up_kin_out_file(&kin_out, output_kinetics_file);

   check_for_sderror("DLLMAIN");

#if CONTACT_DETECTION
   check_for_initial_penetration(y, dy);
#endif

   /* Now that the model is assembled, return a dpSetup frame to SIMM,
    * so it can create a motion to hold the simulation results.
    */
   if (dataCallbackFunc)
   {
      dataSetup.startTime = params.startTime;
      dataSetup.endTime = params.endTime;

      get_motion_info(&dataSetup);

      dataCallbackFunc(sdm->simmModel, dpSetup, &dataSetup);

      dataFrame.numElements = dataSetup.numElements;
      dataFrame.elements = (double*)simm_malloc(dataFrame.numElements * sizeof(double));
   }

   /* Calculate derivatives so the first frame in the output kinetics file will have
    * the correct velocities and accelerations.
    */
	calc_derivatives(t, y, dy, param, &status);

   si.initial_system_energy = MINMDOUBLE;

   if (output_kinetics_file)
      write_kin_out_frame(t, y, dy, &kin_out);

   if (params.outputOptions.systemEnergy == dpYes)
      calc_system_energy(&si);

   if (params.outputOptions.jointReactionForces == dpYes || params.outputOptions.jointReactionTorques == dpYes)
      get_reaction_forces();

   if (params.outputOptions.jointTorques == dpYes)
      calc_joint_torques(t, y, dy);

   /* Moment arms should be calculated last because the function
    * calls sdstate() which resets all of the accelerations to zero.
    */
   if (params.outputOptions.muscleMomentArms == dpYes || params.outputOptions.muscleJointTorques == dpYes ||
       params.outputOptions.totalMuscleJointTorques == dpYes)
      calc_muscle_moment_arms(t, y);

   /* Store the starting position in the output motion, and return it to SIMM. */
   if (dataCallbackFunc)
   {
      store_motion_frame(t, y);

      get_motion_data(&dataFrame);

      dataCallbackFunc(sdm->simmModel, dpFrame, &dataFrame);
   }
   else if (params.outputMotionFile)
   {
      store_motion_frame(t, y);
   }

   mess.id = dpInitialized;
   sprintf(mess.text, "Simulation (version %s) initialized at time = %lf", sim_version, t);
   dataCallbackFunc(sdm->simmModel, dpMessage, &mess);

   return 0;
}


/* dpRunSimulation: this function is called when the "run" button is pressed in
 * the Dynamics Tool. It contains the main integration for loop for the simulation.
 */
DLL int dpRunSimulation(int code)
{
   int i, err, which, status, num_impacts = 0;
   double step, step_size, next_t;
   double param[1] = {-1.0};
   dpMessageStruct mess;

	for (t = params.startTime; t < params.endTime - TINY_TIME; )
   {
		step = step_size = params.stepSize;
		next_t = t + step_size;
      if (next_t > params.endTime)
      {
         next_t = params.endTime;
         step = step_size = next_t - t;
      }

		print_simulation_info(t, y, &si);		

      /* To make the simulation run faster, don't let the muscle excitations
		 * change during an integration interval. Thus you can compute them here
		 * and store them in the muscle structure. If you are spline-fitting
		 * your excitation data, you don't really need to do this since the
		 * muscle excitations will change smoothly (whereas with step functions
		 * they will not), and thus they will not slow down the integration.
       * Note: Starting with version 2.0.1, all muscle derivative functions in
       * derivs.c depend on the muscle excitation being set here. If you remove
       * the code below, you will need to make sure that excitations are set
       * properly in the derivative function that you use.
		 */
		for (i = 0; i < sdm->num_muscles; i++)
			sdm->muscles[i].excitation_level = calc_excitation(&sdm->muscles[i], t, y);
		
      while (t < next_t - TINY_TIME)
      {
			calc_derivatives(t, y, dy, param, &status);
			integrate(calc_derivatives, &t, y, dy, param, step_size, &step, sdm->neq,
				       INTEGRATION_TOL, work, &err, &which);

         if (err == INT_NO_ERROR)
         {
            break;
         }
#if CONTACT_DETECTION
         else if (err == INT_USER_FLAG)
         {
            if (which == IMPACT_FLAG)
            {
               handle_impacts(t, y, dy);
               num_impacts++;
               step = step_size = next_t - t;
            }
            else if (which == CONS_VIOL)
            {
               store_motion_frame(t, y);
               sim_message(abort_action, "CONSTRAINT VIOLATION at time %lf.", t);
               goto END_SIMULATION;
            }
            else if (which == BAD_STATE)
            {
               store_motion_frame(t, y);
               sim_message(abort_action, "BAD STATE at time %lf.", t);
               goto END_SIMULATION;
            }
         } 
#endif
         else if (err == INT_OVER_BUMP)
         {
            if (which >= 0 && which < sdm->nq)
               sim_message(recover, "INTEGRATOR: went over a bump (gencoord %s [position]).", sdm->q[which].name);
            else if (which >= sdm->nq && which < sdm->nq + sdm->nu)
               sim_message(recover, "INTEGRATOR: went over a bump (gencoord %s [velocity]).", sdm->q[which - sdm->nq].name);
            else
               sim_message(recover, "INTEGRATOR: went over a bump (state vector element %d).", which);
            step_size = next_t - t;
         } 
         else if (err == INT_CANT_CONTINUE)
         {
            sim_message(abort_action, "SDVINTEG: Cannot continue after time = %lf (gc %d).", t, which);
            store_motion_frame(t, y);
            goto END_SIMULATION;
         } 
         else 
         {
            if (which == CONS_VIOL)
               sim_message(abort_action, "Constraint Violation.");
            goto END_SIMULATION;
         }
      }

      assign_muscle_states(sdm, t, y);

      if (verbose == dpYes)
         print_state(y, dy);

      if (output_kinetics_file)
         write_kin_out_frame(t, y, dy, &kin_out);

      if (params.outputOptions.systemEnergy == dpYes)
         calc_system_energy(&si);

      if (params.outputOptions.jointReactionForces == dpYes || params.outputOptions.jointReactionTorques == dpYes)
			get_reaction_forces();

      if (params.outputOptions.jointTorques == dpYes)
         calc_joint_torques(t, y, dy);

      /* Moment arms should be calculated last because the function
       * calls sdstate() which resets all of the accelerations to zero.
       */
      if (params.outputOptions.muscleMomentArms == dpYes || params.outputOptions.muscleJointTorques == dpYes ||
          params.outputOptions.totalMuscleJointTorques == dpYes)
         calc_muscle_moment_arms(t, y);

      if (dataCallbackFunc)
      {
         store_motion_frame(t, y);

         get_motion_data(&dataFrame);

         dataCallbackFunc(sdm->simmModel, dpFrame, &dataFrame);
      }
      else if (params.outputMotionFile)
      {
         store_motion_frame(t, y);
      }

      mess.id = dpOverwritable;
      sprintf(mess.text, "SIM> Simulation currently at time = %lf", t);
      dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
   }

END_SIMULATION:
   if (params.outputMotionFile)
      close_output_motion_file();

   if (output_kinetics_file)
      fclose(kin_out);

   free(work);
   free(y);
   free(dy);

   FREE_IFNOTNULL(dataFrame.elements);

   FREE_IFNOTNULL(dataSetup.motionName);

   if (dataSetup.elementNames)
   {
      for (i = 0; i < dataSetup.numElements; i++)
         FREE_IFNOTNULL(dataSetup.elementNames[i]);
      FREE_IFNOTNULL(dataSetup.elementNames);
   }

   if (dataSetup.event)
   {
      for (i = 0; i < dataSetup.numEvents; i++)
         FREE_IFNOTNULL(dataSetup.event[i].name);
      FREE_IFNOTNULL(dataSetup.event);
   }

   mess.id = dpFinished;
   sprintf(mess.text, "Simulation finished at time = %lf", t);
   dataCallbackFunc(sdm->simmModel, dpMessage, &mess);

   return 0;
}


/* dpPauseSimulation: this function is currently not used. When the "pause"
 * button is pressed in the Dynamics Tool, SIMM suspends the simulation thread,
 * so the simulation never receives a message that it has been paused.
 */
DLL int dpPauseSimulation(int code)
{
   return 0;
}


/* dpResetSimulation: this function is called when the "reset" button is pressed
 * in the Dynamics Tool. SIMM then frees the DLL from memory and exits the simulation
 * thread.
 */
DLL int dpResetSimulation(int code)
{
   if (sdm)
      FREE_IFNOTNULL(sdm->joint);

   return 0;
}


/* copyParameters: this function copies the simulation parameters into the DLL. */
static void copyParameters(dpSimulationParameters* from, dpSimulationParameters* to)
{
   to->startTime = from->startTime;
   to->endTime = from->endTime;
   to->stepSize = from->stepSize;

   if (from->workingDir)
      mstrcpy(&to->workingDir, from->workingDir);

   if (from->inputMotionFile)
      mstrcpy(&to->inputMotionFile, from->inputMotionFile);

   if (from->outputMotionFile)
      mstrcpy(&to->outputMotionFile, from->outputMotionFile);

   if (from->boneDir)
      mstrcpy(&to->boneDir, from->boneDir);

   memcpy(&to->outputOptions, &from->outputOptions, sizeof(dpOutputOptions));
}


/* checkModel: this function checks to make sure that the SIMM model passed into
 * the DLL (via dpSetModel()) is the same model that is built into the DLL (iin
 * the file model.sd).
 */
static int checkModel(dpModelStruct* model)
{
   int i, info[50], slider[6];
   dpBoolean fatalError = dpNo;
   dpMessageStruct mess;

   mess.id = dpModelError;

   sdinfo(info);

   if (model->num_body_segments != (info[1] + 1))
   {
      sprintf(mess.text, "Number of segments in simulation DLL (%d) does not match number in SIMM model (%d)",
         (info[1] + 1), model->num_body_segments);
      dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
      fatalError = dpYes;
   }

   if (model->num_joints != info[1])
   {
      sprintf(mess.text, "Number of tree joints in simulation DLL (%d) does not match number of joints in SIMM model (%d)",
         info[1], model->num_joints);
      dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
      fatalError = dpYes;
   }

   if (model->num_closed_loops != info[4])
   {
      sprintf(mess.text, "Number of loop joints in simulation DLL (%d) does not match number in SIMM model (%d)",
         info[4], model->num_closed_loops);
      dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
      fatalError = dpYes;
   }

   if (fatalError == dpNo)
   {
      for (i = 0; i < model->num_joints; i++)
      {
         sdjnt(i, info, slider);
         switch (info[0])
         {
            case 1: // pin
               if (model->joint[i].jnt_type != dpPin && model->joint[i].jnt_type != dpReversePin && model->joint[i].jnt_type != dpWeld)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (pin) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 2: // ujoint
               if (model->joint[i].jnt_type != dpUniversal && model->joint[i].jnt_type != dpReverseUniversal)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (universal) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 3: // gimbal
               if (model->joint[i].jnt_type != dpGimbal && model->joint[i].jnt_type != dpReverseGimbal)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (gimbal) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 4: // ball
               if (model->joint[i].jnt_type != dpBall && model->joint[i].jnt_type != dpReverseBall)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (ball) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 5: // slider
               if (model->joint[i].jnt_type != dpSlider && model->joint[i].jnt_type != dpReverseSlider)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (slider) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 6: // free
               if (model->joint[i].jnt_type != dpFree)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (free) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 7: // cylindrical
               if (model->joint[i].jnt_type != dpCylindrical && model->joint[i].jnt_type != dpReverseCylindrical)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (cylindrical) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 8: // planar
               if (model->joint[i].jnt_type != dpPlanar)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (planar) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 9: // weld
               if (model->joint[i].jnt_type != dpWeld)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (weld) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 10: // bushing
               if (model->joint[i].jnt_type != dpBushing)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (bushing) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 11: // bearing
               if (model->joint[i].jnt_type != dpBearing)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (bearing) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 20: // rplanar
               if (model->joint[i].jnt_type != dpReversePlanar)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (reverse planar) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 21: // rfree
               if (model->joint[i].jnt_type != dpReverseFree)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (reverse free) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 22: // rbushing
               if (model->joint[i].jnt_type != dpReverseBushing)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (reverse bushing) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
            case 23: // rbearing
               if (model->joint[i].jnt_type != dpReverseBearing)
               {
                  sprintf(mess.text, "Type of joint %d in simulation DLL (reverse bearing) does not match type in SIMM.", i + 1);
                  dataCallbackFunc(sdm->simmModel, dpMessage, &mess);
               }
               break;
         }
      }
   }

   if (fatalError == dpYes)
      return -1;
   else
      return 1;
}


/* copyModel: this function one dpModelStruct to another. It is used
 * to copy the model in SIMM memory to one in DLL memory.
 */
static void copyModel(dpModelStruct* from, dpModelStruct* to)
{
   int i, j;

   memcpy(to, from, sizeof(dpModelStruct));

   if (from->name)
      mstrcpy(&to->name, from->name);

   if (to->num_dynamic_params > 0 && from->dynamic_param_names)
   {
      to->dynamic_param_names = (char**)simm_malloc(to->num_dynamic_params * sizeof(char*));
      for (i = 0; i < to->num_dynamic_params; i++)
         mstrcpy(&to->dynamic_param_names[i], from->dynamic_param_names[i]);
   }

#if CONTACT_DETECTION
   init_contact_info();
#else
   sdm->num_contacts = sdm->contacts_size = 0;
   sdm->num_bilat_contacts = sdm->bilat_contacts_size = 0;
   sdm->contacts = NULL;
   sdm->bilat_contacts = NULL;
#endif

   if (to->num_springs > 0 && from->spring)
   {
      to->spring = (dpSpringStruct*)simm_malloc(to->num_springs * sizeof(dpSpringStruct));
      memcpy(to->spring, from->spring, to->num_springs * sizeof(dpSpringStruct));
      for (i = 0; i < to->num_springs; i++)
         mstrcpy(&to->spring[i].floor_name, from->spring[i].floor_name);
      to->spring_array_size = to->num_springs;
   }

   if (to->num_spring_floors > 0 && from->spring_floor)
   {
      to->spring_floor = (dpSpringFloor*)simm_malloc(to->num_spring_floors * sizeof(dpSpringFloor));
      memcpy(to->spring_floor, from->spring_floor, to->num_spring_floors * sizeof(dpSpringFloor));
      for (i = 0; i < to->num_spring_floors; i++)
      {
         mstrcpy(&to->spring_floor[i].name, from->spring_floor[i].name);
         if (from->spring_floor[i].ph)
         {
            to->spring_floor[i].ph = (dpPolyhedronStruct*)simm_malloc(sizeof(dpPolyhedronStruct));
            copyPolyhedron(from->spring_floor[i].ph, to->spring_floor[i].ph);
         }
      }
   }

   if (to->num_force_mattes > 0 && from->force_matte)
   {
      to->force_matte = (dpForceMatte*)simm_malloc(to->num_force_mattes * sizeof(dpForceMatte));
      for (i = 0; i < to->num_force_mattes; i++)
      {
         mstrcpy(&to->force_matte[i].name, from->force_matte[i].name);
         to->force_matte[i].segment = from->force_matte[i].segment;
         if (from->force_matte[i].ph)
         {
            to->force_matte[i].ph = (dpPolyhedronStruct*)simm_malloc(sizeof(dpPolyhedronStruct));
            copyPolyhedron(from->force_matte[i].ph, to->force_matte[i].ph);
         }
      }
   }

   if (to->num_body_segments > 0 && from->body_segment)
   {
      to->body_segment = (dpBodyStruct*)simm_malloc(to->num_body_segments * sizeof(dpBodyStruct));
      memcpy(to->body_segment, from->body_segment, to->num_body_segments * sizeof(dpBodyStruct));
      for (i = 0; i < to->num_body_segments; i++)
      {
         dpBodyStruct* body = &to->body_segment[i];
         mstrcpy(&body->name, from->body_segment[i].name);
         body->contact_joints = NULL;
         if (body->num_objects > 0 && from->body_segment[i].object)
         {
            body->object = (dpPolyhedronStruct**)simm_malloc(body->num_objects * sizeof(dpPolyhedronStruct*));
            for (j = 0; j < body->num_objects; j++)
            {
               body->object[j] = (dpPolyhedronStruct*)simm_malloc(sizeof(dpPolyhedronStruct));
               copyPolyhedron(from->body_segment[i].object[j], body->object[j]);
            }
         }
         else
         {
            body->object = NULL;
         }
      }
   }

   copyMuscles(from, to);

   /* Most of the joint array is filled in later, but some of it needs to be copied
    * so you can check to make sure the models match.
    */
   if (to->num_joints > 0)
   {
      to->joint = (dpJointStruct*)simm_malloc(to->num_joints * sizeof(dpJointStruct));
      memcpy(to->joint, from->joint, to->num_joints * sizeof(dpJointStruct));
   }

   if (to->num_wrap_objects > 0 && from->wrap_object)
   {
      to->wrap_object = (dpWrapObject*)simm_malloc(to->num_wrap_objects * sizeof(dpWrapObject));
      memcpy(to->wrap_object, from->wrap_object, to->num_wrap_objects * sizeof(dpWrapObject));
      for (i = 0; i < to->num_wrap_objects; i++)
         mstrcpy(&to->wrap_object[i].name, from->wrap_object[i].name);
   }

   if (to->num_constraint_objects > 0 && from->constraint_object)
   {
      to->constraint_object = (dpConstraintObject*)simm_malloc(to->num_constraint_objects * sizeof(dpConstraintObject));
      memcpy(to->constraint_object, from->constraint_object, to->num_constraint_objects * sizeof(dpConstraintObject));
      for (i = 0; i < to->num_constraint_objects; i++)
      {
         dpConstraintObject* obj = &to->constraint_object[i];
         mstrcpy(&obj->name, from->constraint_object[i].name);
         if (obj->numPoints > 0 && from->constraint_object[i].points)
         {
            obj->points = (dpConstraintPoint*)simm_malloc(obj->numPoints * sizeof(dpConstraintPoint));
            memcpy(obj->points, from->constraint_object[i].points, obj->numPoints * sizeof(dpConstraintPoint));
            for (j = 0; j < obj->numPoints; j++)
               mstrcpy(&obj->points[j].name, from->constraint_object[i].points[j].name);
         }
      }
   }

   if (to->num_constraint_functions > 0 && from->constraint_function)
   {
      to->constraint_function = (dpSplineFunction*)simm_malloc(to->num_constraint_functions * sizeof(dpSplineFunction));
      for (i = 0; i < to->num_constraint_functions; i++)
      {
         copySplineFunction(&from->constraint_function[i], &to->constraint_function[i]);
         finish_spline_func(&to->constraint_function[i]);
      }
   }

   /* This must be done after the constraint functions because the Qs contain
    * pointers to the functions.
    */
   if (to->nq > 0 && from->q)
   {
      to->q = (dpQStruct*)simm_malloc(to->nq * sizeof(dpQStruct));
      memcpy(to->q, from->q, to->nq * sizeof(dpQStruct));
      for (i = 0; i < to->nq; i++)
      {
         mstrcpy(&to->q[i].name, from->q[i].name);
         to->q[i].restraint_func = getFunctionPointer(to, from, from->q[i].restraint_func);
         to->q[i].min_restraint_func = getFunctionPointer(to, from, from->q[i].min_restraint_func);
         to->q[i].max_restraint_func = getFunctionPointer(to, from, from->q[i].max_restraint_func);
         to->q[i].constraint_func = getFunctionPointer(to, from, from->q[i].constraint_func);
      }
   }

   to->enforce_constraints = from->enforce_constraints;
}


/* getFunctionPointer: this function scans an array of dpSplineFunctions (the 'from' array),
 * looking for one that matches the passed-in pointer. It returns a pointer to the
 * corresponding dpSplineFunction in the 'to' array.
 */
static dpSplineFunction* getFunctionPointer(dpModelStruct* to, dpModelStruct* from, dpSplineFunction* fromPtr)
{
   if (to && from && fromPtr)
   {
      int i;

      for (i = 0; i < from->num_constraint_functions; i++)
         if (fromPtr == &from->constraint_function[i])
            return &to->constraint_function[i];
   }

   return NULL;
}


/* copySplineFunction: this function makes a copy of a dpSplineFunction. */
static void copySplineFunction(dpSplineFunction* from, dpSplineFunction* to)
{
   malloc_function(to, from->numpoints);

   to->type = from->type;
   to->numpoints = from->numpoints;
   to->cutoff_frequency = from->cutoff_frequency;
   to->usernum = from->usernum;

   if (from->x)
      memcpy(to->x, from->x, to->numpoints * sizeof(double));
   if (from->y)
      memcpy(to->y, from->y, to->numpoints * sizeof(double));
   if (from->b)
      memcpy(to->b, from->b, to->numpoints * sizeof(double));
   if (from->c)
      memcpy(to->c, from->c, to->numpoints * sizeof(double));
   if (from->d)
      memcpy(to->d, from->d, to->numpoints * sizeof(double));
}


/* copyPolyhedron: this function makes a copy of a dpPolyhedronStruct. */
static void copyPolyhedron(dpPolyhedronStruct* from, dpPolyhedronStruct* to)
{
   int i;

   if (from->name)
      mstrcpy(&to->name, from->name);

   to->body_segment = from->body_segment;

   memcpy(&to->bc, &from->bc, sizeof(dpBoundingCube));

   if (from->num_vertices > 0 && from->vertex)
   {
      to->num_vertices = from->num_vertices;
      to->vertex = (dpVertexStruct*)simm_malloc(to->num_vertices * sizeof(dpVertexStruct));
      memcpy(to->vertex, from->vertex, to->num_vertices * sizeof(dpVertexStruct));
      for (i = 0; i < to->num_vertices; i++)
      {
         to->vertex[i].polygons = (int*)simm_malloc(to->vertex[i].polygon_count * sizeof(int));
         memcpy(to->vertex[i].polygons, from->vertex[i].polygons, to->vertex[i].polygon_count * sizeof(int));
      }
   }
   else
   {
      to->num_vertices = 0;
      to->vertex = NULL;
   }

   if (from->num_polygons > 0 && from->polygon)
   {
      to->num_polygons = from->num_polygons;
      to->polygon = (dpPolygonStruct*)simm_malloc(to->num_polygons * sizeof(dpPolygonStruct));
      memcpy(to->polygon, from->polygon, to->num_polygons * sizeof(dpPolygonStruct));
      for (i = 0; i < to->num_polygons; i++)
      {
         to->polygon[i].vertex_index = (int*)simm_malloc(to->polygon[i].num_vertices * sizeof(int));
         memcpy(to->polygon[i].vertex_index, from->polygon[i].vertex_index, to->polygon[i].num_vertices * sizeof(int));
      }
   }
   else
   {
      to->num_polygons = 0;
      to->polygon = NULL;
   }
}


/* copyMusles: this function copies the default muscle and array of muscles
 * from one dpModelStruct (in SIMM memory) to another (in DLL memory).
 */
static void copyMuscles(dpModelStruct* from, dpModelStruct* to)
{
   int i;

   to->num_muscles = from->num_muscles;

   to->muscles = (dpMuscleStruct*)simm_malloc(to->num_muscles * sizeof(dpMuscleStruct));

   copyDefaultMuscle(&from->default_muscle, &to->default_muscle, from, to);

   for (i = 0; i < to->num_muscles; i++)
      copyMuscle(&from->muscles[i], &from->default_muscle, &to->muscles[i], &to->default_muscle, from, to);
}


/* copyDefaultMuscle: this function makes a copy of the default muscle. */
static void copyDefaultMuscle(dpMuscleStruct* from, dpMuscleStruct* to, dpModelStruct* ms, dpModelStruct* dp)
{
   int i;

   if (from->name == NULL)
      to->name = NULL;
   else
      mstrcpy(&to->name, from->name);

   to->has_wrapping_points = from->has_wrapping_points;
   to->has_force_points = from->has_force_points;

   if (from->num_orig_points == NULL)
   {
      to->num_orig_points = NULL;
      to->mp_orig = NULL;
   }
   else
   {
      to->num_orig_points = (int*)simm_malloc(sizeof(int));
      *to->num_orig_points = *from->num_orig_points;
      to->mp_orig = (dpMusclePoint*)simm_malloc(*to->num_orig_points * sizeof(dpMusclePoint));
      memcpy(to->mp_orig, from->mp_orig, *to->num_orig_points * sizeof(dpMusclePoint));
      for (i = 0; i < *to->num_orig_points; i++)
      {
         if (to->mp_orig[i].num_wrap_pts > 0 && from->mp_orig[i].wrap_pts)
         {
            to->mp_orig[i].wrap_pts = (double*)simm_malloc(to->mp_orig[i].num_wrap_pts * 3 * sizeof(double));
            memcpy(to->mp_orig[i].wrap_pts, from->mp_orig[i].wrap_pts, to->mp_orig[i].num_wrap_pts * 3 * sizeof(double));
         }
         else
         {
            to->mp_orig[i].wrap_pts = NULL;
         }

         if (to->mp_orig[i].numranges > 0 && from->mp_orig[i].ranges)
         {
            to->mp_orig[i].ranges = (dpPointRange*)simm_malloc(to->mp_orig[i].numranges * sizeof(dpPointRange));
            memcpy(to->mp_orig[i].ranges, from->mp_orig[i].ranges, to->mp_orig[i].numranges * sizeof(dpPointRange));
         }
      }
   }

   to->nummomentarms = 0;
   to->momentarms = NULL;

   copy_nndouble(from->max_isometric_force, &to->max_isometric_force);
   copy_nndouble(from->pennation_angle, &to->pennation_angle);
   copy_nndouble(from->max_contraction_vel, &to->max_contraction_vel);
   copy_nndouble(from->optimal_fiber_length,&to->optimal_fiber_length);
   copy_nndouble(from->resting_tendon_length,&to->resting_tendon_length);

   to->num_dynamic_params = from->num_dynamic_params;
   if (to->num_dynamic_params > 0)
   {
      to->dynamic_param_names = dp->dynamic_param_names;
      to->dynamic_params = (double**)simm_malloc(to->num_dynamic_params * sizeof(double*));
      for (i = 0; i < to->num_dynamic_params; i++)
         copy_nndouble(from->dynamic_params[i], &to->dynamic_params[i]);
   }
   else
   {
      to->dynamic_param_names = NULL;
      to->dynamic_params = NULL;
   }

   if (from->active_force_len_curve == NULL)
      to->active_force_len_curve = NULL;
   else
   {
      to->active_force_len_curve = (dpSplineFunction*)simm_calloc(1, sizeof(dpSplineFunction));
      copySplineFunction(from->active_force_len_curve, to->active_force_len_curve);
   }

   if (from->passive_force_len_curve == NULL)
      to->passive_force_len_curve = NULL;
   else
   {
      to->passive_force_len_curve = (dpSplineFunction*)simm_calloc(1, sizeof(dpSplineFunction));
      copySplineFunction(from->passive_force_len_curve, to->passive_force_len_curve);
   }

   if (from->tendon_force_len_curve == NULL)
      to->tendon_force_len_curve = NULL;
   else
   {
      to->tendon_force_len_curve = (dpSplineFunction*)simm_calloc(1, sizeof(dpSplineFunction));
      copySplineFunction(from->tendon_force_len_curve, to->tendon_force_len_curve);
   }

   if (from->force_vel_curve == NULL)
      to->force_vel_curve = NULL;
   else
   {
      to->force_vel_curve = (dpSplineFunction*)simm_calloc(1, sizeof(dpSplineFunction));
      copySplineFunction(from->force_vel_curve, to->force_vel_curve);
   }

   to->excitation_abscissa = from->excitation_abscissa;
   if (from->excitation == NULL)
      to->excitation = NULL;
   else
   {
      to->excitation = (dpSplineFunction*)simm_calloc(1, sizeof(dpSplineFunction));
      copySplineFunction(from->excitation, to->excitation);
   }

   if (from->excitation_format == NULL)
      to->excitation_format = NULL;
   else
   {
      to->excitation_format = (dpSplineType*)simm_malloc(sizeof(dpSplineType));
      *to->excitation_format = *from->excitation_format;
   }

   copy_nnint(from->muscle_model_index, &to->muscle_model_index);
}


/* copyMuscle: this function makes a copy of a muscle. */
static void copyMuscle(dpMuscleStruct* from, dpMuscleStruct* defFrom,
                       dpMuscleStruct* to, dpMuscleStruct* defTo,
                       dpModelStruct* ms, dpModelStruct* dp)
{
   int i;

   /* Start by zero-ing out the entire muscle structure. */
   memset(to, 0, sizeof(dpMuscleStruct));

   if (from->name == defFrom->name)
      to->name = defTo->name;
   else
      mstrcpy(&to->name, from->name);

   to->display = from->display;
   to->output = from->output;
   to->selected = from->selected;
   to->has_wrapping_points = from->has_wrapping_points;
   to->has_force_points = from->has_force_points;

   if (from->num_orig_points == defFrom->num_orig_points)
      to->num_orig_points = defTo->num_orig_points;
   else
   {
      to->num_orig_points = (int*)simm_malloc(sizeof(int));
      *to->num_orig_points = *from->num_orig_points;
   }

   if (from->mp_orig == defFrom->mp_orig)
      to->mp_orig = defTo->mp_orig;
   else
   {
      to->mp_orig = (dpMusclePoint*)simm_malloc(*to->num_orig_points * sizeof(dpMusclePoint));
      memcpy(to->mp_orig, from->mp_orig, *to->num_orig_points * sizeof(dpMusclePoint));
      for (i = 0; i < *to->num_orig_points; i++)
      {
         if (to->mp_orig[i].num_wrap_pts > 0 && from->mp_orig[i].wrap_pts)
         {
            to->mp_orig[i].wrap_pts = (double*)simm_malloc(to->mp_orig[i].num_wrap_pts * 3 * sizeof(double));
            memcpy(to->mp_orig[i].wrap_pts, from->mp_orig[i].wrap_pts, to->mp_orig[i].num_wrap_pts * 3 * sizeof(double));
         }
         else
         {
            to->mp_orig[i].wrap_pts = NULL;
         }

         if (to->mp_orig[i].numranges > 0 && from->mp_orig[i].ranges)
         {
            to->mp_orig[i].ranges = (dpPointRange*)simm_malloc(to->mp_orig[i].numranges * sizeof(dpPointRange));
            memcpy(to->mp_orig[i].ranges, from->mp_orig[i].ranges, to->mp_orig[i].numranges * sizeof(dpPointRange));
         }
      }
   }

   copy_nddouble(from->max_isometric_force, &to->max_isometric_force,
                 defFrom->max_isometric_force, defTo->max_isometric_force);

   copy_nddouble(from->pennation_angle, &to->pennation_angle,
                 defFrom->pennation_angle, defTo->pennation_angle);

   copy_nddouble(from->optimal_fiber_length, &to->optimal_fiber_length,
                 defFrom->optimal_fiber_length, defTo->optimal_fiber_length);

   copy_nddouble(from->resting_tendon_length, &to->resting_tendon_length,
                 defFrom->resting_tendon_length, defTo->resting_tendon_length);

   if (from->tendon_force_len_curve == defFrom->tendon_force_len_curve)
      to->tendon_force_len_curve = defTo->tendon_force_len_curve;
   else
   {
      to->tendon_force_len_curve = (dpSplineFunction*)simm_calloc(1, sizeof(dpSplineFunction));
      copySplineFunction(from->tendon_force_len_curve, to->tendon_force_len_curve);
   }

   if (from->active_force_len_curve == defFrom->active_force_len_curve)
      to->active_force_len_curve = defTo->active_force_len_curve;
   else
   {
      to->active_force_len_curve = (dpSplineFunction*)simm_calloc(1, sizeof(dpSplineFunction));
      copySplineFunction(from->active_force_len_curve, to->active_force_len_curve);
   }

   if (from->passive_force_len_curve == defFrom->passive_force_len_curve)
      to->passive_force_len_curve = defTo->passive_force_len_curve;
   else
   {
      to->passive_force_len_curve = (dpSplineFunction*)simm_calloc(1, sizeof(dpSplineFunction));
      copySplineFunction(from->passive_force_len_curve, to->passive_force_len_curve);
   }

   if (from->force_vel_curve == defFrom->force_vel_curve)
      to->force_vel_curve = defTo->force_vel_curve;
   else
   {
      to->force_vel_curve = (dpSplineFunction*)simm_calloc(1, sizeof(dpSplineFunction));
      copySplineFunction(from->force_vel_curve, to->force_vel_curve);
   }

   copy_nddouble(from->max_contraction_vel, &to->max_contraction_vel,
                 defFrom->max_contraction_vel, defTo->max_contraction_vel);

   to->num_dynamic_params = from->num_dynamic_params;
   if (to->num_dynamic_params > 0)
   {
      to->dynamic_param_names = dp->dynamic_param_names;
      to->dynamic_params = (double**)simm_malloc(to->num_dynamic_params * sizeof(double*));
      for (i = 0; i < to->num_dynamic_params; i++)
      {
         if (from->dynamic_params[i] == defFrom->dynamic_params[i])
            to->dynamic_params[i] = defTo->dynamic_params[i];
         else
         {
            to->dynamic_params[i] = (double*)simm_malloc(sizeof(double));
            *to->dynamic_params[i] = *from->dynamic_params[i];
         }
      }
   }
   else
   {
      to->dynamic_param_names = NULL;
      to->dynamic_params = NULL;
   }

   to->excitation_abscissa = from->excitation_abscissa;

   if (from->excitation == defFrom->excitation)
      to->excitation = defTo->excitation;
   else
   {
      to->excitation = (dpSplineFunction*)simm_calloc(1, sizeof(dpSplineFunction));
      copySplineFunction(from->excitation, to->excitation);
   }

   if (from->excitation_format == defFrom->excitation_format)
      to->excitation_format = defTo->excitation_format;
   else
   {
      to->excitation_format = (dpSplineType*)simm_malloc(sizeof(dpSplineType));
      *to->excitation_format = *from->excitation_format;
   }

   if (from->muscle_model_index == defFrom->muscle_model_index)
      to->muscle_model_index = defTo->muscle_model_index;
   else
   {
      to->muscle_model_index = (int*)simm_malloc(sizeof(int));
      *to->muscle_model_index = *from->muscle_model_index;
   }

   to->numWrapStructs = from->numWrapStructs;
   if (from->wrapStruct == defFrom->wrapStruct)
      to->wrapStruct = defTo->wrapStruct;
   else
   {
      to->wrapStruct = (dpMuscleWrapStruct**)simm_malloc(to->numWrapStructs * sizeof(dpMuscleWrapStruct*));
      for (i = 0; i < to->numWrapStructs; i++)
      {
         to->wrapStruct[i] = (dpMuscleWrapStruct*)simm_calloc(1, sizeof(dpMuscleWrapStruct));
         to->wrapStruct[i]->wrap_algorithm = from->wrapStruct[i]->wrap_algorithm;
         to->wrapStruct[i]->startPoint = from->wrapStruct[i]->startPoint;
         to->wrapStruct[i]->endPoint = from->wrapStruct[i]->endPoint;
         to->wrapStruct[i]->wrap_object = from->wrapStruct[i]->wrap_object;
      }
   }

   to->mp_array_size = *(to->num_orig_points) + (to->numWrapStructs * 2);
   to->mp = (dpMusclePoint**)simm_malloc(sizeof(dpMusclePoint*) * to->mp_array_size);

   /* When wrapping is calculated by the simulation, the mp[] array will be filled in
    * and num_points set appropriately.
    */
   to->num_points = 0;

   /* Copy the muscle's excitation format into the excitation spline structure,
    * whether or not it comes from the default muscle.
    */
   if (to->excitation && to->excitation_format)
      to->excitation->type = *to->excitation_format;
}


/* copy_nndouble: this utility function copies a double, but only if the
 * source is not NULL.
 */
ReturnCode copy_nndouble(double* from, double** to)
{
   if (from == NULL)
      *to = NULL;
   else
   {
      if ((*to = (double*)simm_malloc(sizeof(double))) == NULL)
         return code_bad;
      **to = *from;
   }

   return code_fine;
}


/* copy_nndouble: this utility function copies a double, but only if the
 * source is not equal to a default value.
 */
ReturnCode copy_nddouble(double* from, double** to, double* deffrom, double* defto)
{
   if (from == deffrom)
      *to = defto;
   else
   {
      if (from == NULL)
         *to = NULL;
      else
      {
         if ((*to = (double*)simm_malloc(sizeof(double))) == NULL)
            return code_bad;
         **to = *from;
      }
   }

   return code_fine;
}


/* copy_nndouble: this utility function copies an integer, but only if the
 * source is not NULL.
 */
ReturnCode copy_nnint(int* from, int** to)
{
   if (from == NULL)
      *to = NULL;
   else
   {
      if ((*to = (int*)simm_malloc(sizeof(int))) == NULL)
         return code_bad;
      **to = *from;
   }

   return code_fine;
}


/* sim_message: this function returns a message and error status to SIMM.
 * There is a separate version of it for the stand-alone version of a simulation.
 */
int sim_message(ErrorAction action, const char* format, ...)
{
   int n;
   va_list ap;
   static dpMessageStruct mess;

   va_start(ap, format);
   n = vsprintf(buffer, format, ap);
   va_end(ap);

   strcpy(mess.text, "SIM> ");
   strncat(mess.text, buffer, sizeof(mess.text) - 6);

   if (action == none)
      mess.id = dpNormal;
   else if (action == recover)
      mess.id = dpSimWarning;
   else if (action == abort_action)
      mess.id = dpSimError;
   else
      mess.id = dpFinished;

   dataCallbackFunc(sdm->simmModel, dpMessage, &mess);

   return n;
}
