/*******************************************************************************

   SDUFUNCS.C

   Authors: Peter Loan
            Krystyne Blaikie

   Copyright (c) 1996-2004 MusculoGraphics, a division of Motion Analysis Corp.
   All rights reserved.

   Description: This file contains the main routine for a dynamics
		simulation, and several other utility functions that are
		independent of the musculoskeletal model in the simulation.
		This file is generated by SIMM when you choose the
		"project files" option in the "Save Dynamics" dialog box.
		You will probably want to generate it once and then customize
		it to your specific simulation.

*******************************************************************************/
#include "universal.h"

/*************** DEFINES (for this file only) *********************************/

/* Tolerances and Integration parameters. */
#define ASSEMBLY_TOL 1e-7

/*************** STATIC GLOBAL VARIABLES (for this file only) *****************/


/**************** GLOBAL VARIABLES (used in only a few files) *****************/


/*************** EXTERNED VARIABLES (declared in another file) ****************/
extern SystemInfo si;
extern MotionData* kinetics_data;
extern dpSimulationParameters params;
extern dpModelStruct* sdm;
extern char buffer[];

/*************** PROTOTYPES for STATIC FUNCTIONS (for this file only) *********/



/* This routine (called by integrate()) computes system derivatives, given the 
 * time and state of the system.  It returns a user flag if impacts are found.
 */
void calc_derivatives(double t, double y[], double dy[], double param[], int *status)
{
   int i, err;
#if CONTACT_DETECTION
   int calc_impact = NO;
#endif

	*status = NO_FLAG;

	sdstate(t, y, &y[sdm->nq]);
	err = check_for_sderror("CALC_DERIVATIVES");
	if (err)
      goto allDone;

	/* calc muscle derivatives */
	calc_muscle_derivatives(t, y, dy, param, &err);

	sdumotion(t, y, &y[sdm->nq]);
	sduforce(t, y, &y[sdm->nq]);
	sdderiv(dy, &dy[sdm->nq]);

#if CONTACT_DETECTION
	/* determine contact points */
	determine_contacts(y, dy);
	get_contact_info();
   get_bilat_contact_info();

	if (sdm->num_contacts == 0)
      goto allDone;

   /* Check for impacts. If any are found, set the flag and return. */
   if (param[0] < 0.0)
   {
      for (i = 0; i < sdm->num_contacts; i++)
      {
         if ((sdm->contacts[i].contact_type == dpImpact))
         {
            *status = IMPACT_FLAG;
            goto allDone;
         }
      }
   }

	/* if no impacts were found, find resting contact forces, apply them,
	 * and calculate accelerations
    */
	sdstate(t, y, &y[sdm->nq]);
	sdumotion(t, y, &y[sdm->nq]);
	sduforce(t, y, &y[sdm->nq]);

   compute_contact_forces(calc_impact);
	apply_forces_at_contacts(sdm->num_contacts, sdm->contacts);

	sdderiv(dy, &dy[sdm->nq]);
#endif

	err = check_for_sderror("CALC_DERIVATIVES: alldone");

allDone:
    /* We're done with calculating derivatives.  If an error occurred, we'll
     * assume it means the integrator picked a bad time/state for this guess,
     * and we'll reject the guess.  This will make the integrator cut its
     * step size, hopefully producing a better guess next time.
     *
     * If the error is "singular mass matrix" we'll ignore it, however,
     * since in this case that's just an artifact of our use of massless
     * frames when in certain configurations and does not actually cause
     * problems.
     *
     * If we reject this guess, we'll clear out dy[] which may contain
     * garbage (e.g. NaNs) resulting from the bad state.
     */
	if (err == 43 || err == 44)
   {
      print_final_information(t, y, dy, &si);
      sim_message(exit_program, "A joint is in gimbal lock.");
   }
   if ((err != 0) && (err != 47))
   {
		sim_message(none, "BAD STATE");
		print_state(y, dy);
		*status = BAD_STATE;
		sim_message(exit_program, "deriv");
   } 

}


/* SDUFORCE: this function is used to apply forces to the body segments.
 * The first section of code determines the current frame for the external
 * force data, if any exist. You may want to change this code, depending
 * on what type of external force[s] you want to apply, and how many
 * frames of data there are. Sduforce() then calls the functions to
 * apply the muscles forces, the restraint torques, and the external
 * forces, respectively.  It also calls the functions to apply spring
 * forces for spring-based contact.
 */

int sduforce(double t, double q[], double u[])
{

	if (kinetics_data)
      apply_external_forces(t, kinetics_data);
	
   apply_muscle_forces(sdm);

   apply_joint_restraint_torques(sdm, q, u);

   apply_spring_forces(sdm);

   check_for_sderror("SDUFORCE");

   return 1;
}

/* Apply prescribed motions to fixed and prescribed gencoords */
int sdumotion(double t, double q[], double u[])
{

   set_fixed_gencoords(sdm);

   set_prescribed_gencoords(t, q, u, sdm, kinetics_data);

   return 1;

}


/* calculate position errors for constrained gencoords */
void sduperr(double t, double q[], double errors[])
{
   int i, j, q_ind, constraint_num;
   double q_ind_value, q_dep_value, q_value, u_ind_value = 0.0, a_ind_value = 0.0;
   dpConstraintObject *co;

   /* constrained gencoords */
   for (i=0; i<sdm->nq; i++)
   {
      if (sdm->q[i].type == dpConstrainedQ)
      {
         q_ind = sdm->q[i].q_ind;
         q_ind_value = q[q_ind] * sdm->q[q_ind].conversion;
         q_dep_value = q[i];
         q_value = interpolate_spline(q_ind_value, sdm->q[i].constraint_func,
            zeroth, u_ind_value, a_ind_value) / sdm->q[i].conversion;
         errors[sdm->q[i].constraint_num] = q_dep_value - q_value;
      }
   }

   /* constraint objects */
   if (sdm->enforce_constraints == 1)
   {
      for (i = 0; i < sdm->num_constraint_objects; i++)
      {
         co = &sdm->constraint_object[i];
         if (co->active == dpNo)
            continue;
         for (j = 0; j < co->numPoints; j++)
         {
            constraint_num = co->points[j].constraint_num;
            errors[constraint_num] = calculate_constraint_position_error(co, PERR, j);
         }
      }
   }
}


/* calculate velocity errors for constrained gencoords */
void sduverr(double t, double q[], double u[], double errors[])
{
   int i, j, q_ind, constraint_num;
   double q_ind_value, u_ind_value, u_dep_value, a_ind_value = 0.0, v_value;
   dpConstraintObject *co;

   /* constrained gencoords */
   for (i=0; i<sdm->nq; i++)
   {
      if (sdm->q[i].type == dpConstrainedQ)
      {
         q_ind = sdm->q[i].q_ind;
         q_ind_value = q[q_ind] * sdm->q[q_ind].conversion;
         u_ind_value = u[q_ind] * sdm->q[q_ind].conversion;
         u_dep_value = u[i];
         v_value = interpolate_spline(q_ind_value, sdm->q[i].constraint_func,
            first, u_ind_value, a_ind_value)/sdm->q[i].conversion;
         errors[sdm->q[i].constraint_num] = u_dep_value - v_value;
      }
   }

   /* constraint objects */
   if (sdm->enforce_constraints == 1)
   {
      for (i = 0; i < sdm->num_constraint_objects; i++)
      {
         co = &sdm->constraint_object[i];
         if (co->active == dpNo)
            continue;

         for (j = 0; j < co->numPoints; j++)
         {
            constraint_num = co->points[j].constraint_num;
            errors[constraint_num] = calculate_constraint_velocity_error(co, j);
         }
      }
   }
}



/* calculate acceleration errors for constrained gencoords */
void sduaerr(double t, double q[], double u[], double udot[], double errors[])
{
   int i, j, q_ind, constraint_num;
   double q_ind_value, u_ind_value, a_ind_value, a_dep_value;
   double a_value;
   dpConstraintObject *co;

   /* constrained gencoords */
   for (i=0; i<sdm->nq; i++)
   {
      if (sdm->q[i].type == dpConstrainedQ)
      {
	      q_ind = sdm->q[i].q_ind;
	      q_ind_value = q[q_ind] * sdm->q[q_ind].conversion;
	      u_ind_value = u[q_ind] * sdm->q[q_ind].conversion;
	      a_ind_value = udot[q_ind] * sdm->q[q_ind].conversion;
	      a_dep_value = udot[i];
         a_value = interpolate_spline(q_ind_value, sdm->q[i].constraint_func, second,
            u_ind_value, a_ind_value)/sdm->q[i].conversion;
         errors[sdm->q[i].constraint_num] = a_dep_value - a_value;
      }
   }

   /* constraint objects */
   if (sdm->enforce_constraints == 1)
   {
      for (i = 0; i < sdm->num_constraint_objects; i++)
      {
         co = &sdm->constraint_object[i];
         if (co->active == dpNo)
            continue;

         for (j = 0; j < co->numPoints; j++)
         {
            constraint_num = co->points[j].constraint_num;
            errors[constraint_num] = calculate_constraint_acceleration_error(co, j);
         }
      }
   }
}


/* calculate and apply constraint forces for constrained gencoords */
void sduconsfrc(double t, double q[], double u[], double mults[])
{
   int i, j, q_ind, constraint_num;
   double q_ind_value, torque, u_ind_value, a_ind_value = 0.0, int_spline;
   dpConstraintObject *co;
 
   for (i=0; i<sdm->nq; i++)
   {
      if (sdm->q[i].type == dpConstrainedQ)
      {
         q_ind = sdm->q[i].q_ind;
         q_ind_value = q[q_ind] * sdm->q[q_ind].conversion;
         u_ind_value = sdm->q[q_ind].conversion;

	      sdhinget(sdm->q[i].joint,sdm->q[i].axis,mults[sdm->q[i].constraint_num]);

         int_spline = interpolate_spline(q_ind_value, sdm->q[i].constraint_func,
            first, u_ind_value, a_ind_value) / sdm->q[i].conversion;
         torque = -mults[sdm->q[i].constraint_num] * int_spline;

         sdhinget(sdm->q[q_ind].joint,sdm->q[q_ind].axis,torque);
      }
   }

   /* constraint objects */
   for (i = 0; i < sdm->num_constraint_objects; i++)
   {
      co = &sdm->constraint_object[i];
      if (co->active == dpNo)
         continue;

      for (j = 0; j < co->numPoints; j++)
      {
         constraint_num = co->points[j].constraint_num;
         apply_constraint_forces(co, mults[constraint_num], j);
      }
   }
   check_for_sderror("SDUCONSFRC");

}

/************* Initialization Routines **************/

/* Set on/off state of prescribed motion for all Qs based on their types */
void init_motion(void)
{

   set_prescribed_motion(sdm, dpUnconstrainedQ, 0);
   set_prescribed_motion(sdm, dpConstrainedQ, 0);
   set_prescribed_motion(sdm, dpPrescribedQ, 1); 
   set_prescribed_motion(sdm, dpFixedQ, 1);

   check_for_sderror("INIT_MOTION");

}


/* Set initial conditions for all Qs in the model. The initial values
 * and velocities of all Qs, regardless of type, are set here. Values
 * for unconstrained Qs are taken from the 'initial_value' field in the
 * sdm struct.
 */
void set_initial_conditions(double *t, double y[], double dy[])
{

   int i;
   double q_ind_value;

   *t = params.startTime;

   for (i = 0; i < sdm->neq; i++)
      y[i] = dy[i] = 0.0;
	
   for (i = 0; i < sdm->nq; i++)
   {
      if (sdm->q[i].type != dpConstrainedQ)
      {
         y[i] = sdm->q[i].initial_value/sdm->q[i].conversion;
      }
   }

   for (i = 0; i < sdm->nq; i++)
   {
      if (sdm->q[i].type == dpConstrainedQ)
      {
         if (sdm->q[i].constraint_func == NULL)
            sim_message(exit_program, "Constrained gencoord %s does not have a function defined.", sdm->q[i].name);

         if (sdm->q[i].constraint_num == -1)
            sim_message(exit_program, "Constrained gencoord %s does not have an associated constraint number.", sdm->q[i].name);

         if (sdm->q[i].q_ind == -1)
            sim_message(exit_program, "Constrained gencoord %s does not have an independent q.", sdm->q[i].name);

         q_ind_value = y[sdm->q[i].q_ind] * sdm->q[sdm->q[i].q_ind].conversion;
         y[i] = interpolate_spline(q_ind_value,sdm->q[i].constraint_func,zeroth,0.0,0.0) / sdm->q[i].conversion;
      }
   }

   for (i = 0; i < sdm->nq; i++) 
   {
      if (sdm->q[i].type != dpFixedQ)
      {
         y[i + sdm->nq] = dy[i] = sdm->q[i].initial_velocity / sdm->q[i].conversion;
      }
      else
      {
         if (sdm->q[i].initial_velocity != 0.0)
            sim_message(none, "Warning: initial velocity for %s (FIXED) was not 0.0. Setting to zero...",
                        sdm->q[i].name);
         y[i + sdm->nq] = dy[i] = 0.0;
      }
   }
}


/* Assmeble the model, and make sure the gencoord velocities
 * are properly set.
 */
void assemble_model(double t, double y[])
{
   int i, fcnt, err, *lock;

   lock = (int*)simm_malloc(sdm->nq * sizeof(int));

   for (i = 0; i < sdm->nq; i++)
   {
      if (sdm->q[i].type == dpFixedQ)
         lock[i] = 1;
      else
         lock[i] = 0;
   }

   /* assemble model */
   sdassemble(t, y, lock, ASSEMBLY_TOL, 500, &fcnt, &err);
   if (err)
   {
      sim_message(none, "Assembly failed, err = %d.", err);
      sim_message(none, "Closest solution:");
      for (i = 0; i < sdm->nu; i++)
         sim_message(none, "%s = %lf (%d)", sdm->q[i].name, y[i], lock[i]);
      sim_message(exit_program, "");
   }

   /* You may want to call verify_assembly() if you know for sure that
    * none of the gencoords should be outside their range of motion.
   if (verify_assembly(sdm,y) == code_bad)
      sim_message(exit_program, "Verify assembly failed.");
    */

   sdinitvel(t, y, lock, ASSEMBLY_TOL, 500, &fcnt, &err);
   if (err)
   {
      sim_message(none, "Velocity analysis failed.");
      sim_message(exit_program, "Check that prescribed gencoord velocities are not being set to new values.");
   }

   free(lock);

}



void set_up_kinetics_input(char filename[], MotionData** data)
{
   int i, index_pres = -1;

   if ((*data = (MotionData*)simm_calloc(1, sizeof(MotionData))) == NULL)
   {
      sim_message(exit_program, "Unable to allocate enough memory to run.");
      return;
   }
   else if (load_kinetics_data(sdm, *data, filename) == code_bad)
   {
      /* You could try to recover from an error reading the kinetics/motion
       * file, but it's probably serious enough to exit and make the user
       * fix the problem.
       */
      free_motion_data(*data);
      FREE_IFNOTNULL(*data);
      sim_message(exit_program, "Encountered fatal error while reading %s.", filename);
      return;
   }

   /* Copy the enforce_constraints parameter from the motion into the model structure.
    * This parameter is 1 by default, but can be set to 0 in the motion if the motion
    * contains data for all of the gencoords affected by the constraint objects.
    */
   sdm->enforce_constraints = (*data)->enforce_constraints;

   /* If there is position, velocity, and acceleration data for a Q in the
    * kinetics file, make it prescribed.
    */
   if ((*data)->q_data)
   {
      int position_present, velocity_present, acceleration_present;

      for (i = 0; i < sdm->nq; i++)
      {
         /* Position data must be explicitly specified (though it can be splined or not).
          * Velocity can either be specified explicitly, or calculated from position
          * (if position data is splined). Acceleration can be specified explicitly or
          * calculated from position or velocity.
          */
         position_present = (int)((*data)->q_data[i]);
         velocity_present = (*data)->u_data[i] ||
                            ((*data)->q_data[i] && (*data)->q_data[i]->type != dpStepFunction);
         acceleration_present = (*data)->udot_data[i] ||
                                ((*data)->q_data[i] && (*data)->q_data[i]->type != dpStepFunction) ||
                                ((*data)->u_data[i] && (*data)->u_data[i]->type != dpStepFunction);

         if (sdm->q[i].type == dpFixedQ)
         {
            if (position_present || velocity_present || acceleration_present)
            {
               sim_message(recover, "Warning: Pos, vel, and/or acc data for fixed Q %s was specified in %s.",
                      sdm->q[i].name, filename);
               sim_message(none, "Data will be ignored.");
            }
         }
         else if (sdm->q[i].type == dpConstrainedQ)
         {
            if (position_present || velocity_present || acceleration_present)
            {
               sim_message(recover, "Warning: Pos, vel, and/or acc data for constrained Q %s was specified in %s.",
                      sdm->q[i].name, filename);
               sim_message(none, "Data will be ignored.");
            }
         }
         else
         {
            if (position_present && velocity_present && acceleration_present)
            {
               sdm->q[i].type = dpPrescribedQ;
               index_pres = i;
            }
            else if (position_present || velocity_present || acceleration_present)
            {
               if (!position_present)
               {
                  sim_message(recover, "Warning: Position data for %s was not specified in %s.",
                     sdm->q[i].name, filename);
                  sim_message(none, "Gencoord will not be prescribed.");
               }
               else if (!velocity_present)
               {
                  sim_message(recover, "Warning: Velocity data for %s was not specified in %s.",
                     sdm->q[i].name, filename);
                  sim_message(none, "Gencoord will not be prescribed.");
               }
               else if (!acceleration_present)
               {
                  sim_message(recover, "Warning: Acceleration data for %s was not specified in %s.",
                     sdm->q[i].name, filename);
                  sim_message(none, "Gencoord will not be prescribed.");
               }
            }
         }
      }
   }

   /* If all unconstrained gencoords are prescribed with data in the
    * kinetics file, then this is really more of an inverse dynamics
    * simulation than a forward one. So override the default values
    * of params.start_time, params.end_time, and params.step_size to
    * match the data in the kinetics file.
    */
   for (i = 0; i < sdm->nq; i++)
   {
      if (sdm->q[i].type == dpUnconstrainedQ)
         break;
   }
   if (i == sdm->nq)
   {
      /* No gencoords are left as unconstrained. Use index_pres, which is the
       * index of one of the Qs that is prescribed in the file, to get the
       * time of the first and last frames of data in the file. Divide this
       * time range by the number of frames to get the step size (reporting
       * interval) for the integrator.
       */
      params.startTime = (*data)->q_data[index_pres]->x[0];
      params.endTime = (*data)->q_data[index_pres]->x[(*data)->q_data[index_pres]->numpoints - 1];
      params.stepSize = (params.endTime - params.startTime) / ((*data)->q_data[index_pres]->numpoints - 1);
      sim_message(none, "All unconstrained Qs are prescribed with data from %s.", filename);
      sim_message(none, "   assuming inverse dynamics analysis, changing:");
      sim_message(none, "      start time to %lf", params.startTime);
      sim_message(none, "      end time to   %lf", params.endTime);
      sim_message(none, "      step size to  %lf", params.stepSize);
   }
}

